<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="1 算法及其复杂性分析 1.1 渐进时间复杂性定义 只考大O、大Ω 1.1.1 渐进上界 big-O O f(n) 的渐进上界是 g(n)，0 &lt;= f(n) &lt;= cg(n)\n即，f(n)的阶不高于g(n)的阶 ——f上升规模/档次不快于于g 并不是f(n) &lt;= g(n) 意味着f(n) 的最高阶 &lt;= g(n) 的最高阶 找到一个 常数c 和n0\nf(n)=5n^2 +1, g(n)=2n^2, n0=1, c=3 6n^2 &gt;= 5n^2 +1 当n &gt;= 1 1.1.2 渐进下界 Ω f(n) 的渐进下界是 g(n)， 0 &lt;= cg(n) &lt;= f(n)\n">
<title>算法设计与分析 大三上</title>

<link rel='canonical' href='https://ffirestorm.github.io/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="算法设计与分析 大三上">
<meta property='og:description' content="1 算法及其复杂性分析 1.1 渐进时间复杂性定义 只考大O、大Ω 1.1.1 渐进上界 big-O O f(n) 的渐进上界是 g(n)，0 &lt;= f(n) &lt;= cg(n)\n即，f(n)的阶不高于g(n)的阶 ——f上升规模/档次不快于于g 并不是f(n) &lt;= g(n) 意味着f(n) 的最高阶 &lt;= g(n) 的最高阶 找到一个 常数c 和n0\nf(n)=5n^2 +1, g(n)=2n^2, n0=1, c=3 6n^2 &gt;= 5n^2 +1 当n &gt;= 1 1.1.2 渐进下界 Ω f(n) 的渐进下界是 g(n)， 0 &lt;= cg(n) &lt;= f(n)\n">
<meta property='og:url' content='https://ffirestorm.github.io/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/'>
<meta property='og:site_name' content='ffirestorm'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2024-09-20T09:23:06&#43;08:00'/><meta property='article:modified_time' content='2024-09-20T09:23:06&#43;08:00'/>
<meta name="twitter:title" content="算法设计与分析 大三上">
<meta name="twitter:description" content="1 算法及其复杂性分析 1.1 渐进时间复杂性定义 只考大O、大Ω 1.1.1 渐进上界 big-O O f(n) 的渐进上界是 g(n)，0 &lt;= f(n) &lt;= cg(n)\n即，f(n)的阶不高于g(n)的阶 ——f上升规模/档次不快于于g 并不是f(n) &lt;= g(n) 意味着f(n) 的最高阶 &lt;= g(n) 的最高阶 找到一个 常数c 和n0\nf(n)=5n^2 +1, g(n)=2n^2, n0=1, c=3 6n^2 &gt;= 5n^2 +1 当n &gt;= 1 1.1.2 渐进下界 Ω f(n) 的渐进下界是 g(n)， 0 &lt;= cg(n) &lt;= f(n)\n">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu9742106442265571223.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🤪</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">ffirestorm</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/CaiJimmy/hugo-theme-stack'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://ffirestorm.github.io/en/" >English</option>
                                
                                    <option value="https://ffirestorm.github.io/" selected>简体中文</option>
                                
                                    <option value="https://ffirestorm.github.io/ar/" >عربي</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#1-算法及其复杂性分析">1 算法及其复杂性分析</a>
      <ol>
        <li><a href="#11-渐进时间复杂性定义-只考大o大ω">1.1 渐进时间复杂性定义 只考大O、大Ω</a>
          <ol>
            <li><a href="#111-渐进上界-big-o-o">1.1.1 渐进上界 big-O O</a></li>
            <li><a href="#112-渐进下界-ω">1.1.2 渐进下界 Ω</a></li>
            <li><a href="#113-非紧上界-o-不考">1.1.3 非紧上界 o 不考</a></li>
            <li><a href="#114-非紧下界-w-不考">1.1.4 非紧下界 w 不考</a></li>
            <li><a href="#115-紧渐进界-θ-不考">1.1.5 紧渐进界 Θ 不考</a></li>
          </ol>
        </li>
        <li><a href="#12-例题">1.2 例题</a></li>
        <li><a href="#13-算法时间复杂性">1.3 算法时间复杂性</a></li>
      </ol>
    </li>
    <li><a href="#2-递归和分治">2 递归和分治</a>
      <ol>
        <li><a href="#分治经典算法">分治经典算法</a>
          <ol>
            <li><a href="#分治法设计方法">分治法设计方法</a></li>
            <li><a href="#归并排序">归并排序</a></li>
            <li><a href="#快速排序">快速排序</a></li>
            <li><a href="#线性时间选择">线性时间选择</a></li>
          </ol>
        </li>
        <li><a href="#采用特征方程求解递归方程">采用特征方程求解递归方程</a>
          <ol>
            <li><a href="#无重根的例子">无重根的例子</a></li>
            <li><a href="#有重根的例子">有重根的例子</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#3-动态规划">3 动态规划</a>
      <ol>
        <li><a href="#动态规划算法基本要素">动态规划算法基本要素</a>
          <ol>
            <li><a href="#最优子结构">最优子结构</a></li>
          </ol>
        </li>
        <li><a href="#经典算法">经典算法</a>
          <ol>
            <li><a href="#矩阵连乘">矩阵连乘</a></li>
            <li><a href="#最长公共子序列">最长公共子序列</a></li>
            <li><a href="#最大子段和">最大子段和</a></li>
            <li><a href="#01-背包">0/1 背包</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#4-贪心法">4 贪心法</a>
      <ol>
        <li><a href="#贪心选择性质">贪心选择性质</a></li>
        <li><a href="#算法">算法</a>
          <ol>
            <li><a href="#背包问题">背包问题</a></li>
            <li><a href="#最优装载问题">最优装载问题</a></li>
            <li><a href="#单源最短路径">单源最短路径</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#5-回溯法">5 回溯法</a>
      <ol>
        <li><a href="#算法-1">算法</a>
          <ol>
            <li><a href="#tsp">TSP</a></li>
            <li><a href="#n-后问题">n-后问题</a></li>
            <li><a href="#图的m着色问题">图的m着色问题</a></li>
            <li><a href="#0-1-背包问题">0-1 背包问题</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#6-分支限界法">6 分支限界法</a>
      <ol>
        <li><a href="#算法-2">算法</a>
          <ol>
            <li><a href="#旅行商问题">旅行商问题</a></li>
            <li><a href="#0-1-背包问题-1">0-1 背包问题</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/">算法设计与分析 大三上</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-09-20</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 16 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="1-算法及其复杂性分析">1 算法及其复杂性分析
</h2><h3 id="11-渐进时间复杂性定义-只考大o大ω">1.1 渐进时间复杂性定义 只考大O、大Ω
</h3><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-3.png"
	width="604"
	height="305"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-3_hu6808695435002203554.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-3_hu12589892647487952544.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="198"
		data-flex-basis="475px"
	
></p>
<h4 id="111-渐进上界-big-o-o">1.1.1 渐进上界 big-O O
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image.png"
	width="1189"
	height="435"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image_hu15274118279278559291.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image_hu6937760358157518004.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="273"
		data-flex-basis="656px"
	
>
f(n) 的渐进上界是 g(n)，0 &lt;= f(n) &lt;= cg(n)</p>
<pre><code>即，f(n)的阶不高于g(n)的阶 ——f上升规模/档次不快于于g
并不是f(n) &lt;= g(n)

意味着f(n) 的最高阶 &lt;= g(n) 的最高阶
</code></pre>
<p>找到一个 常数c 和n0</p>
<pre><code>f(n)=5n^2 +1, g(n)=2n^2, n0=1, c=3
6n^2 &gt;= 5n^2 +1  当n &gt;= 1
</code></pre>
<h4 id="112-渐进下界-ω">1.1.2 渐进下界 Ω
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-1.png"
	width="1179"
	height="408"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-1_hu4229870830235623614.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-1_hu7490055651666909368.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="288"
		data-flex-basis="693px"
	
>
f(n) 的渐进下界是 g(n)， 0 &lt;= cg(n) &lt;= f(n)</p>
<pre><code>即f(n)的阶不低于g(n)的阶——f上升规模/档次不慢于g

意味着 f(n) 的最高阶 &gt;= g(n)的最高阶
</code></pre>
<p>例子</p>
<pre><code>f(n)=5n^2 +1，g(n)=10n^1.5
c = 1
0 &lt;= g(n) &lt;= f(n) 当n&gt;4时
</code></pre>
<h4 id="113-非紧上界-o-不考">1.1.3 非紧上界 o 不考
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-2.png"
	width="1206"
	height="396"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-2_hu14790402056231709650.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-2_hu14386316437341636970.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="304"
		data-flex-basis="730px"
	
></p>
<pre><code>要对于任何的正常数c，这就意味着，g的阶一定要比f的阶高
阶：g &gt; f
n -&gt; ∞ 时， f/g -&gt; 0
要求比渐进上界严格许多
</code></pre>
<h4 id="114-非紧下界-w-不考">1.1.4 非紧下界 w 不考
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-4.png"
	width="1211"
	height="418"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-4_hu2081089705977592313.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-4_hu7983348918885229065.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="289"
		data-flex-basis="695px"
	
></p>
<pre><code>对于任意的正常数c
f 的阶一定要比 g 的阶高
f(n) / g(n) -&gt; ∞ ，当  n -&gt; ∞
</code></pre>
<h4 id="115-紧渐进界-θ-不考">1.1.5 紧渐进界 Θ 不考
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-5.png"
	width="1173"
	height="321"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-5_hu4893523542032916001.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-5_hu8132489469357142311.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="365"
		data-flex-basis="877px"
	
></p>
<h3 id="12-例题">1.2 例题
</h3><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-6.png"
	width="928"
	height="295"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-6_hu5548828950403415974.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-6_hu12265149101929051754.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="314"
		data-flex-basis="754px"
	
></p>
<p>对于1：找到一个正常数c，和一个n0，使得对于任意的 n&gt;n0 ， f(n) &lt;= cg(n)</p>
<p>对于2这种题，类似的有：证明O(f(n))+O(g(n)) = O(max{f(n),g(n)})</p>
<pre><code>Step1. 
    根据O的含义，对于任意f1(n) ∈ O(f(n)) ，存在正常数c1和自然数n1，使得对所有n&gt;= n1，有f1(n) &lt;= c1f(n) 
Step2. 
    类似地，对于任意g1(n) ∈ O(g(n)) ，存在正常数c2和自然数n2，使得对所有n &gt;= n2，有g1(n) &lt;= c2g(n) 
Step3. 
    令c3=max{c1, c2}， n3 =max{n1, n2}，h(n)= max{f1(n),g1(n)} ，则对所有的 n &gt;= n3，有：

        f1(n) +g1(n) 
        &lt;= c1f(n) + c2g(n) 
        &lt;= c3f(n) + c3g(n)= c3(f(n) + g(n))   
        &lt;= c3 * 2 *max{f(n),g(n)}
        = 2 * c3 *h(n)  
        = c4 * h(n) 
        = O(max{f(n),g(n)}) 
</code></pre>
<h3 id="13-算法时间复杂性">1.3 算法时间复杂性
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">key</span><span class="p">;</span>                           <span class="c1">//   cost        times
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>        <span class="c1">//    c1          n   
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">key</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>                     <span class="c1">//    c2          n-1 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>                    <span class="c1">//    c3          n-1 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="k">while</span><span class="p">(</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">key</span> <span class="p">){</span>    <span class="c1">//    c4        sum of  ti
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">// ti：满足循环条件j&gt;=0 &amp;&amp; a[j]&gt;key的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>                  <span class="c1">//    c5        sum of (ti-1) 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">j</span><span class="o">--</span><span class="p">;</span>                          <span class="c1">//    c6        sum of (ti-1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>     <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">key</span><span class="p">;</span>                    <span class="c1">//    c7          n-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-7.png"
	width="1164"
	height="175"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-7_hu16477806305786393314.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-7_hu16199132886169911292.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="665"
		data-flex-basis="1596px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-8.png"
	width="1087"
	height="242"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-8_hu11557383883895958466.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-8_hu235876649392210028.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="449"
		data-flex-basis="1078px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-9.png"
	width="1133"
	height="585"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-9_hu12077851575386858296.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-9_hu7735752608211225377.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="193"
		data-flex-basis="464px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-10.png"
	width="1148"
	height="475"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-10_hu1694162090691201882.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-10_hu14214801541792422769.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="241"
		data-flex-basis="580px"
	
></p>
<h2 id="2-递归和分治">2 递归和分治
</h2><p>审查一遍</p>
<pre><code>递归概念，递归法的原理/步骤（了解）
分治法基本原理/步骤、适用条件（了解）

递归函数（了解）
了解概念

用特征方程解递归方程
    线性齐次递归方程
    做题！
    注意：特征方程有重根的情况
不要求会线性非齐次递归方程
</code></pre>
<p>要求：面向特定问题的具体算法</p>
<pre><code>原理
步骤，或代码/伪代码， C/C++/Java/Python
说明时间复杂性
最好/最坏/平均时间复杂性，大O
计算示例：针对给定输入，给出算法步骤、执行结果
</code></pre>
<p>掌握以下算法：</p>
<pre><code>快速排序
合并排序
线性时间选择
</code></pre>
<h3 id="分治经典算法">分治经典算法
</h3><h4 id="分治法设计方法">分治法设计方法
</h4><p>适用问题：</p>
<pre><code>1. 当问题规模缩小的一定程度就可以容易地解决
2. 可以分解为若干个规模较小的相同问题，该问题具有最优子结构性质
3. 利用该问题分解出的子问题的解可以合并为该问题的解
4. 该问题分解出的各个子问题是相互独立的
</code></pre>
<p>基本步骤</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">devide_and_conquer</span><span class="p">(</span><span class="n">P</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="o">|</span><span class="n">P</span><span class="o">|</span> <span class="o">&lt;=</span> <span class="n">n0</span><span class="p">)</span> <span class="nf">adhoc</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>    <span class="c1">//解决小规模问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">divide</span> <span class="n">P</span> <span class="n">into</span> <span class="n">smaller</span> <span class="n">subinstances</span> <span class="n">P1</span><span class="p">,</span><span class="n">P2</span><span class="p">...,</span><span class="n">Pk</span><span class="p">;</span>     <span class="c1">// 分解问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>      <span class="c1">// 串行、并行地递归地解各子问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">yi</span> <span class="o">=</span> <span class="nf">divide_and_conquer</span><span class="p">(</span><span class="n">Pi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">merge</span><span class="p">(</span><span class="n">y1</span><span class="p">,...,</span><span class="n">yk</span><span class="p">);</span> <span class="c1">//将各子问题的解合并为原问题的解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>在用分治法设计算法时，从平衡(balancing)子问题、提高算法效率角度出发，应尽可能使分解后的各个子问题的规模大致相同，即将一个问题分成大小相等的k个子问题
</code></pre>
<h4 id="归并排序">归并排序
</h4><p>原理</p>
<pre><code>将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序
    目标：非递减序
合并两个排好序的子集合，得到排好序的原集合
</code></pre>
<p>递归合并排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">Type</span> <span class="n">c</span><span class="p">[</span> <span class="p">],</span> <span class="n">Type</span> <span class="n">d</span><span class="p">[</span> <span class="p">],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 合并已经排好序（递增）的源c[l : m]、c[m+1: r]到目标数组d[l:r] 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">,</span>   <span class="c1">//左子段的搜索比较指针的起点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">j</span><span class="o">=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="c1">//右子段的搜索比较指针的起点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">k</span><span class="o">=</span><span class="n">l</span><span class="p">;</span>      <span class="c1">//目标数组d的指针起点，符合递增顺序的c[ ]中的元素被拷贝至d[k]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">))</span>     
</span></span><span class="line"><span class="cl">      <span class="c1">//左子段比较元素c[i]小于右子段比较元素c[j]，左子段元素c[i]移至d[k]，指针i、k后移; 否则，右子段元素c[j]移至d[k]，指针j、k后移
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>   
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">)</span>    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">)</span>    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 自顶向下
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>                 <span class="c1">//*至少有2个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="p">(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>             <span class="c1">//*取中点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">mergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>            <span class="c1">//*左子问题求解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">mergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>         <span class="c1">//*右子问题求解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>      <span class="c1">//合并、copy到数组b, 关键 ! 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>          <span class="c1">//复制回数组a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-11.png"
	width="1086"
	height="626"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-11_hu1606448321226405230.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-11_hu8807478017804882123.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="173"
		data-flex-basis="416px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-12.png"
	width="1112"
	height="495"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-12_hu9065517693299752910.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-12_hu7774633537875798441.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="224"
		data-flex-basis="539px"
	
></p>
<p>非递归合并排序</p>
<p>改进</p>
<pre><code>省略自上而下的分解过程，将a[]中相邻元素两两配对，作为最底层子问题，由下而上使用merge过程，进行排序
消除排序中的递归
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">//合并x[]中长度为s的内部已排序的多对相邻子数组；合并结果放在y[]中，y[]内部包括长度为2s的多对相邻有序子数组；x、y中元素总数n
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">MergePass</span><span class="p">(</span><span class="n">Type</span> <span class="n">x</span><span class="p">[],</span> <span class="n">Type</span> <span class="n">y</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span>  <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>  <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">//合并x[]中的已排序的长度s的2个相邻子段x[i,i+s-1]、[i+s,i+2s-1]，结果放在y[]中, e.g.i=0, s=2时，x[0,1]、x[2,3]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">Merge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 剩下的元素x[i,n-1]的个数少于2s(e.g.2s=4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 剩余未处理的子段x[i,n-1]，如果其长度大于s、小于2s，e.g.    i=12, s=2， i+s=14 &lt;= n=15， x[i,n-1]内部没有完全排好序，合并长度=s的x[i,i+s-1]={0,18}、长度&lt;s的x[i+s,n-1]={16};  如果子段x[i,n-1]长度n-i&lt;s, i+s&gt;n, e.g n=14, 不包括最后元素{18}，剩余子段{0，16}内部已排序，将其copy至y[]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">)</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Type</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>    <span class="c1">//创建数组b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//自下而上，从长度为s=1的子序列对（数组中2个相邻的元素对）开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span>  <span class="p">(</span><span class="n">s</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">MergePass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">        <span class="c1">//将源数组a[]中长度为s的子序列对（2个长度为s的相邻子序列），合并到目标数组b；  合并完后，长度s增加，为下次合并做准备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="o">+=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//将b []中长度为s的子序列对，合并到数组a；  合并完后，长度s增加，为下次合并做准备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="nf">MergePass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>   <span class="c1">//合并到数组a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">s</span><span class="o">+=</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="快速排序">快速排序
</h4><p>原理</p>
<pre><code>对输入的待排序数组a[p:r]
1. 分解
    按照一定的规则，从中选择x=a[q]，以a[q]为基准元素，将数组a划分为三段a[p:q-1], a[q], a[q+1:r]，使得a[p:q-1]中的元素均小于等于a[q]，a[q+1:r]的元素均大于a[q]
2. 递归求解
    递归调用快排算法，对a[p:q-1]和a[q+1:r] 分别排序
3. 合并
    不需要做任何计算
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Partition</span> <span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">Type</span> <span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="c1">// *第1个元素作为比较基准
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 将&lt; x的元素交换到左边区域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 将&gt; x的元素交换到右边区域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">           <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="p">);</span>   <span class="c1">//扩展左端a[p:i]，左→右搜索大元素a[i]&gt;=x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">-</span> <span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span><span class="n">x</span><span class="p">);</span>         <span class="c1">//扩展右端a[j:r]，左←右搜索小元素a[i]&lt;=x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>           
</span></span><span class="line"><span class="cl">           <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">           <span class="nf">Swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">           <span class="p">}</span>
</span></span><span class="line"><span class="cl">       <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">       <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">QuickSort</span> <span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">&lt;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="c1">//至少2个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="nf">Partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">QuickSort</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//对左半段排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">QuickSort</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">);</span> <span class="c1">//对右半段排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>算法复杂性分析<br></p>
<ol>
<li>
<p>非递减序</p>
<p>e.g : 6、8、10、12、15、20</p>
<p>Partition:<br>
以O(n)时间复杂度，将长度为n=r-p+1的a[p:r]划分为</p>
<pre><code> 1. 长度为1的a[p:p]
 2. 长度为n-1的非递减子序列a[p+1:r]
</code></pre>
<p>每次划分后，右端需要进一步处理的子序列长度减一</p>
<p>QuickSort:<br>
n-1次调用Partition，对长度为n、n-1、&hellip;、2的子序列a[p:r], a[p+1:r], a[p+2:r],&hellip;,a[r-1:r]进行划分排序<br>
时间复杂性为O(n^2)</p>
<p>a[p:r]已排好序，Partition、QuickSort是多余的</p>
</li>
<li>
<p>非递增序</p>
<p>e.g : 20、15、12、10、8、6</p>
<p>Partition<br>
以O(n)时间复杂度，将长度为n=r-p+1的a[p:r]划分为</p>
<pre><code> 1. 长度=1的a[p:p]
 2. 长度为n-1的a[p+1:r]
</code></pre>
<p>每次划分后，左端或右端需要进一步处理的子序列长度减一</p>
<p>QuickSort:<br>
n-1次调用Partition，对长度为n、n-1、&hellip;2的子序列a[p:r]，a[p:r-1]，a[+1:r-1]，&hellip;，a[p:p+1]进行划分排序，从两端依次选取划分元素<br>
每次所选取的进行划分的子序列从左右两端依次减少一个元素，子序列长度为n、n-1、&hellip;2、1</p>
<p>时间复杂性为O(n^2)</p>
</li>
</ol>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-13.png"
	width="665"
	height="225"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-13_hu17382701501889088264.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-13_hu11459127071855334052.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="295"
		data-flex-basis="709px"
	
></p>
<p>最坏：</p>
<pre><code>当选取数组中最小元素（或最大元素）作为划分元素x，划分产生的2个子序列不平衡、大小不一，1个有n-1个元素，而另一个只有0个元素，从分治法角度，两个子问题极度不平衡
</code></pre>
<p>最好：</p>
<pre><code>当选取数组中各个元素的中位数（或接近中位数）作为划分元素x，划分产生的2个子序列大小接近。从分治法角度，两个平衡子问题
</code></pre>
<h4 id="线性时间选择">线性时间选择
</h4><p>问题</p>
<pre><code>给定线性序集中n个元素和一个整数k，1≤k≤n，要求找出这n个元素中第k小的元素
n个元素存放在a[0:n-1]中
</code></pre>
<p>设计</p>
<pre><code>Step1. 从a[]中选取划分基准元素x=a[0]，将a[0:n-1]划分为2部分,得到a[0:q]：
    1）a[0:q]，q+1个元素,包括a[q]
    2）a[q+1, n-1]，n-q-1个元素
Step2. 
    1）L=q+1=k, x=a[q]为第k小元素，返回结果，算法结束
    2）L=q+1&gt;k, 则左半段至少有k个不大于x=a[q]的小元素，第k小的元素在左半段，递归搜索a[0:q]
    3）L= q+1 &lt; k, 左半段比x=a[q]小的元素少于k-1个，x=a[q]不可能是第k小元素，第k小的元素在右半段，递归搜索a[q+1:n-1]
</code></pre>
<p>算法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 3，1，0，4，2，5，7，8，6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">RandomizedPartition</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Type</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">--</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="nf">RandomizedSelect</span><span class="p">(</span> <span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>    <span class="c1">//只有1个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="nf">RandomizedPartition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="c1">//*划分为2部分, e.g. i=p+5
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">//左端小元素个数，e.g. j=6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">j</span><span class="p">)</span>     <span class="c1">// e.g. k=4， -&gt;  第4小的元素3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span> <span class="c1">//*在左半部分查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="k">return</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">);</span> <span class="c1">//*在右半部分查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>复杂性分析：</p>
<pre><code>最坏复杂性为O(n^2)，不行，要最坏的复杂性为O(n)的。
</code></pre>
<p>改进——划分基准寻找</p>
<pre><code>step1. 将n个输入元素划分成m=n/5个组(取上界)，每组5个元素，只可能有一个组（最后一组）少于5个元素
    这一步复杂性为O(n)
step2. 选用某种排序算法，如冒泡排序，将每组中的元素排好序，取出每组的中位数，共m=n/5个
    复杂性 [n/5] * 5lg5=O(n)
step3.  递归调用select找出这[n/5]个元素的中位数，如果m=[n/5]是偶数，找它的2个中位数中较大的一个。以这个元素作为划分基准
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">Type</span> <span class="nf">Select</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="c1">// 用某个简单排序算法对数组a[p:r]排序;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>       <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>       <span class="c1">//返回a[p:r]中的第k小元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 找到各个区间的中位数，并放到数组的最前面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>  <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="n">p</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">s</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 一个区间的左右
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span>  <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="nf">bubble</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 选择中位数作为划分基准x，从存放各子段中位数的a[]前端部分a[p:p+(r-p-4)/5]中，选第(r-p+6)/10小的数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 一共有r-p+1个元素，[r-p+1/5]个组，要取上界。这些组里要找一个中位数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Type</span> <span class="n">x</span> <span class="o">=</span> <span class="nf">Select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">p</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//根据x将a[p:r]分成三部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nf">Partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//左子段长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="采用特征方程求解递归方程">采用特征方程求解递归方程
</h3><p>线性齐次递归方程 —— 特别注意有重根的情况</p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-15.png"
	width="935"
	height="310"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-15_hu9981744108047199151.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-15_hu8370214785972161614.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="301"
		data-flex-basis="723px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-16.png"
	width="906"
	height="315"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-16_hu569161321397237753.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-16_hu17805675924399303230.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="287"
		data-flex-basis="690px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-17.png"
	width="912"
	height="161"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-17_hu9950038277369900318.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-17_hu6836291303651050822.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="566"
		data-flex-basis="1359px"
	
></p>
<p>需要考虑两种情况：</p>
<pre><code>1. 特征方程的k个根不相同，即无重根
2. 特征方程有相重的根
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-18.png"
	width="1055"
	height="310"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-18_hu7535841123017634894.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-18_hu12674389123488515760.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="340"
		data-flex-basis="816px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-19.png"
	width="1100"
	height="309"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-19_hu16807770434617604663.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-19_hu2972684114261981104.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="355"
		data-flex-basis="854px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-20.png"
	width="1076"
	height="193"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-20_hu18332576513477591445.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-20_hu2361232954959386018.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="557"
		data-flex-basis="1338px"
	
></p>
<h4 id="无重根的例子">无重根的例子
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-21.png"
	width="1113"
	height="626"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-21_hu14072634115395974008.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-21_hu8320774218631392967.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="177"
		data-flex-basis="426px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-22.png"
	width="968"
	height="177"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-22_hu16473556526912790261.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-22_hu6281850910839978290.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="546"
		data-flex-basis="1312px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-23.png"
	width="998"
	height="316"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-23_hu14262352483493539938.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-23_hu5991392183202725257.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="315"
		data-flex-basis="757px"
	
></p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-24.png"
	width="1052"
	height="128"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-24_hu12674376712533203527.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-24_hu15034700058417850781.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="821"
		data-flex-basis="1972px"
	
></p>
<h4 id="有重根的例子">有重根的例子
</h4><pre><code>f(n) = 5f(n-1)- 7f(n-2) + 3f(n-3)
f(0) = 1
f(1) = 2
f(3) = 7
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-27.png"
	width="942"
	height="111"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-27_hu3672632815099961836.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-27_hu13316789829573999292.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="848"
		data-flex-basis="2036px"
	
></p>
<p>这里好像ppt写错了，但是最后的因式分解结果没错
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-26.png"
	width="1040"
	height="356"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-26_hu14075707410465490577.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-26_hu13928891659781745928.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="292"
		data-flex-basis="701px"
	
></p>
<p>先得到通解
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-28.png"
	width="982"
	height="176"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-28_hu741040751220457885.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-28_hu7431241135869987407.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="557"
		data-flex-basis="1339px"
	
></p>
<p>再代入
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-29.png"
	width="878"
	height="325"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-29_hu11368918787445152880.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-29_hu13427135561331504948.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="270"
		data-flex-basis="648px"
	
></p>
<p>最后算出c1、c2、c3，并带入通解中
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-30.png"
	width="982"
	height="143"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-30_hu2963350590208427001.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-30_hu8984797479593605266.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="686"
		data-flex-basis="1648px"
	
></p>
<h2 id="3-动态规划">3 动态规划
</h2><p>动态规划法的原理、要素（了解）</p>
<pre><code>最优子结构性质
</code></pre>
<p>要求：面向特定问题的具体算法</p>
<pre><code>原理
说明/证明最优子结构性质，递推/状态方程
步骤，或代码/伪代码，c/c++/Java/Python
说明/分析时间复杂性，大O
计算示例：针对给定输入，给出算法步骤、执行结果
</code></pre>
<p>掌握</p>
<pre><code>矩阵连乘
最长公共子序列
最大子段和
0/1背包问题
</code></pre>
<h3 id="动态规划算法基本要素">动态规划算法基本要素
</h3><p>具有两个性质</p>
<pre><code>最优子结构
    子问题的解-原问题/规模更大子问题的解之间的递推关系，决定自下而上的求解方式
重叠子问题
    动态规划法，寻找子问题解的最优组合
</code></pre>
<h4 id="最优子结构">最优子结构
</h4><p>原问题/规模较大的子问题的最优解中包含了规模较小的子问题的最优解</p>
<pre><code>以矩阵连乘为例
    全部矩阵的最少乘法次数的计算次序中，
    包含着部分矩阵的最少乘法次数的计算次序
</code></pre>
<p>采用反证法，证明一个问题具有最优子结构性质</p>
<pre><code>首先假设由原问题的最优解推导出的子问题的解不是最优的，
然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾

例如矩阵连乘问题
1. 假设最优子结构性质不成立，即矩阵连乘中，最优解的子问题不是最优解
2. 我们假设在k处做了一个非最优决策，将矩阵链划分为两部分：A1 * A2 * ... * Ak-1 * (Ak * Ak+1 * ... * An)。
我们考虑将第k个矩阵与其前面的矩阵链合并，得到(A1 * A2 * ... * Ak) * (Ak+1 * ... * An)。由于我们假设在位置k处选择了非最优决策，所以这个新的矩阵链的乘法次数会比原最优解更少。
3. 通过将非最优决策变为最优决策，我们构造了一个乘法次数更少的解，原问题的最优解不是最优解，矛盾。
</code></pre>
<h3 id="经典算法">经典算法
</h3><h4 id="矩阵连乘">矩阵连乘
</h4><p>给定n个可连乘的矩阵{A1, A2, …,An}，计算连乘积A1A2 …An</p>
<pre><code>2个矩阵A[pi, pj],B[pj, pk],
A×B 为[pi,pk]矩阵，数乘次数pi×pj×pk
</code></pre>
<p>目标</p>
<pre><code>给定n个矩阵｛A1, A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1，如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少？
</code></pre>
<p>考察计算A[i:j]的最优计算次序</p>
<pre><code>设该计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为
(Ai Ai+1...Ak)(Ak+1 Ak+2 ... Aj)
</code></pre>
<p>计算量为</p>
<pre><code>A[i:k]的计算量 +  
A[k+1:j]的计算量  +
A[i:k]和A[k+1:j]相乘的计算量
</code></pre>
<p>最优解结构分析</p>
<pre><code>计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的（可以反证法证明），即：
    矩阵连乘计算次序问题的最优解包含着其子问题的最优解，
    这种性质称为最优子结构性质
</code></pre>
<p>建立递归关系</p>
<pre><code>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]
当 i=j 时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n
当 i&lt;j 时，m[i,j]=m[i,k]+m[k+1,j]+ pi-1 * pk *pj
    断开位置为k。这里的Ai维数为pi-1 * pi
    两个矩阵相乘，结果有pi-1 * pi+1 个元素，每个元素需要计算 pi 次
m[i,j]可以递归的定义为：
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-31.png"
	width="1035"
	height="284"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-31_hu7383871305456472599.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-31_hu1170180345977855662.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="364"
		data-flex-basis="874px"
	
></p>
<p>最终得到多项式时间的算法，O(n3)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MatrixChain</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="err">，</span><span class="kt">int</span> <span class="n">n</span><span class="err">，</span><span class="kt">int</span> <span class="o">**</span><span class="n">m</span><span class="err">，</span><span class="kt">int</span> <span class="o">**</span><span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//自下而上，从规模为r=2的子问题开始，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">r</span><span class="o">++</span><span class="p">){</span>   
</span></span><span class="line"><span class="cl">        <span class="c1">//考察规模为r的子问题                                  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">            <span class="c1">// [i:j]有r个矩阵         
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>              
</span></span><span class="line"><span class="cl">            <span class="c1">// m[i:i] = 0，后面的m[i+1][j]已经在上一次迭代中计算了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span><span class="mi">0</span><span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>   
</span></span><span class="line"><span class="cl">            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// 记录初始最优断点位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                 
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>复杂性
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-32.png"
	width="1088"
	height="313"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-32_hu11674178143306503464.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-32_hu2477090199737461230.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="347"
		data-flex-basis="834px"
	
></p>
<p>求解要素
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-33.png"
	width="1043"
	height="751"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-33_hu15471356128486405041.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-33_hu11515573714999111861.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="138"
		data-flex-basis="333px"
	
></p>
<p>状态</p>
<pre><code>自下而上求解过程中的不同阶段、步骤，状态A[i,j]代表规模为(j-i+1)的子问题已经解决，得到其最优解m[i: j]

初始状态：A[i: i], 1≤i ≤ n，规模为1的子问题
中间状态：A[i: j], 1 ≤ i &lt;j ≤ n, 规模为j-i+1&lt;n的子问题
目标状态： A[1: n]，规模为n的原问题
</code></pre>
<h4 id="最长公共子序列">最长公共子序列
</h4><p>判断最优子结构性质</p>
<pre><code>设序列X(m)={x1,x2,…,xm}和Y(n)={y1,y2,…,yn}的最长公共子序列为Z(k)={z1,z2,…,zk} ，问题规模&lt;m,n&gt;，考察三种情况下问题结构
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-34.png"
	width="974"
	height="379"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-34_hu10271631851422321481.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-34_hu2961691248446117607.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="256"
		data-flex-basis="616px"
	
></p>
<pre><code>情况1：若xm=yn，则zk=xm=yn，且Z(k-1)={z1, z2,…,zk-1 }是X(m-1)= {x1,x2,…,xm-1}和Y(n-1)={y1,y2,…,yn-1}的最长公共子序列
    &lt;m, n&gt; -&gt; &lt;m-1, n-1&gt;
情况2：若xm≠yn且zk≠xm，则Z(k)是X(m-1)和Y(n)的的最长公共子序列
    &lt;m, n&gt; -&gt; &lt;m-1, n&gt;
情况3：若xm≠yn且zk≠yn，则Z(k)是X(m)和Y(n-1)的最长公共子序列
    &lt;m, n&gt; -&gt; &lt;m, n-1&gt;
由此可见，2个序列的最长公共子序列包含了这2个序列的前缀(i.e. 子问题)的最长公共子序列。
因此，最长公共子序列问题具有最优子结构性质 
</code></pre>
<p>问题递归结构/状态方程</p>
<pre><code>c[i][j]：序列X(i)和Y(j)的最长公共子序列的长度，
1. 边界条件：X(i)={x1,x2,…,xi}，Y(j)={y1,y2,…,yj}，当i=0或j=0时，即其中1个序列为空，则空序列是Xi和Yj的最长公共子序列，故此时C[i][j]=0
2. 其它情况下，由最优子结构性质可建立递归关系如下：
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-35.png"
	width="1027"
	height="226"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-35_hu8302361973956526078.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-35_hu4018380956107959284.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="454"
		data-flex-basis="1090px"
	
></p>
<p>算法设计</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">LCSLength</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="err">，</span><span class="kt">int</span> <span class="n">n</span><span class="err">，</span><span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="err">，</span><span class="kt">char</span> <span class="o">*</span><span class="n">y</span><span class="err">，</span><span class="kt">int</span> <span class="o">**</span><span class="n">c</span><span class="err">，</span><span class="kt">int</span> <span class="o">**</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="err">，</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化, Y[j]为空时，最小子问题&lt;i,0&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//初始化， X[i]为空时，最小子问题&lt;0,j&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">    <span class="c1">//两重循环，自下而上，计算子问题{X(i), Y(j)}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>               <span class="c1">//情况1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>   <span class="c1">//情况2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">                <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>            <span class="c1">//情况3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">每个数组单元的计算耗时</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">，算法耗时：</span><span class="nf">O</span><span class="p">(</span><span class="n">mn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 构造最长公共子序列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">LCS</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="err">，</span><span class="kt">int</span> <span class="n">j</span><span class="err">，</span><span class="kt">char</span> <span class="o">*</span><span class="n">x</span><span class="err">，</span><span class="kt">int</span> <span class="o">**</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span> <span class="mi">1</span><span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">LCS</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="c1">//第1种情况下，X(i)和Y(j)的最长公共子序列由X(i-1)和Y(j-1)的解LCS(i-1, j-1, x, b)，加上位于最后的x[i]组成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">==</span> <span class="mi">2</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">LCS</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="err">，</span><span class="n">j</span><span class="err">，</span><span class="n">x</span><span class="err">，</span><span class="n">b</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span> 
</span></span><span class="line"><span class="cl">        <span class="nf">LCS</span><span class="p">(</span><span class="n">i</span><span class="err">，</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="err">，</span><span class="n">x</span><span class="err">，</span><span class="n">b</span><span class="p">);</span> <span class="c1">//其它2种情况下，原问题解等于子问题解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">过程：</span>
</span></span><span class="line"><span class="cl">    <span class="err">从</span><span class="n">b</span><span class="p">[</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="err">开始，依其值在数组</span><span class="n">b中搜索</span>
</span></span><span class="line"><span class="cl">    <span class="mf">1.</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Xi和Yj的最长公共子序列由Xi</span><span class="o">-</span><span class="mi">1</span><span class="err">和</span><span class="n">Yj</span><span class="o">-</span><span class="mi">1</span><span class="err">的最长公共子序列，在尾部加上</span><span class="n">xi得到</span>
</span></span><span class="line"><span class="cl">    <span class="mf">2.</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Xi和Yj的最长公共子序列与Xi</span><span class="o">-</span><span class="mi">1</span><span class="err">和</span><span class="n">Yj的的最长公共子序列相同</span>
</span></span><span class="line"><span class="cl">    <span class="mf">3.</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">Xi和Yj的最长公共子序列与Xi和Yj</span><span class="o">-</span><span class="mi">1</span><span class="err">的的最长公共子序列相同</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">算法中，每次递归调用使</span><span class="n">i或j减一</span><span class="err">，算法计算时间复杂性为</span><span class="n">O</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="最大子段和">最大子段和
</h4><p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-36.png"
	width="1012"
	height="318"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-36_hu280481284831036086.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-36_hu1143810760911424175.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="318"
		data-flex-basis="763px"
	
></p>
<pre><code>二维表示：左端i，右端j
一维表示：b[j]，右端j
</code></pre>
<p>递归方程：</p>
<pre><code>b[j] = max{a[j]+b[j-1], a[j]} , 1 &lt;= j &lt;= n
</code></pre>
<p>算法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">maxSum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">sum</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="01-背包">0/1 背包
</h4><p>给定n种物品{1, 2, 3, …,n}和一背包，物品i的重量wi，价值为vi，背包的容量为C
<br>应如何选择装入背包的物品，使得装入背包中物品在其总重量不超过背包容量C的前提下，背包中物品的总价值最大？
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-37.png"
	width="820"
	height="360"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-37_hu1808253975006564983.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-37_hu14433066172190968697.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="227"
		data-flex-basis="546px"
	
></p>
<p>最优子结构性质</p>
<pre><code>设(x1, x2, ... xn)是相对于n种物品{1,2,...,n}的1个最优解，则(x2,...,xn)是子问题{2,3,...,n}的1个最优解，即原问题最优解包括了子问题最优解
子问题1：{1}
子问题2：{2,3,...,n}

假设对于一个最优解 {x1,x2,...xn}，它的子问题{2,...,n}的解不是最优的。因此我们能够对于子问题2找出另一个更优的解{x2',x3',...xn'}
通过新的子问题最优解与原来的子问题1合并，我们得到了更优的问题解，推导出一开始的解不是最优解。这使得假设矛盾，因此该问题具有最优子结构性质
</code></pre>
<p>问题表示</p>
<pre><code>子问题&lt;i, j&gt;的最优值定义为m&lt;i, j&gt;
背包容量为j，可选物品为{i, i+1, ..., n}时，0-1背包的最优值
原问题&lt;1, c&gt;的最优解表示为m(1, c)
</code></pre>
<p>状态方程</p>
<pre><code>根据最优子结构性质，建立计算m(i, j)递归式
边界条件：i == n， 对于只有一个物品 —— 最有一个物品{n}，背包容量为j的子问题&lt;n, j&gt;
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-38.png"
	width="1075"
	height="227"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-38_hu18008871867632281845.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-38_hu15407497483103456809.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="473"
		data-flex-basis="1136px"
	
></p>
<pre><code>对于子问题&lt;i, j&gt;，有
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-39.png"
	width="1059"
	height="175"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-39_hu5756840606068828862.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-39_hu15066447200464232805.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="605"
		data-flex-basis="1452px"
	
></p>
<pre><code>当j的容量小于wi的时候，i物品肯定放不进去了
当j的容量大于等于wi的时候，i物品才有可能放进去，
    此时要比较的是把物品置换出来的价值大，还是原来那样大
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// v:价值矩阵   w:重量矩阵, c:背包容量  n:物品总数  m:问题最优解m[i][j]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Void</span> <span class="nf">Knapsack</span><span class="p">(</span><span class="n">Type</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">type</span> <span class="o">**</span><span class="n">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 比较一下最后一个物品的重量和背包重量谁最小，方便初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">jMax</span><span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">jmax</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将能放下第n个物品的空间先初始化为第n个物品的价值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>  <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">jMax</span><span class="o">=</span> <span class="nf">min</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 先把放不下的赋值了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="n">j</span><span class="o">&lt;=</span><span class="n">JMax</span><span class="p">;</span>  <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 再把放得下的赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="n">j</span><span class="o">&lt;=</span><span class="n">c</span><span class="p">;</span>  <span class="n">j</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">c</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 根据子问题 &lt;2, c&gt;， &lt;1, c-w[1]&gt;，构造原问题&lt;1, c&gt;的解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">&gt;</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="nf">max</span><span class="p">(</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">+</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">从</span><span class="n">m</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="err">的递归式容易看出，算法需要</span><span class="n">O</span><span class="p">(</span><span class="n">nc</span><span class="p">)</span><span class="err">计算时间</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">当背包容量</span><span class="n">c很大时</span><span class="err">，算法需要的计算时间较多</span>
</span></span><span class="line"><span class="cl"><span class="err">例如，当</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="n">n</span> <span class="err">时，算法需要Ω</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="o">^</span><span class="n">n</span><span class="p">)</span><span class="err">计算时间</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="4-贪心法">4 贪心法
</h2><p>算法基础(了解)：</p>
<pre><code>最优子结构性质、贪心选择性质
贪心算法与动态规划算法的差异
</code></pre>
<p>要求：面向特定问题的具体算法</p>
<pre><code>原理，采用的贪心策略
说明/证明问题满足贪心选择性质
步骤，或代码/伪代码 
说明/给出时间复杂性
计算示例：针对给定输入，给出算法步骤、执行结果
</code></pre>
<p>掌握：</p>
<pre><code>单源最短路径
背包问题
最优装载问题
</code></pre>
<h3 id="贪心选择性质">贪心选择性质
</h3><p>证明原理：数学归纳法，分两步</p>
<pre><code>Step1. 存在以贪心选择开始的最优方案，即最...的一定在最优解种

Step2. 每步所作的贪心选择，将问题简化为一个更小的、与原问题具有相同形式的子问题。据此，对贪心选择次数做归纳，可以证明：贪心法产生原问题的最优解
</code></pre>
<p>问题的全局/整体最优解可以通过采用一系列局部最优的选择，即贪心选择，来获得</p>
<pre><code>贪心选择性质是贪心算法可应用于求解问题全局最优解的第一个基本要素，也是贪心算法与动态规划算法的主要区别
</code></pre>
<p>确定具体问题是否具有贪心选择性质，须证明</p>
<pre><code>每一步所作的贪心选择最终导致问题的整体最优解
</code></pre>
<h3 id="算法">算法
</h3><h4 id="背包问题">背包问题
</h4><p>与0-1背包问题类似，但在选择物品i装入背包时，1≤i≤n，可以选择物品i的一部分，即0 ≤ xi ≤1，不要求物品全部装入背包</p>
<p>但是背包问题具有贪心选择性质，可以用贪心法</p>
<pre><code>贪心选择性质证明：
首先将所有物品按照vi从大到小排列。问题的解X={x1,x2,...xn}是一个最优解
设k为最先装入背包中的价值最大的物品
当问题有最优解的时候，分两种情况：
1. x1被充分放入
2. x1没有被充分放入。
对于1，当x1被充分放入，已经时最优解了。
对于2，构造可行解Y，选择w1 &lt; W的任意值，其中wi是x1的部分。此时将x1完全放入背包，即y1 = x1。然后根据贪心选择性质，选择单位重量价值次高的物品放入背包，直到背包装满。
由于y1=x1，此时Y的总价值不小于X的总价值，因为我们在构造Y时选择了相同或更高价值密度的物品。
因此，无论x1充分放入与否，都可以构造一个具有相同或更高总价值的解。这证明了分数背包问题具有贪心选择性质。
</code></pre>
<p>步骤</p>
<pre><code>计算每种物品的单位重量价值vi/wi ，作为贪心选择的依据指标
贪心选择策略:
    选择单位重量价值最高的物品，将该物品尽可能多地装入背包
若将所选择的物品全部装入背包后，背包内的物品总重量未超过背包容量C，则选择单位重量价值次高的物品，并尽可能多地装入背包
依此策略一直地进行下去，直到背包装满为止
</code></pre>
<p>实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// n物品总数，M背包容量，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Knapsack</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="n">M</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">[],</span> <span class="kt">float</span> <span class="n">w</span><span class="p">[],</span> <span class="kt">float</span> <span class="n">x</span><span class="p">[])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>      
</span></span><span class="line"><span class="cl">    <span class="c1">//对n个物品，计算其单位重量价值 v[i]/w[i]；n个物品，按照v[i]/w[i]从大到小重新排序编号！！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Sort</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>        <span class="c1">//解向量赋初值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">float</span> <span class="n">C</span><span class="o">=</span><span class="n">M</span><span class="p">;</span>                  <span class="c1">//当前可用背包容量C ←初始背包容量M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//从单位价值最大的物品开始，依次考虑物品i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//  物品i的重量超出当前可用背包容量，结束循环，放入物品i的一部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">C</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl">        <span class="c1">// 物品i的重量没有超过当前可用背包的容量，将i全部装入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>      
</span></span><span class="line"><span class="cl">        <span class="c1">// 调整当前可用背包容量，减少         
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">c</span><span class="o">-=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>                        <span class="c1">//通过for循环中各步骤装入的物品都是整体装入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//如果还有物品没有考虑且背包还有剩余容量(C&gt;0)，将剩余容量分配给物品i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">C</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="o">/</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">算法</span><span class="n">knapsack的主要计算时间在于将各种物品依其单位重量的价值从大到小排序</span><span class="p">,</span>  <span class="err">因此算法的计算时间上界为</span>
</span></span><span class="line"><span class="cl">        <span class="nf">O</span><span class="p">(</span><span class="n">nlogn</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="最优装载问题">最优装载问题
</h4><p>问题描述</p>
<pre><code>有n个集装箱要装上一艘载重量为C的轮船，其中集装箱i的重量为wi
</code></pre>
<p>要求</p>
<pre><code>装载体积不受限制的情况下，将尽可能多的集装箱装上轮船，且装载的集装箱总重量不超过C
    优化目标：装载的集装箱数目极大化
    约束条件：装载重量受限
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-40.png"
	width="1196"
	height="377"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-40_hu15100244707957291175.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-40_hu12027443883170810394.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="317"
		data-flex-basis="761px"
	
></p>
<p>算法描述</p>
<pre><code>贪心选择策略：先装重量最轻的，剩余重量空间最大化，以容纳更多的其它或物，可产生最优装载问题的最优解
</code></pre>
<p>贪心选择性质的证明（证明优先将最轻的放入能不能得到最优解）</p>
<pre><code>设集装箱已经按重量从小到大排序，X={x1, x2, ..., xn}是最优装载问题的一个最优解
设k为最先装入箱中的最轻货物

当问题有最优解（有可能是非贪心策略解）时，分两种情况

1. 当k=1，即最轻的第一个货物被装入，货物选择的放入顺序符合贪心策略，{x1，x2，...，xn}是满足贪心选择性质的一个最优解。 x1=0

2. 当k&gt;1，即最轻的集装箱1没有被装入。此时，按如下方式从{x1,x2,...xn}构造出一个满足贪心策略的最优解Y={y1,y2,...yn}，y1=1
    i. 对k，其中1&lt;k&lt;n, yk=1, 取y1=1，yk=0，将第1个集装箱放入，第k个集装箱拿出，即用第1个集装箱替换原方案中最轻的集装箱，而第1个集装箱比第k个集装箱更轻，即w1&lt;=wk
    ii. yi=xi, 1&lt;=i&lt;=n, i≠k，其他集装箱是否被放入仍保持不变
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-41.png"
	width="1036"
	height="188"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-41_hu2614370416900329478.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-41_hu9568166771363876025.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="551"
		data-flex-basis="1322px"
	
></p>
<pre><code>新方案仍满足容量约束条件，因此新方案是满足贪心策略的可行解。需进一步判断装入的集装箱数是否最多?

由于 yi的总和 = xi的总和，集装箱数量一样。说明第2个方案Y={y1, y2, ..,yk, …, yn}具有与最优方案X一样的装箱数。
所以：优先将最轻的第1个集装箱装入可以使得装载的总箱数最大化！

综上所述，Y是一个满足贪心策略的最优解
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// X是解向量，w是重量向量，c是总装载量，n是集装箱总数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">Loading</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">[],</span>  <span class="n">Type</span> <span class="n">w</span><span class="p">[],</span> <span class="n">Type</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>      
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对n个集装箱，按照重量w[i]从小到大重新排序并排列编号，结果放在t中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// t放的是w从小到达排序的编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Sort</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="c1">//解向量赋初值          
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     
</span></span><span class="line"><span class="cl">    <span class="c1">// 在有剩余容量的情况下，从轻到重，装入各个集装箱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">c</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">c</span> <span class="o">-=</span> <span class="n">w</span><span class="p">[</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="单源最短路径">单源最短路径
</h4><p>问题描述</p>
<pre><code>给定带权有向图G =(V, E)，V={1, 2, 3,..., n}, 其中每条边的权c[i][j]是非负实数
给定V中的一个顶点v，称为源
</code></pre>
<p>要求: 计算从源v到所有其它各顶点j∈V-{v}的最短路径长度</p>
<pre><code>路径长度：路径上各条边的权之和
</code></pre>
<p>Dijkstra算法: 贪心算法求解单源最短路径</p>
<p>算法原理</p>
<pre><code>1. 设置集合S={i}⊆V，记录已经得到最短路径的顶点i（已经求出v至i的最短路径）
    顶点i∈S，当且仅当从源v到该顶点i的（全局）最短路径已知
    初始时，S中只有源点v
2. 对图G(V, E)中某一个顶点u∈V，将从源v到u且中间只经过S中的顶点的路径称为从源点v到u的特殊路径，用数组dist记录v到图中各点u的特殊路径长度，记为dist[u]

v到u的特殊最短路径，长度dist[u]
    从v到u、中间只经过S中的顶点

v到u的全局最短路径，长度d(v,u)
    d(v,u) ≤ dist[u]
    可能经过不在S中的顶点，如k
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-42.png"
	width="762"
	height="393"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-42_hu3279150801034249685.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-42_hu15498811559791932011.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="193"
		data-flex-basis="465px"
	
></p>
<pre><code>3. 采用贪心选择策略，从V-S中挑选具有最小dist[uk]的顶点uk，将uk加入S，S={uk}∪S
        S0={v}, S1={v, u1}, …, Sn={un-1}∪Sn-1
4. 当S=V时，获得源点v至图中全部其它n-1个顶点的最短路径，算法结束
</code></pre>
<p>贪心策略</p>
<pre><code>扩展集合S时，从V-S中取出具有最短特殊路径长度dist[u]的顶点u，将u添加到S中
S发生改变，对数组dist应作必要修改，重新计算v到S外(?)各点u的dist[u]
</code></pre>
<p>算法例子及步骤
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-44.png"
	width="1186"
	height="832"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-44_hu14592477265813478487.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-44_hu16501125419173696286.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="142"
		data-flex-basis="342px"
	
></p>
<p>算法复杂性O(n2)</p>
<pre><code>算法主循环体需要O(n)时间，这个循环需要执行n-1次，所以完成循环需要O(n^2)时间
算法的其余部分所需要时间不超过 O(n^2)
</code></pre>
<p>贪心选择性质证明</p>
<pre><code>首先知道该算法的贪心选择策略：循环/迭代计算中每一步，从V-Si中选择具有最短特殊路径dist[u]的顶点u，加入Si得到Si+1

为了证明贪心选择性质，需要证明：
对任意已经在Si中的顶点u，从v开始、经过G中任意顶点到达u的全局最短路径的长度d(v, u) = 从v开始、只经过Si中顶点到达u的最短路径的长度dist(u)：u一旦放入S，dist[u]就是d(v,u)
即证明：不存在另一条v到u的全局最短路径，该路径上某些节点x不在V-S 中，且该路径长度d(v,u)&lt;dist[u]

使用反证法，假设
在迭代求解的过程中，顶点u是遇到的集合S中第1个满足d(v,u)&lt;dist[u]的顶点，即d(v,u)≠dist[u]且全局最优路径经过S之外的顶点
    从v到u的全局最短路径上，经过的第1个属于V-Si的顶点为x
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-43.png"
	width="1129"
	height="441"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-43_hu16684745014821002774.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-43_hu16992296580628150564.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="256"
		data-flex-basis="614px"
	
></p>
<pre><code>对v到u的全局最短路径d(v ,u) ，根据d(v, x) + distance(x, u) = d(v ,u) ，由于distance(x, u) &gt;0，有
    d(v, x) &lt; d(v ,u)
进一步地，根据假设d(v,u) &lt; dist[u], 有
    d(v, x) + distance(x, u) =  d(v ,u) &lt; dist[u]  
由于distance(x, u) &gt;0, 因此
dist[x]= d(v, x) ≤ d(v,u)= d(v, x) + distance(x, u) &lt; dist[u],  
    即  dist[x] &lt; dist[u]
但是根据路径p构造方法，在下图所示情况下，u、x都在集合Si之外，即u、x都属于V-Si，贪心选择S外顶点时，u被选中，并没有选x，根据扩展Si的原则：选dist最小的顶点加入Si，说明此时
    dist[u] ≤ dist[x] 
这与 前面推出的
    dist[x]&lt; dist[u]
相矛盾
</code></pre>
<p>算法实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">double</span><span class="o">*</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="kt">double</span> <span class="o">**</span><span class="n">graph</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化 s 集合，只有一个起始点在里面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="o">*</span> <span class="n">s</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="o">*</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">double</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 先将起始点放入S中 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 进行最短路径算法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 考虑原点v之外的其他点u，对于不同规模Si，逐步扩展
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">MAXINT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//选取s外具有最小dist的点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">u</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">temp</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MAXINT</span> 
</span></span><span class="line"><span class="cl">            <span class="o">&amp;&amp;</span> <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">                <span class="n">dist</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>    
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="5-回溯法">5 回溯法
</h2><p>要求：面向特定问题的具体算法</p>
<pre><code>原理
解向量，剪枝函数设计
步骤，或代码
说明/给出时间复杂性
计算示例：针对给定输入，画出搜索/剪枝过程及解空间树，给出执行结果
</code></pre>
<p>掌握</p>
<pre><code>0/1背包
旅行商问题TSP
n皇后问题，图的m着色问题
</code></pre>
<h3 id="算法-1">算法
</h3><h4 id="tsp">TSP
</h4><p>定义：</p>
<pre><code>t: 递归深度，当前解在解空间树中深度. 初始时，t=1,  e.g. 结点B, t=2

f(n,t), g(n,t)：当前扩展结点处(e.g B)未搜索的子树的起始编号、终止编号,   e.g. t=2, f(n,t)=C, g(n,t)=E

h(i): 当前扩展结点处的第i个可选值，e.g. h(i)=C, D, E

constraint(t): 当前扩展结点处的约束函数，e.g. 不允许城市重复出现；判断当前结点是否满足约束，决定是否舍弃当前结点对应分支

bound(t): 当前扩展结点的限界函数，用于判断当前结点是否越界，决定是否舍弃当前结点对应分支
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-45.png"
	width="1152"
	height="552"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-45_hu12516664947519490494.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-45_hu9243028920765996172.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="208"
		data-flex-basis="500px"
	
></p>
<p>剪枝条件</p>
<pre><code>1. 如果当前正在考虑的顶点j与当前已经在走过的部分路径末端结点i 没有边相连，即w[i, j] = ∞ ，则放弃搜索j所在分支

2. 令到第i层结点为止，构造的部分解路径为
    &lt;1, x[2], x[3],…, x[i-1], x[i], ?, ? , ?&gt;,
    该路径的权值总和 大于 bestw —— x[i] 无希望达到更优的路径，则停止搜索x[i]分支及其下面的层。bestw表示目前为止，找到的最佳完整回路的权和

当前已有的部分路径为&lt;1,2, ?, ?&gt;, 路径末端结点为2
根据路径组成规则，下一步可考虑n-2=2个顶点：顶点3、4，加入到部分路径中
但是，顶点2与4间无边，w(2,4)= ∞
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-46.png"
	width="1116"
	height="801"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-46_hu16079593398095519589.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-46_hu9089874193272727957.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="139"
		data-flex-basis="334px"
	
></p>
<p>变量定义</p>
<pre><code>bestx[1:n]记录最佳路径
cw:当前已经走过的部分路径总长
x[1:n]搜索过程中生成的部分路径
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">backTrackTSP</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果搜索到达叶节点，还没有考虑的城市只有x[n]，因此只能选择最后一个城市x[n]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 最后一个城市与前一个城市相连，与第一个城市相连，并且路径更优
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">!=</span> <span class="n">MAXINT</span> <span class="o">&amp;&amp;</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MAXINT</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cw</span> <span class="o">+</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">+</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bestw</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 更新最优路径及长度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">bestx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">bestw</span> <span class="o">=</span> <span class="n">cw</span> <span class="o">+</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">+</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果没有到达叶节点, 已有部分解，依次考察下一步x[i]的可能取值j
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">!=</span><span class="n">MAXINT</span> <span class="o">&amp;&amp;</span> <span class="n">cw</span><span class="o">+</span><span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">bestw</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">                <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="n">cw</span> <span class="o">+=</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="nf">backTrack</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">cw</span> <span class="o">-=</span> <span class="nf">w</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">                <span class="nf">swap</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>排列树问题</p>
<pre><code>从n个元素组成的集合中，找出满足某种性质的n个元素的排列，构成问题解
</code></pre>
<p>排列树一般有n!个结点，树遍历时间Ω(n!)</p>
<h4 id="n-后问题">n-后问题
</h4><p>问题描述</p>
<pre><code>1）在n×n格的棋盘上，放置n个彼此不受攻击的皇后
2）按照国际象棋的规则，任何2个皇后不放在同一行或同一列或斜率为±1的同一斜线上
</code></pre>
<p>设计解向量</p>
<pre><code>X[i]表示第i行的皇后处在第几列
X=  4      6      8     2      7      1      3       5      
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-47.png"
	width="673"
	height="525"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-47_hu2130280814322808061.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-47_hu16522932633751904575.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="128"
		data-flex-basis="307px"
	
></p>
<p>约束</p>
<pre><code>1. 1 ≤ xi ≤ n, 即xi = 1,2, … ,n, 每个皇后只能位于1～n列
2.  
    1）任意2个皇后不同列：  xi ≠ xj
    2）任意2个皇后不处于同一正、反对角线：|i-j| ≠ |xi-xj|
</code></pre>
<p>迭代非递归回溯法</p>
<pre><code>1. 外层循环依次考虑1,2,…,n个皇后，对应棋盘上的1,2,…,n行
2. 内层循环对选定了行位置的皇后k，考虑应放置的列位置x[k]是否与1,…,k-1发生冲突
</code></pre>
<p>约束函数设计</p>
<pre><code>1. 判断部分解是否满足显式、隐性约束
2. 测试当前部分解中的皇后所处位置是否合适
    对皇后k，当将其放置在第k行、x[k]列时，是否与前面已经放置好的皇后1、2、3、k-1相冲突——为第k个皇后选择合适列
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// x[] 为包含皇后1，2，...k-1，k位置的1个部分解
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">place</span><span class="p">(</span><span class="n">x</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 判断第k个皇后与前面位置是否冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span> <span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 不能在对角线，不能同一列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="nf">abs</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">||</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// n：皇后个数，x[]：解向量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">nQueens</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 外层循环，负责依次安排皇后1，2，...k，...，n的位置，本次循环安排第k个皇后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 内层循环，为第k个皇后选择合适的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">k</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果当前位置有冲突，继续搜索下一个位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 为第k个皇后搜索到了合适的列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>  <span class="c1">// 最后一个皇后，可以了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果不k不是最后一个皇后，为继续搜索下一个k+1皇后做准备
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">k</span> <span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// x[k] &gt; n，说明当前分支不能走了，要回退一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">//置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">k</span><span class="o">--</span><span class="p">;</span>    <span class="c1">//回溯上一层，重新选择x[k-1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">N后问题属于排列树问题</span>
</span></span><span class="line"><span class="cl"><span class="err">回溯法最坏情况下的复杂性是</span><span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="o">!</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">算法由</span><span class="mi">2</span><span class="err">层循环组成，算法运行时间与外部循环执行次数和内部循环体</span><span class="n">place函数的执行次数有关</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">每访问搜索树中的</span><span class="mi">1</span><span class="err">个结点，就执行一次。</span> <span class="err">因此，算法运行时间取决于它所访问的结点个数</span><span class="n">c</span><span class="err">——搜索树的</span><span class="n">size</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">因此，计算约束方程的总次数为</span><span class="n">O</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span><span class="err">，</span><span class="n">c是动态生成的</span><span class="err">，一般为</span><span class="n">n的多项式</span><span class="err">（见后面例子）</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="图的m着色问题">图的m着色问题
</h4><p>地图着色问题转换为图着色</p>
<pre><code>以地图中的区域作为图中顶点，2个区域如果邻接，则这2个区域对应的顶点间有一条边，即边表示了区域间的邻接关系
给定无向连通图G=(V, E)和m种不同的颜色,  用这些颜色为图G的各顶点着色，每个顶点着一种颜色
约束：相邻边不同着色
目标：使用的颜色尽可能少
</code></pre>
<p>图的m可着色判定问题</p>
<pre><code>是否有一种着色法，只使用m种颜色，使G中每条边的2个顶点着不同颜色？
</code></pre>
<p>图的色数</p>
<pre><code>如果一个图最少需要m种颜色才能使图中每条边连接的2个顶点着不同颜色，m为该图的色数
</code></pre>
<p>问题的解空间</p>
<pre><code>给定n个顶点的图G=(V, E)，m种颜色,  解向量
    x[1:n]=(x1, x2, … , xn)
    x[i]表示顶点i所着颜色
    顶点i的颜色取值范围为1,2,...,m即x[i]∈{1,2,...,m}

搜索过程形成高度为n的完全m叉树
    在第i层，i=0,1,..,n-1, 有mi个结点
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-48.png"
	width="1129"
	height="494"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-48_hu16613993858370837476.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-48_hu10513159854546944025.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="228"
		data-flex-basis="548px"
	
></p>
<p>约束函数：</p>
<pre><code>相邻结点不能着色相同，即x[i]≠x[j]，如果顶点i与顶点j邻接
</code></pre>
<p>数据结构设计</p>
<pre><code>int n   顶点个数
int m   最大颜色数
int x[n]    各顶点的着色
bool a[n][n]    图中顶点邻接矩阵，a[k][j] == 1表示k与j相邻
</code></pre>
<p>测试函数</p>
<pre><code>ok(int x[], int k, bool a[][], int n)
假设当前已经对顶点1, 2, 3,…, k-1进行了有效可行（满足约束条件）的着色，考察顶点k，判断是否可将k着色为x[k]
    &lt;x1, x2, xk-1, xk?, ?, ?, ?...&gt;
要求： xk与之前的x1, x2, xk-1不冲突，即相邻顶点颜色不同
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">ok</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 邻接，且冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>算法设计</p>
<pre><code>2层循环：
    1. 外层循环依次考虑不同顶点1, 2, ..., k,..., n
    2. 内层循环为外层循环选定的顶点选择合适颜色：1,2,...,m
        调用ok函数，测试当前顶点k的着色是否与已经着色的1,2,...,k-1的颜色想容
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">m_coloring</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">a</span><span class="p">[][],</span> <span class="kt">int</span> <span class="n">x</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 未着色
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 为顶点选择下一个颜色，从第一种颜色开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">ok</span><span class="p">(</span><span class="n">k</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果顶点k当前着色x[k]不合适
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 前面步骤为顶点k找到了合适的着色，如果没有，x[k] &gt; m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 当前顶点是最后一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 不是最后一个，判断下一个顶点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 前面步骤没有为k找到合适着色，需要回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// k 回溯
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">k</span> <span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>掌握 搜索树画法
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-49.png"
	width="1198"
	height="880"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-49_hu78601432591158696.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-49_hu7563721826067827074.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="136"
		data-flex-basis="326px"
	
></p>
<p>复杂性分析</p>
<pre><code>对于每一个非叶节点，在最坏情况下，用OK检查当前扩展结点的每一个子节点所相应的颜色可用性, 需耗时O(mn) 
    该非叶节点对应的图中顶点与其它最多n-1个顶点均相邻，需要考察m种颜色
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-50.png"
	width="1077"
	height="240"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-50_hu18184671577067110139.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-50_hu11524943154973775758.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="448"
		data-flex-basis="1077px"
	
></p>
<h4 id="0-1-背包问题">0-1 背包问题
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">backtrack</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nf">output</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 这里可以更新最优值 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果满足约束条件，就向下搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="nf">constraint</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">bound</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="c1">// 只要重量不超过背包载重量，就可以
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nf">backtrack</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>搜索树如下
<img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-52.png"
	width="1174"
	height="555"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-52_hu17422106157998945381.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-52_hu7241757322456265261.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="211"
		data-flex-basis="507px"
	
></p>
<pre><code>n=3, 解向量&lt;x1,x2,x3&gt;, 4层
子集树的叶结点数目：2^n=2^3
全部树结点数目： 2^(n+1) -1 =2^(3+1) -1=15
</code></pre>
<p>子集树特征</p>
<pre><code>子集树的叶结点数目：2^n
全部树结点数目：2^(n+1) -1
算法复杂性：Ω(2^n)
</code></pre>
<h2 id="6-分支限界法">6 分支限界法
</h2><p>要求：面向特定问题的具体算法</p>
<pre><code>原理
问题解上下界估计，非叶节点上界ub或下界lb估计
算法框架/步骤，或代码/伪代码，C/C++/Java/Python
说明/给出时间复杂性
计算示例：针对给定输入，画出搜索/剪枝过程及解空间树，给出执行结果
</code></pre>
<p>掌握</p>
<pre><code>0-1 背包
旅行商问题TSP
</code></pre>
<h3 id="算法-2">算法
</h3><p>分支限界法解空间书及搜索/扩展过程</p>
<pre><code>扩展结点
从活结点表ANT中（根据某种准则，e.g.  bound值最大、最小，价值最大）筛选出来、当前准备进行扩展的结点，即当前进行处理的结点

1. 评估每个活结点的价值，按照价值最大/小化原则，从ANT表中选取扩展结点e_node
2. e_node 扩展方式：
    (1) 宽度优先，即生成e_node的全部子结点  
    (2) 评估这些子结点，满足界限约束，有可能产生更优解的结点被称为活结点，加入ANT
    (3) 不满足约束、或无法产生最优解的子结点被舍弃
3. e_node 结点被扩展后，该结点转换为死节点，以后将不会被再搜索
    活结点 -&gt; 扩展结点 -&gt; 死结点
</code></pre>
<p>算法框架</p>
<pre><code>1. 根据初始结点，确定函数的上下界[down, up]
2. 将活结点表ANT初始化为空
3. 生成根节点v0的全部子结点——宽度优先
    对每个子结点v，执行以下操作
    (1) 估算v的目标函数值 bound(v)
    (2) 若目标函数值 bound(v) 不超过界限，将v加入ANT表
        (最大化问题bound是上界，bound &gt;= down；最小化问题bound是下界，bound &lt;= up)
4. 循环，直到某个叶节点在目标函数值在表ANT中最大
    (1) 从ANT中选择bound最大的结点vi，扩展其子结点
    (2) 对vi的每个子结点c，执行下列操作
        i. 估算c的bound
        ii. 如果bound满足约束，将c加入ANT
        iii. 如果c是叶节点 并且 bound(c) 在表中最大
                则将叶节点c对应的完全解输出，算法结束
        iv. 如果c是叶节点，但是bound(c) 在表ANT中不是最大
            更新界限
            删除ANT中不满足新界限的结点
</code></pre>
<h4 id="旅行商问题">旅行商问题
</h4><p>搜索空间树</p>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-51.png"
	width="1201"
	height="820"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-51_hu9838623666865882572.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-51_hu15018935973087743691.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="146"
		data-flex-basis="351px"
	
></p>
<p>TSP 的上下界</p>
<pre><code>1. 利用贪心法 + 回溯 计算上界up
    以起始城市1作为出发城市，每次从当前出发城市发出的多条边中，选择没有遍历过的最短边连接的城市，作为下一步达到城市，即：选择离当前出发城市最近的城市作为下一步出发城市

2. TSP 下界down
    (1) 矩阵中每一行的最小元素相加 —— 从每个城市走向下一个最近城市
    (2) 在一条路径上，每个城市i有2条邻接边：进入该城市、离开该城市
        第i个城市对应矩阵中第i行
        将每一行最小的2个元素相加除以2，并向上取整，得到一个更合理的下界

3. 对于某个结点的下界down
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-53.png"
	width="1147"
	height="765"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-53_hu3336519278479650455.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-53_hu15579531662158040936.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="149"
		data-flex-basis="359px"
	
></p>
<p>剪枝</p>
<pre><code>对TSP等最小化问题，在问题求解过程中，如果1个部分解的目标值dist的下界估计值lb，超出问题完整解的上界，则该部分解对应了死结点，可剪枝
</code></pre>
<p>算法步骤</p>
<pre><code>1. 采用贪心法，计算问题上界up —— 用于后续结点剪枝
2. 将活结点ANT表置空
3. for(i = 1; i &lt;= n; i++)  x[i] = 0; // 解向量初始化
4. k = 1; x[1] = 1;    // 从顶点1 出发
5.  while( k &gt;= 1)
5.1     i = k+1 ;    
5.2     x[i]=1;
5.3     while(x[i] &lt;= n)    // 宽度优先，生成x[k] 的子结点x[i] = 1,2,...,n
5.3.1       if( 路径上城市顶点不重复 )
5.3.1.1         计算x[i] 的下界lb
5.3.1.2         if (lb &lt;= up)
                    将路径上的顶点和lb值存入活结点表ANT
5.3.2       x[i] = x[i] + 1;        // 依次生成x[i] = 1 的各个兄弟结点
5.4     if(i == n &amp;&amp; bound(i)是ANT中所有叶节点中最小的)
            output(x)
5.5     else if(i == n)
            更新上界 up = minlb
            删除ANT表中bound(vi) &gt; up的结点
5.6     k = 表ANT中lb最小结点中，已得路径上的顶点个数
</code></pre>
<h4 id="0-1-背包问题-1">0-1 背包问题
</h4><p>问题</p>
<pre><code>n个物品{1, 2,…, n}，重量w[1: n]，价值v[1: n]，背包容量C
4个物品，重量(4, 7, 5, 3 )，容量C=10，
   价值(40, 42, 25, 12)
按照单位价值最大化排序
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-54.png"
	width="1161"
	height="492"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-54_hu12786515785194935792.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-54_hu12627740226315510251.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="235"
		data-flex-basis="566px"
	
></p>
<p>搜索树</p>
<pre><code>二分搜索树，依次考虑物品1, 2, 3, 4, …, n是否放入
k=0层：对应根节点，未考虑任何物品，部分解S={?, ?, ?, ?}
k&gt;0层：
    物品1, 2, …, k-1已经确定是否放入， 部分解S={x1, x2, …, xk-1, xk?, ?, …, ?}中的x1, x2, ..,xk-1的值已经确定
    考虑第k个物品是否放入，确定xk?，左分支→放入，右分支→不放入
</code></pre>
<p><img src="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-55.png"
	width="795"
	height="318"
	srcset="/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-55_hu18315862016468597842.png 480w, /p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/image-55_hu17515944796251367593.png 1024w"
	loading="lazy"
	
		alt="Alt text"
	
	
		class="gallery-image" 
		data-flex-grow="250"
		data-flex-basis="600px"
	
></p>
<p>界限函数</p>
<pre><code>下界down
    贪心法，第1个可装入的、具有最大价值/重量比的物品所具有的价值
上界up
    背包中全部装入第1个物品，且装满

对第k&gt;0层（k=1,…,n）结点，代表对物品1~k-1已作出选择（装入、不装入），假设已经装入的物品总重量为w，获得的总价值为v，该结点的限界函数ub
    = 已装入背包中物品取得的价值v 
        + 背包剩余容量(C-w)*剩余物品中的最大单位重量价值
</code></pre>

</section>


    <footer class="article-footer">
    

    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2024 ffirestorm
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
