[{"content":"概论 通信与电信 通信系统模型 通信网三要素 由 终端设备、交换设备、传输设备 组成\n交换方式 所谓电信交换，就是在电信网上，在通信的源点和目的点之间建立通信通道，并传送信息的机制。\n交换和选路的区别：\n选路：每一个交换设备如何选择合适的出线，从而在交换网中建立最佳的从源点到目的点的信息通道； 交换：每个交换设备内部如何将入线的信息送到出线上。 电路交换 三个阶段是面向连接方式最显著的特征：建立、传输、释放\nPSTN采用电路交换方式\n实时、恒定速率的话音业务 电路交换系统的特点\n呼叫建立时向网络申请资源，建立一条从主叫到被叫的通路；呼叫结束时释放该通路。 用基于呼叫损失制的方法来处理业务流量.如果申请不到资源，则发生呼损。 面向连接。通信过程中，双方始终占有这条通路，保证数据快速传递。支持实时的、交互的通信，但线路利用率低。 只提供透明传输。对通路上的通信内容，交换系统不进行差错控制。 适于交换同步时分复用的信号。 同步时分复用信号的最小交换单元为时隙。 比如30/32路的PCM系统\n一帧=32时隙=125μs 报文交换 采用 ‘存储—转发’ ，以报文为单位进行交换 无呼损，不需要叫通对方就可以发送报文 由多个报文送往同一地点时，要排队按顺序 报文传送中有检错纠错 提高线路利用率 交换机要有哒的存储容量（要先存储再转发） 不适用于即时交互式数据通信 分组交换 采用存储-转发，分组单位是packet\n分组是将报文截成许多短的、规格化了的‘分组’\n特点：\n‘分组’ 实时性比报文交换高 线路统计复用，通信线路的利用率高 可靠性高，分段进行差错校验，网络故障时可自动重选路由 非透明传输，交换节点要对分组进行处理 无呼损，但有可变的呼叫延迟 适于交换统计时分复用的信号，最小交换单元为分组 分组交换有两种工作模式\n数据报Datagram\n每个数据分组都包含终点地址信息，独立寻找路径，在网络终点需要重新排序。 时延大 DG方式则不需要有建立过程，但对每个分组都要独立地进行选路。 DG方式中各个分组可选择不同路由，对故障的防卫能力较强，从而可靠性较高。 DG方式则适用于面向事务的询问／响应型数据业务。\n虚电路Virtual Circuit\n类似电路交换，通信要经过 连接建立、数据传输、连接拆除 三个阶段 不同于电路交换中的物理连接，而是逻辑连接 分组头中只含有对应于所建立的VC的逻辑信道标识 传输时延小，分组有序到达 VC方式预先有建立过程，但一旦虚电路建立，在端到端之间所选定的路由上的各个交换节点都具有映象表，存放出入逻辑信道的对应关系，每个分组到来时只要查找映象表，而不需要进行复杂的选路。 VC方式对故障较为敏感，当传输链路或交换节点发生故障时可能引起虚电路的中断，需要重新建立。 VC方式适用于较连续的数据流传送，其持续时间应显著地大于呼叫建立的时间，如文件传送、传真业务等\n快速分组交换——帧中继 取消原网络完成的逐段链路的差错控制，由网络的边缘完成； 交换节点只进行差错检查 交换的基本数据单元为帧，实现不同协议的数据的封装和传输 在链路层引入数据链路连接标示符DLCI，完成分组交换的虚电路功能 用于LAN之间的互联 各交换方式的比较： 支持的业务类型（话音/数据/图像/视频）和典型的业务特征（实时性/突发性/可靠性/交互性…） 电路交换：\n话音业务 实时性高，可靠性高，适合长时间连续传输 分组交换：\n数据、图像、视频 突发性强，实时性较低，适合短时间大量数据传输 信息传送单元和信息传送长度（可变/固定） 单位：\n电路交换： 时隙，长度固定 分组交换：分组，长度可变 帧中继： 帧，长度可变 适合的信息复用方式和电路利用率 电路交换的复用方式是：时分复用TDM，链路利用率较低\n分组交换的复用方式是统计复用，链路利用率高\n帧中继交换的复用方式也是统计复用，链路利用率高\n连接类型（面向连接/无连接，物理连接/逻辑连接）和信息传输时延 电路交换是面向连接的\n时延低 分组交换是无连接的\n分组交换中的虚电路方式，是逻辑连接而不是物理连接 时延高 对业务冲突或过载的处理方式 电路交换使用呼损\n分组交换采用呼叫延迟\n帧中继采用拥塞控制\n信息可靠性 电路交换可靠性高\n分组交换和帧中继较低\n各种常用网络的交换方式 PSTN电话网、B_ISDN、Internet、No7信令网、GSM网络、GPRS网络、4G网络、5G网络、IMS系统、MPLS网络、SDN\nPSTN电话网：电路交换 B_ISDN：帧中继 Internet：分组交换 No7信令网：电路交换 GSM网络：电路交换 GPRS网络：电路交换和分组交换 4G网络：分组交换 5G网络：分组交换 IMS系统：分组交换 MPLS网络：帧中继+分组交换 SDN：分组交换 各种常用网络的重要信令/协议 PSTN电话网、IMS、MPLS网络、SDN、Internet——No7信令网、LDP、SIP、Openflow\nPSTN电话网：No7信令网 IMS：SIP MPLS网络：LDP SDN：OpenFlow Internet：TCP/IP 电信交换系统的基本结构 程控电话交换机、IP路由器、MPLS路由器的结构\n程控电话交换机：\n结构：控制单元、交换矩阵、接口单元、信令单元 IP路由器：\n结构：控制平面（路由协议）、转发平面（数据包处理）、接口（网络接口）、管理平面（网络管理） MPLS路由器：\n结构：控制平面（LDP、RSVP）、转发平面（标签交换）、接口（MPLS接口）、管理平面（网络管理） 复用技术 时分复用 根据抽样定理使多路信号以时间分割的方式交替在同一条线路上互不干扰地传输\n同步时分复用\n依据数字信号在时间轴上的位置区别各路信号，无信息传送时也占用信道 各支路的信息比特率稳定 统计时分复用——分组化时分复用\n标志化信道：信息属于哪路取决于标志码，与出现的时间无关； 分组长度可变，分组头起定界作用； 统计复用提高信道利用率 一定容量的排队存贮器，解决瞬间的出线冲突； 统计时分复用——异步时分复用\n标志化信道：分组长度固定，分组头标志输出端 统计复用提高信道利用率 插入空信元保持信元同步 较小容量的排队存贮器，解决瞬间的出线冲突 频分复用 利用调制手段和滤波技术使多路信号以频率分割的方式同时在同一条线路上互不干扰地传输 码分复用 CDMA酒会，只过滤出有用的（俄罗斯语、中文、英文、德语\u0026hellip;只关注到自己听得懂的）\n波分复用 连接类型 带宽分配 2 交换网络 交换单元 四个端：输入、输出、控制、状态 M条入线N条出现的称为 MxN 的交换单元，编号从0~M-1 0~N-1 分类：\n按照信息流向，分为有向和无向开关 按照使用需求分类，分为集中型（M\u0026gt;N）、分配型（M==N）、扩散型（M\u0026lt;N） 开关个数计算\n有向交换单元\nMxN的无向交换单元，里面需要MxN个单向开关\n无向交换单元\n采用双向开关：每两个端口只需要一个双向开关，自己跟自己不用开关。所以需要1+2+\u0026hellip;+N-1个开关 = N*(N-1)/2 采用单向开关：每个端口不用跟自己连，需要N*N-N 个开关 交换过程：\n建立内部通道，完成信息交换 完成信息交换后，拆除内部通道 连接的定义：\n对于一个入端t，和一组出端Rt，c={t, Rt}称为一个连接 若r∈Rt ，Rt 中只含有一个元素，则称该连接是一对一（点对点 ）连接 若r∈Rt ，Rt 中含有多个元素，则称该连接是一对多（点对多点 ）连接 同发与广播：\n如果是点对多点的，就是同发 如果出端是所有出线口，那么就是广播 交换单元不允许多对多或多对一，这种情况叫出线冲突 连接函数\n排列表示法\n一列是一个连接 ，上面表示出线，下面表示入线 当不存在同发时，可用简写成一行（一个出线只对应一个入线，不能多个入线发到同个出现上） 如果满足以下三个条件：\n1. 交换单元的入端数M等于出端数N；\n2. 没有空闲的入端和出端；\n3. 没有点对多点的连接。\n那么可以得到一个结论：一个N*N的交换单元有 N！种不同的点对点连接方式。\n函数表示法\n直线连接\n交叉连接\n间隔交叉连接\n均匀洗牌连接\n二进制表示法中，最高位移到最低位后面了\n蝶式连接\n二进制的头尾调换 连接的效果是前后直连\n空分交换单元 空间接线器 ———— 基本开关阵列\n实际的开关阵列里面的2*2交换单元有两种形式： 1. bar连接型 平行 上左入，下右出 2. cross连接型 交叉 可以避免出现冲突，不支持同发 缺点\n交叉接点开关数量巨大 交叉接点开关利用率低 克服缺点的方法\n时分交换 多级网络 空间（S）接线器\n实现一个时隙内任意母线（highway 高速复用线）间的交换。 由电子交叉点（能快速打开闭合）矩阵、控制存贮器（控制谁和谁连接）CM和控制电路组成。 控制方式分为：输入控制和输出控制 输出控制方式： 出现和哪条入线连接 电子交叉矩阵， 32个时隙， 上方为出线号， 一行代表一个时隙 里面填的是入线 只能填1个入线 输入控制方式 和输出控制相似， 矩阵里面填的是出线号 空间交换单元的工作原理（以输出控制方式为例） 每条出现都对应8条入线，是一个8选1的选择器，所以是输出控制方式 时分交换单元 内部只存在一条惟一的通路，由输入复用线上各子信道分时共享 PCM线路连接，作为复用线，有多少时隙，就能交换多少路数据 通过这个通路的类型来划分\n时分交换单元——共享存储器型交换单元 交换单元有N路输入信号和N路输出信号， 存储器被划分成N各区域， N路信号被放在存储器的N个区域中，不同区域的N路信号被读出，形成N路输出信号 基本结构\n信号存储器 控制器 工作方式\n入线缓冲，控制读出 出线缓冲，控制读入 输入缓冲方式：\nN个区域与N路输入信号一一对应，0~N-1路输入信息分别对应存放在存储器的0~N-1个区域中 并在适当的时候输出到目的输出信道上 比如 1-\u0026gt;N, 2-\u0026gt;1, N-\u0026gt;2 这样的连接 首先1~N号区域都存储每个输入端要交换的信息，以及交换的出现号 再从0~N遍历出线号 比如1号出线，就是2号入线的信息，2号出线就是N号入线的信息，N号出现就是1号入线的信息 这样进行交换 输出缓冲方式：\n0~N-1 路输出信息 分别对应0~N-1路输出信息。从不同输入信道来的信息如果要交换到输出信道中，就把信息放在这个输出信道所对应存储器的相应区域中，当输出时刻到来时输出信息 在存储器的0~N-1号区域，分别存储对应出线号的连接信息，比如 1—\u0026gt;N 2-\u0026gt;1 N-\u0026gt;2 就是在a[N]=1, a[1]=2, a[2]=N 共享存储器的同步时分复用\n时间T接线器\n实现一条母线上的时隙交换 由话音存储器、控制存储器和控制电路组成 控制方式分为：输出控制和输入控制 话音存储器SM\n用来暂时存放数字编码的话音信息。 话音存储器的大小与入复用线（或出复用线）上的时隙数相关。如果一条入复用线（或出复用线）上有n个时隙，那么话音存储器对应地必须有n个单元（一般为32个时隙 0~31 ）。 由于每个时隙上传输的是8位编码，所以话音存储器每个单元的大小也应该是8位。 控制存储器CM\n用来控制话音存储器的读或写。 它存放的内容是话音存储器在当前时隙内因该写入或读出的地址。 控制存储器与话音存储器的大小相等，假设话音存储器有n个单元，那么控制存储器也应该有n个单元 CM一个单元的大小和时隙数有关，比如有32个时隙，那么一个单元是5bit 控制存储器单元数=话音存储器单元数=入复用线（或出复用线）的时隙数\n它的输出和输入控制方式的区别在于：SM的写入和读出是控制的还是顺序的\n输出控制的话，SM就是顺序写入，控制读出 输入控制的话，SM就是控制写入，顺序读出 CM在两者里面都是控制写入，顺序读出 输出控制方式\n1. CPU先往CM填输出地址（第j个时隙交换的信息在第i号SM单元里）CM[j]=i 2. 入复用线信息按时隙号顺序写入SM， 3. 第j个时隙到来时，出复用线读CM的第j个单元信息（存放SM对应地址）i 4. 再从SM的第i个单元读出信息，发到出复用线上 这样就完成了入复用线i和出复用线j的交换 CM下标和内容： \u0026lt;出时隙 —— SM地址\u0026gt; SM下标和内容： \u0026lt;入时隙 —— 交换信息\u0026gt; 1. CM 控制写入 2. SM 自动写入 3. CM 自动读出 4. SM 控制读出 总结为：顺序写入，控制读出\n输入控制方式\n1.1 入复用线第i个时隙到来时，接线器从CM第i个单元读出一个地址j，该地址是话音存储i时隙信息的地址 1.2 随后，接线器把输入复用线上第i个时隙的信息存储在SM的j中 2.1 出复用线在第j个时隙到来时，从SM的第j个单元读出 这样就完成了入复用线i时隙跟出复用线j时隙的交换 1. CM 控制写入 2. CM 自动读出 3. SM 控制写入 4. SM 自动读出 总结为：控制写入，顺序读出 时间T接线器特点：\n以空间位置的划分实现时隙交换 SM划分为N个区域，每个区域一个字节，存放一个话音数据。各个区域间不共享，各个区域内无排队缓冲。 交换的控制过程由硬件CM实现，速度快。 交换时延小，且稳定。 严格无阻塞。 可避免出线冲突。 易于实现同发和广播。 带宽（速率）固定为64kb/s。 一秒有8k次交换，1分钟60s，就是60*8k = 480k 时分交换单元——共享总线型交换单元 交换网络 交换网络从外部看，也有一组输入端和一组输出端，将其分别称为交换网络的入线和交换网络的出线。如果交换网络有M条入线和N条出线，则把这个交换网络称为MxN的交换网络 单级交换网络和多级交换网络\n相同容量的多级网络比单级网络的交叉点数量减少 有阻塞交换网络和无阻塞交换网络\n- 严格无阻塞交换网络 只要入端与出端空闲时，就可以通过交换网络建立一个连接 - 可重排无阻塞交换网络 只要入端与出端空闲时，通过对已有连接的重排，就可以通过交换网络建立一个连接 - 广义无阻塞交换网络 一个给定的网络存在着固有的阻塞可能，但又可能存在着一种精巧的选路方法，使得所有的阻塞均可避免，而不必重新安排网络中已建立起来的连接 单通路交换网络和多通路交换网络\n时分交换网络和空分交换网络\nCLOS网络 3级CLOS网络\n入线N条，被分为r组，每组n条：N = r*n。第一级就有r个交换单元 假如第二级有m个交换单元，那么第二级每个交换单元都有r条入线，第一级每个交换单元有m条出线 3级CLOS网络严格无阻塞条件\n本级的入线 = 上级的交换单元数 本级的出线 = 下一级的交换单元数 用5元组（m1 , n3 , r1 , r2 , r3）表示 m1表示第一级的入线数，n3表示第三级的出线数，r表示每一级的交换单元个数 假如第一级的某个条入线a要到第三级的一条出现b 最不利的情况是：a当前的交换单元其他n-1条入线都有信息要交换，并且所有的n-1条输出线都连接到第2级的不同的交换单元上；最后一级与b相连的交换单元除b以外所有的n-1条输出线也均有信息要交换出来，并且对第2级来说，需要另外的n-1个交换单元，且这些交换单元都要有一条出线和b的交换单元相连。 那么在最坏的情况下，共需要(n-1)+(n-1)=2(n-1)个可供选择的第2级交换单元，这时候为了保证a~b严格无阻塞，则需要多加一个交换单元，所以一共需要2(n-1)+1=2n-1个交换单元 一般的CLOS网络严格无阻塞的条件为： n2 \u0026gt;= (i1-1)+(o3-1)+1 = i1 + o3 -1 中间个数 \u0026gt;= 出线数 + 入线数 - 1 3级CLOS网络可重排无阻塞条件\n充要条件： r2 ≥ Max ( m1 , n3 ) 重排次数≤ r1 + r3 - 2 TST网络 由时间(T)接线器和空间(S)接线器组成 反向路由的半帧选择 TS(A-\u0026gt;B)+F/2 = TS(B-\u0026gt;A) 控制存储器的合用 (因为双向差半帧，存储的内容是一样的) 网络完全无阻塞的条件：m（内部时隙数）=2n（输入时隙数） 同发特性：\n初 T 顺入控出， S 输出控制/输入控制， 次 T 控入顺出。 初 T 控入顺出， S 输出控制/输入控制， 次 T 顺入控出。 TST网络结构\n每一条PCM线路连接到一个T接线器，有多少条输入或输出PCM线路，就有多少个T接线器 S级的出入数决定于两侧T接线器的数量，即等于输入输出线数量 工作原理 A和B要通信\n首先A到B，A的TS2时隙空闲，往第一级的SM中顺序写入， 第二级的TS7为内部时隙(表示该时隙空闲，S接线器可以交换) 在TS7的时候，从第一级的SM中拿出信息，交换到B上， B是TS31空闲，该级接线器是输入控制，所以在TS7时控制输入，B在TS31时得到信息 话音交换是双向的 所以B也要向A建立连接。 一般认为反向路由的内部时隙和正向路由的内部时隙差半帧，所以在TS31时，B往第一级顺序输入，在TS23时交换到第二级传给第三级接线器，接线器在A空闲时TS2传给A banyan网络 由2*2的交换单元构成的n*n矩阵banyan网络 构造2N*2N的BANYAN网络，可以用两个N*N的BANYAN网络 和N个2*2交换单元组成 前一级N*N BANYAN网络的出线分别连接最后N个2*2交换单元的相同序号的入线 N*N的BANYAN网络，级数为log2N；每一级需要N/2个2*2交换单元。共需要 ( N/2 )*log2N 个交换单元 PPT上的BANYAN例子\n内部阻塞和出线冲突\n交叉连接单元 平行 交换 点到多点(上播，下播) 环回 banyan网络及其特性 banyan是基于树形结构 banyan网络级数为k=lb N, 每级有N/2个交换单元 已有N*N的banyan网络，要构成2N*2N的扮演网络，需要2组N*N的banyan网络以及N个2*2的交换单元 第一组N*N的N条出线分别与N个2*2的交换单元的某一入线相连，第二组的N*N的N条出线分别与2*2的另一入线相连 自选路由特性 从任意入线到任意出线都有且只有一条通路 但是每条通路并不是完全分离的，会有公共的内部链路，所以会有内部竞争 banyan网络是有阻塞网络 解决内部冲突的方法\n使用排序的banyan网络 先经过batcher排序网络，如果某个排序节点只有一个输入，那么就往小的方向送\n根据连接的目的地址将其按升序排列，每个节点比较两个连接目的地址，并将高地址连接送到高端，低地址连接送到低端。仅有一个连接时，送到低端。\n大值向箭头方向\n构造多通路的banyan网络\n输出地址不变的情况下，增加输出的链路\n增加级数\n增加级数，每增加一级，多一倍通路\nbenes 增加平面数\n一个BANYAN网是一个平面，多几个网，在一个平面有阻塞的适合去另一个平面就可以了\nbenes 网络 可重排无阻塞网络。 使用2x2的交换单元来构成NxN的benes网络的方法\n两侧各有N/2个2X2交换单元，中间为两个N/2 X N/2的子网络，每个交换单元以一条链路连到每个子网络；再将中间子网络按上述方法继续分解，直到中间子网络就是2X2交换单元为止。 3 电话交换系统 电话交换基础 拨号：\n脉冲式\n音频式\n极性保护：\n交换机向用户提供直流电，该电路保证：无论外部a、b线极性如何，内部电路c、d的极性固定\n程控交换机的基本组成\n由话路部分和控制部分组成 程控数字交换机的系统结构 用户模块通过PCM连到数字交换网络，再连到远端模块 每个电话机通过双绞线连接到用户电路 绿色是话路部分，红色是控制部分 接口设备：是实现数字交换系统和外围环境的接口。 远端接口：是到集中维护操作中心、网管中心、计费中心等的数据传送接口。 用户集中级：完成话务集中功能，集中比一般为2:1到8:1一般为单T交换网络。 用户模块：用户集中级+用户电路 远端模块：设置在远端的用户模块。 用户模块 用户电路\n每个电话用户对应一个用户电路。一块用户电路板包含多个用户电路 用户级交换网络\nT接线器，集中话务，连接收号器 收号器\n各种交换机设计不同，收号器可能位于中央交换网络侧 扫描存储器\n存储用户环路状态（摘机状态、挂机状态的信息） 分配存储器\n存储处理机送给用户电路的控制命令 微处理机\n控制用户级的交换，读写各个存储器 信号提取插入\n提取接收中央处理机发来的信息，插入送给中央处理机的信息 控制子系统 中央级 系统资源分配 中央交换网络控制 呼叫处理 信令处理 控制用户级CPU以及完成系统的操作、维护、管理等 用户级 对用户模块内所有用户线路进行监视扫描 控制用户级交换网络 完成话路集中 对相关资源进行分配 话路子系统 由中央级交换网络和用户级交换网络以及各种借口设备组成\n交换网络主要完成交换功能 接口设备主要完成外部信号与交换机内部信号的转换 接口设备/接口电路 接口设备主要有\n用户电路 中继电路 信令收发设备 接口设备的功能是完成外部信号与交换机内部信号的转换\n接口类型 数字接口\nV接口 网络侧的A、B类接口 模拟接口\nZ类接口 网络侧的C类接口 用户电路 是程控交换机通过用户线与用户终端相连的接口电路\n用户电路也有模拟和数字电路之分\n模拟用户电路功能有：BORSCHT B 馈电 —— battery feeding 通过电容（隔直流，通交流）和电感（隔交流，通直流）的设置，既保证了向用户供电，减少对话音信号的影响，又可将话音信号传送到交换机里 -48V ~ 0V O 过压保护 —— overvolatage protection 防止外来高压袭击 阻止高的电流 R 振铃控制 —— ringing control 用户摘机后，振铃开关送出解铃信号 S 监视 —— supervision 监视用户线上的直流环流 通/断 来判断下面三种状态 用户话机的摘挂机状态 用户话机（号盘）发出的拨号脉冲 投币、磁卡等话机的输入信号 C 编译码和滤波 —— CODEC \u0026amp; filters 完成模拟和数字信号的转换 H 混合电路 —— hybrid 完成二/四线的转换 T 测试 —— test 配合外部测试设备对用户线进行测试 中继电路 交换机和中继器的接口设备，也叫中继器\n有以下六个功能\n码型变换 内部的NRZ（单极性不归零码）与外部的HDB3（高密度双极性码）的转换 帧同步 就是从接收的数据流中搜索并识别到同步码，以确定一帧的开始，以便接收端的帧结构排列和发送端的完全一致。 帧同步码0011011在PCM的偶帧的TS0中 复帧同步 PCM的一个复帧由16个帧组成。 使接收端与发送端的复帧结构排列完全一致 复帧同步码在F0（复帧的第一个帧）的TS16的高4个比特中传输，码字为0000 一帧32个时隙（一帧是125μs），一个时隙8bits，所以一帧是256bits，换算成带宽是2048kbits/s 时钟提取 就是从输入的数据流中提取时钟信号，作为输入数据流的基准时钟。同时该时钟信号还用来作为本端系统时钟的外部参考时钟源。 提取和插入信号 帧定位（再定时） 把输入数据的时钟调整到本局系统时钟上，实现系统时钟的同步 数字交换网络-话路建立 复用器和分路器 1 点速率为 2048 kbit/s，传输信号为串行码；2 点速率为 256 kbit/s，传输信号为 8 位并行码；3 点速率为 1024 kbit/s，传输信号为 8 位并行码。\n如果复用器输入线数为n，依次编号为0,1,…,n−1，且i号输入线上j时隙信号TSj经复用器串并变换和复用后，在输出线上第k个时隙输出，即在TSk出现，则有：k=jn+i。\n话路建立：\n用户 A 呼叫用户 B：用户级出线HW0TS8经过复用器M0交换为ITS16=2∗8+0，选择交换时隙ITS20； 用户 B 建立到用户 A 的连接：采用反向法（半帧法）计算，由ITS20，T 接线器输入信号每帧为 64 时隙（由两条 PCM32 线路复用而来），半帧为 32，故 20+32=52，所以 B 到 A 的连接选择ITS52。 完整版：\n每个用户模块连接 256 个用户，内部提供 8 条 HW，32TS/HW（即 256*256）的交换 所有模块（包括用户模块/中继模块/信号音源）连接到 TST 的中央交换网络，支持 16K * 16K 的交换（每个 T 支持 512*512 交换）。用户模块采用复接方式接入 TST（A 为复接点），实现话务集中 用户 A 接至模块 0 的 HW0TS1，用户 B 接至模块 n 的 HW7TS31 （双向都使用该时隙） 系统为用户 A 选择模块 0 的空闲时隙 HW0TS3（双向），模块 0 的 HW0 固定连接到 M0 的 HW0; 为用户 B 选择模块 n 的空闲时隙 HW3TS8（双向），模块 n 的 HW3 固定连接到 M31 的 HW8 A→B 连接时，TST 网络选择使用内部时隙 ITS4；B→A 连接时， 使用反相法选择内部时隙 程控交换软件技术 程控交换软件系统 特点：\n实时性 多任务并发执行 高可靠性 组成：\n由系统软件和应用软件组成 交换机操作系统：是交换机硬件和应用软件之间的接口\n程控交换机的操作系统对任务调度一般采用基于优先级的抢占式调度算法。每个任务都有一个优先级。\n优先级分为三种：\n故障级任务，具有最高优先级 周期级任务 基本级任务 呼叫处理的基本原理 —— 重点 一个呼叫的处理过程：\n摘机呼叫 送拨号音，准备收号 收号 号码分析 接至被叫用户 向被叫用户振铃 被叫应答和通话 挂机，通话结束 呼叫处理过程的特点：\n整个呼叫处理过程可分为若干个阶段，每个阶段可以用一个稳定的状态来表示； 整个呼叫处理的过程就是在一个稳定状态下，处理机监视、识别输入信号，进行分析处理，执行任务和输出命令，然后跃迁到下一个稳定状态的循环过程； 两个稳定的状态之间要执行各种处理； 在一个稳定状态下，若没有输入信号，状态不会迁移； 相同的输入信号在不同的状态下会有不同的处理，并迁移到不同的状态； 在同一状态下，对不同输入信号的处理是不同的； 同一状态下，输入相同信号，也可能因不同情况得出不同结果 呼叫的处理过程：\n输入处理 识别并接收外部输入的处理请求和信号，生成事件 分析处理 根据目前状态和输入信号进行分析、判别，决定下一步任务 任务执行和输出处理 根据分析结果，发布控制命令 SDL图 用SDL图表示呼叫处理过程 输入处理 对用户线、中继线、信令设备进行监视、检测并进行识别，生成相应事件放入队列，以便其他程序取用。大多是周期级程序，包括： 用户线状态扫描：\n摘挂机识别 比对这次扫描结果和前次扫描结果进行判断\n脉冲识别\n位间隔识别\n按钮拨号DTMF信号\n当信号标志 SP = 0 表示DTMF收号器正在收号，可以从收号器读取号码信息 当收号标志 SP = 1 表示DTMF收号器没有收号，无信息可读 分析处理 属于基本级程序\n去号分析\n根据输入分析检测的摘机信号，根据用户数据，确定下一步动作 基于主叫用户数据 去号分析的结果决定下一步接续动作 号码分析\n号码分析可分为二步：号首分析、号码翻译\n号首分析：判断前几位（1~3位），以判定呼叫的接续类型，获取应收号长和路由等信息。\n号码翻译：通过接收到的被叫号码来找到对应的被叫用户。确定被叫用户的用户设备号，从而确定其实际所处的物理端口。 来号分析\n来话分析的数据来源是被叫用户数据。 状态分析\n状态分析的信息源是状态和输入的事件。 执行和输出 任务执行是指 从一个稳定状态跃迁到下一个稳定状态之前，根据分析处理的结果，处理机完成相关任务的过程\n分配和释放各种资源 启动和停止各种计时器 形成信令、处理机间通信消息和驱动硬件的控制命令 开始和停止计费 计算操作 存储各种号码 对用户数据、局数据的读写操作 在任务执行中，要输出一些信令、消息或动作命令，这就是输出处理\n送各种信号音、停各种信号音，向用户振铃和停振铃 驱动交换网络建立或拆除通话话路 连接DTMF收号器 发送公共信道信令 发送线路信令和MFC信令 发送处理机间通信信息 发送计费脉冲等 程控交换软件技术 群处理\n对一群对象同时进行逻辑运算和处理 从群处理结果可知：用户5和0摘机，用户7挂机\n逐次展开法\n基于逐次展开分析表（多级检索表）\n每一级对应一位号码 表格驱动\n时间表每一行代表一个时间\n每一列代表一个程序 若某一行某一列的值为1，则代表在该时刻程序要被调用，若为0，则不用调用 屏蔽表为0时，代表该任务被屏蔽，不管时间表是1还是0，都不做。 屏蔽表\u0026\u0026时间表 == 1 才会在该时刻做当前任务 有限状态机的实现\n二维数组的有限状态机的实现 通过状态号和事件号得出要做的任务\n多级表的有限状态机的实现 控制系统 呼叫处理能力与过负荷控制 呼叫处理能力\n用BHCA来衡量：最大忙时呼叫次数，单位时间内控制系统能够处理的呼叫次数 系统开销 = 固有开销+非固有开销\nBHCA计算模型：t = a+bN 当交换设备上试呼总次数超过它的设计负荷能力的10%时，此时称为10%过负荷\n当交换机设备出现过负荷，交换机要采取过负荷控制，避免交换机的处理能力大幅下降 高可靠性\n控制系统的结构方式 集中控制 处理机可以对交换系统内的所有功能及资源实施统一控制 n个CPU，每个都能完成所有的功能及控制 三个特点： 处理机直接控制所有功能的完成和资源的使用，控制关系简单，处理机间通信接口简单 每台处理机上运行的应用软件包含了对交换机所有功能的处理，因而单个处理机上的应用软件复杂、庞大 处理机几种完成所有功能，一旦处理机系统出现故障，整个控制系统失效，可靠性低 分散控制 由多个处理机分担完成，每个处理机只完成交换机的部分功能及控制部分资源\n全分散控制\n采用全分散控制方式的控制系统，其多个处理机之间独立工作，分别完成不同的功能和对不同的资源实施控制，这些处理机之间不分等级，不存在控制与被控制关系，各处理机有自主能力。\n分级分散控制\n就是控制系统由多个处理机构成，各处理机分别完成不同的功能和对不同的资源实施控制，处理机之间是分等级的，高级别的处理机控制低级别的，协同完成整个系统的功能。\n多处理机的分担方式/工作方式 功能分担方式\n多个处理机完成不同的功能，不同的处理机完成不同功能\n提高整个系统的适应性，完成不同功能的处理机可以有不同的配置；模块可以按需配置 话务分担方式（负荷分担）\n多个处理机各自完成一部分话务功能\n提高BHCA ，提高可靠性 冗余方式\n双机冗余配置 N+m冗余配置：N个处理机在线运行，m个处理机处于备用状态 除了正常运行的处理机外，还配置备用的处理机 同步方式\n主备机同时接收外部事件，同时处理，并比较处理结果。结果相同时，由主用机发命令；结果不同时，双机均进行自检。若主机故障，则进行主备切换；若备机故障，则备机脱机检修；若都无故障，则保持原状态。这种方式可以保证切换时不损失任何呼叫，但技术复杂\n互助方式\n正常工作时，双机按话务分担方式工作，当一个处理机故障时，另一个处理机接管全部业务。这种方式可以保证故障时通话状态的呼叫不损失，但故障时单机的话务负荷比较高。\n热备用方式\n正常工作时，由主机负责全部话务，并随时将呼叫数据送给备用机，备用机不处理任何呼叫；主用机故障时，进行主备机切换，备用机接管全部话务，并根据已有的呼叫数据保证一部分呼叫不损失。\n多处理机的通信方式 电话通信网 4 分组交换技术MPLS 路由器技术 交换单元结构 包转发原理：\n信息到达路由器的入线 线路卡按不同线路的帧格式提出净荷，并将校验正确的帧送入I/O管理ASIC I/O管理ASIC按不同的协议格式（IPv4或MPLS）提出3层的包，根据包的交换要求设置“寻路关键字”，并将包分段成64字节的块，一起送分布缓冲管理器 缓冲管理器将“块”轮流放入共享存贮器 缓冲管理器根据块中的“寻路关键字”构造“包通告”，送寻路部件 寻路部件查找路由 寻路部件将包含了转发决定的“包通告”送缓冲管理器，缓冲管理器再将此包通告转发给输出端口的I/O管理器，输出端口的I/O管理器将所有的包通告排队，逐一处理 I/O管理器处理到某一个包通告时，通告缓冲管理器产生一个读“块”的请求，将数据读出 I/O管理器将块重新组装成包，送线路卡 线路卡按线路要求将数据包作为净荷置入线路帧格式中，发出。 MPLS的基本组成和原理 Multi-Protocol Label Switching概念 MPLS是一个可以在多种第二层媒质上进行标记交换的网络技术。它结合了第二层的交换和第三层路由的特点，将第二层的基础社死和第三层的路由有机地结合起来。\nMPLS是一种有效的封装机制，通过在packets上使用标记Labels进行数据传递\n同时可以支持多协议，也就是它不仅可以支持多种上层网络协议，包括IPv4、IPv6等，而且可以运行于不同底层（ATM、FR、PPP）的网络上。\n基本模型 指一种结合分组路由和电路交换的混合模型\n使用固定长度的标记表示转发信息，使用精确匹配算法进行转发判决，故称标记交换 技术思路 传统路由协议选路 无连接变面向连接 增加标记分发协议 路由选择和数据转发分开进行\n采用精确地址匹配方法进行寻址\n技术特点 以路由判决为基础，先使用相关协议为信息流建立虚连接，分组按分配的标记为基础进行转发\n以分组头的某些定长字段标识这个虚连接\n标记都是本地（逐段）有效的\nMPLS的PDU允许变长\nMPLS可以使用多种2层完了过技术\n允许直接使用已有的路由技术\n标记置换：将 2 层的交换速度带到 3 层\n控制平面与转发平面分离：便于采用新的路由协议和交换技术\n通过标记堆栈实现多层次的转发：提高可扩展性\n与传统IP交换的区别\n传统 IP 交换采用逐跳转发，路由选择与数据转发同时进行，其核心交换机制是无连接工 作模式。 MPLS 将路由选择与数据转发分开进行，在信息传输之前需要建立虚连接，其核心交换 机制是面向连接的工作模式。 MPLS 网络组成 LSP\nLabel Switched Path 是指在某逻辑层次上（相应于标记堆栈）由多个LSR组成的交换式分组传输通路。 LSP来自于面向虚电路的思想，类似于ATM中的虚连接。 LER\nLabel Edge Router 入口边缘路由器，为每个 FEC 生成 Label，映射到 LSP 下一跳的标记。对入口 IP 分组进行分类，确定 FEC，根据 FEC 查询 LIB 得到下一跳 Label，将 Label 插入 IP 包头，从相应端口发送。 FEC\nForward Equivalence Class 是一组沿相同路径、有相同处理过程的数据分组。可以按照IP地址前缀划分等，有多种划分方式。 同一组FEC具有相同的Label，走相同的LSP LIB\nLabel Information Base 标记信息库，保存转发 Labeled 分组所需要的信息。 LSR\nLabel Switch Router，维护 LIB、完成标记置换。 Egress LER\n去掉 Label 还原成普通 IP 包继续转发。 MPLS 交换原理 MPLS 基本标记格式 Label 20bits 、COS/EXP=Class of Service 3bits、S=Bottom of stcack 1bit、TTL 8bits\n基本交换原理 建立连接\n通过LDP等协议，在LSR和LER、LSR和LSR之间完成标记信息的分发，形成与FEC对应的LSP路径 数据传输\n入口LER接收分组，完成第三层功能，判定分组所属的FEC，并给分组加上标记形成MPLS标记分组 LSR依据分组上的标记以及标记转发表通过交换单元对其进行转发，不再进行任何第三层处理 出口LER将分组中的标记去掉后转发至目的地 拆除连接\n取消标记，释放LSP 控制平面与数据平面 控制平面\n处理MPLS的信令和路由协议，负责LSP的建立、拆除、维护、重建等 FEC—LSP 标记分配协议LDP协议 数据平面\n规定如何利用标记进行数据传输 标记的格式和封装 标记分配过程（LDP） 标记分配方式 上游标记分配（一般不使用） 下游主动标记分配 下游按需标记分配（常用） 例子1 建立路由 标记请求 上游向下游请求标记 标记分配 下游告诉上游相关的FEC要使用哪个标签，并将上游的相应标签填入字节的In label中 上游将标签和端口号填入Out Label和out I'face中 之后可以进行分组转发\n5 信令 协议 信令工作过程： 信令的分类：\n按照信令完成的功能分类 线路信令\n具有监视功能，用来监视主、被叫的摘挂机，及设备忙闲\n路由信令\n具有选择功能，用来选择路由\n管理信令\n具有操作功能，用于电话网的管理和维护\n按照信令所工作的区域分类 用户信令：用户信令是用户和交换机之间的信令，在用户线上传送。\n模拟用户信令 1. 状态信令：用户线的忙闲状态，如主被叫的拽摘挂机状态 2. 地址信令：主叫所拨打的把欸叫号码， 3. 铃流和信号音：交换机向用户发送的信号。振铃信号、信号音\n局间信令：是交换机之间（市\u0026ndash;市、市\u0026ndash;长、长\u0026ndash;长）、交换机与网管中心、数据库（HLR、VLR）之间的信令。\n按照信令传送通路和用户信息传送通路的关系 随路信令 呼叫接续过程中的各种信令均在该呼叫所占用的话路中传送(或信令通路与话路存在对应关系)\n公共信道信令 信令通路与话音通路分开，且一条信令通路可以为多条话音通路服务\n信令传送速度快、信号容量大、可靠性高；\n不仅可以传送与电路接续有关的信号，还可以传送各种与电路接续无关的传令信息；\n具有改变或增加信令的灵活性，便于开放新业务；\nNo.7 信令系统 技术特点：\n采用公共信道方式 传送模式采用的是分组传送模式中的数据报方式，传送的最小单位是SU 由于话路与信令通道是分开的，所以必须对话路进行单独的导通检验 必须设置备用设备，保证可靠性 信令网组成 信令点SP和信令转节点STP\n信令链路\n连接各个信令点，传送信令的物理链路。通常就是通信链路的一部分。 我国的信令网的三级结构 第一级位高级信令转接点HSTP，负责转接它汇接的第二级LSTP和第三级SP的信令消息 第二级位低级信令转接点LSTP,负责转接它所汇接的第三级SP的信令消息。LSTP可以采用独立型信令转接设备；也可以采用与交换局合设在一起的综合式信令转接点设备。 第三级为信令点SP，它是信令网传递各种信令消息的源点或宿点，由各种交换局和特种服务中心，如业务控制点SCP、网管中心NMC等组成。 功能结构 由消息传递部分（MTP）和用户部分（UP）组成 画的时候只用画MTP 的三层以及一层总的UP\nMTP消息传递部分： 由信令数据链路功能（MTP1）、信令链路功能（MTP2）、信令网功能（MTP3）组成\nMTP1信令数据链路功能级： 对应OSI七层协议的物理层 用于传送信令业务的二进制比特流 全双工的方式工作 在数字的信令链路中，采用64kb/s、2Mb/s 在模拟的信令链路中，采用4.8kb/s的速率 占用时隙： 在数字环境下，信令数据链路采用64kbit/s的数字通路，通常对应于PCM传输系统中的一个时隙 MTP2信令链路功能： 功能概述\n与信令MTP1配合，共同保证在直联的两个信令点之间，提供可靠的传送信令消息的信令链路 信令单元定界定位 差错检测 差错校正 初始定位 信令链路差错率监视 流量控制 处理机故障控制 SU信令单元\n消息信令单元MSU\n运载高层(用户部分或信令网管理功能)产生的信令消息\n链路状态信令单元LSSU\n用来传送链路状态信息；\n插入信令单元FIISU\n在无MSU和LSSU可发时发送\nSU 基本格式 标识码 F\n表示信令单元的开始或结束\n长度表示语LI\n用于指示信令单元携带的净荷长度。从长度表示语之后，校验码之前的八位位组的数目，也就是字节数。 该字段有6比特组成，编码范围为0~63 LI=0 插入信令单元，不含有任何信息，只是为了同步 LI=1、2 链路信令单元，用来传递链路状态 LI\u0026gt;2 消息信令单元\n序号与表示语比特（BSN、BIB、FSN、FIB）\n每个信令单元都有一个前向序号FSN、后向序号BSN、前向指示语比特FIB、后向指示语BIB 前向序号FSN是发送侧的每个信令单元本身序号 后向序号BSN用来证实对端发来的信令单元序号\n业务信息8位码组SIO\nSIO又可以分为业务表示语SI和子业务字段SSF两部分 SI用于MTP3的信令消息处理功能完成消息分配，让MTP3知道要交给上层的哪个部分 SSF中的低两位备用，高两位作为网络表示语，用来知道是国内还是国际网\nCRC校验\n信令消息字段\n状态字段SF\n该字段包含于链路状态信令单元中，通过它 本端和信令链路对端交换链路状态信息包\nMTP3信令网功能： 网络管理功能 网络功能级结构 用SLC来标识链路\n信令点编码 消息发送路由选择示意 UP用户部分 电话用户部分TUP\nTUP主要规定了有关电话呼叫的建立和释放的信令程序及实现这些程序的消息和消息编码，并能支持部分用户补充业务\n信令连接控制部分SCCP\n为了满足新的用户部分对消息传递的进一步要求，CCITT补充了SCCP来弥补MTP在网络层功能的不足。SCCP提供了较强的路由和寻址功能，叠加在MTP上，与MTP中的第三级一起共同完成OSI中网络层的功能。 至于那些满足MTP服务的用户部分（如TUP），则可以不经SCCP直接与MTP第三级连接\nTCAP 事务处理\nISUP 综合业务数字网用户部分\nISDN用户部分是在TUP的基础上扩展而成的。ISUP提供总户业务数字网中的信令功能，用来支持基本的承载业务和附加的承载业务。 当ISUP传送与电路相关的信息时，只需要得到MTP的支持， 而在传送端到端的信令消息时，可依靠SCCP来支持。\nDUP 数据用户部分\n不用怎么管\n电话用户消息格式 DPC对端地址 OPC本端地址 CIC电路识别码来标识电路 SLS链路选择码 信令程序 驱动程序检测摘挂机，振铃 呼叫处理：号码分析，路由查找 信令模块：跟其他电话通信时需要一个信令模块送出去 信令模块收到之后，给呼叫处理模块进行来话分析，再发一个振铃 呼叫和信令时紧密相关的 呼叫处理和信令是松耦合的 TUP消息类型：\n前向地址消息FAM： IAM：初始地址消息 IAI：带附加信息的初始地址消息 SAM：后续地址消息 SAO：织带一位号码的后续地址消息 GSM：一般建立消息 后向建立消息BSM： GRQ：一般请求消息 成功的后向建立消息SBM： ACM：地址全消息，表示被叫空闲，呼叫建立成功 不成功后向建立消息UBM： CGC电路群拥塞 SEC交换机拥塞 SLB、STB 市话忙、长话忙 监视消息CCM： 正常呼叫结束时电路释放监护消息RLG 呼叫监视消息CSM： ANC被叫应答、计费消息 ANM应答、免费 CLF前向释放 CBK后向释放 CCL主叫挂机 信令消息传递\n信令消息直达 信令消息经STP转接 VoIp技术 Voice over Internet Protocol语音通话技术\nPC-PC\nIP网络内部的话音通信\n多媒体计算机经电话线或LAN连到ISP\n利用IP地址进行呼叫\n话音压缩、编解码、打包 都在PC上完成\nPC-Phone\n传统电话网与IP网络电话业务互通\nIP网关完成IP地址与电话号码的翻译及话音编解码和打包\nPhone-Phone\n普通电话经电话网连到IP电话网关，用电话号码呼叫\n传统电话网讲IP网络视为其业务承载网\n发端IP网关鉴别主叫用户，将被叫电话号码翻译成网关IP地址将呼叫连接到最靠近被叫的网关，完成话音编码和打包\n收端IP网关完成拆包、解码以及反向地址翻译，将呼叫连到被叫终端用户\nIP媒体网关——语音处理功能 语音信号的编解码功能 回音消除 静音压缩 信号因检测 输入缓冲 H.323 基本组件\n终端 H.323终端是提供实时、双向通信的结点设备 网关 提供基于分组网的H.323终端与其他电路交换网的终端类型之间的翻译转换功能 网守 地址翻译、带宽控制、接入许可控制和区域管理 多点控制单元MCU 用于支持三个以上节点设备间的会议 信令信道\nRAS信令信道 H.225呼叫信令信道：使用H.225.0消息建立两个H.323端点之间的呼叫连接 H.245媒体控制信道：传输端到端的控制消息以管理H.323实体的操作，包括主从判别、能力交换、打开和关闭逻辑信道、模式参数请求、流控消息和通用命令与指示 H.323基本呼叫建立方法 依次建立三种信道：RAS信道、呼叫信令信道、H.245媒体控制信道 MGCP H.323和SIP的网关同时具有控制功能和承载功能，既要进行信令的转换、也要进行媒体的转换。网关功能复杂\n为了降低复杂性，提高可靠性，将网关功能分离\n媒体网关MG只负责媒体格式的转换适配 媒体网关控制器MGC负责呼叫控制、接入控制、资源控制 媒体网关MG与媒体网关控制器MGC之间用标准的协议 MGCP网络结构 媒体网关 MG-Media Gateway 负责媒体变换以及PSTN和IP两侧通路连接 提供PSTN和IP网之间承载链路的联通 信令网关SGW-Signalling Gateway 负责信令的转换，处于网络边缘，它发送和接收电路交换网络的信令 呼叫代理 CA-Call Agent 根据收到的信令消息控制网关建立和释放连接 MGC是系统的总控制器，控制MG和SG MGCP呼叫模型\n端点\n物理端点\n虚拟端点\n连接\n一个端点上可以绑定多个连接\n一个连接建立之后，就可以在IP网上访问相应的端点\n呼叫是一组连接\n事件\n事件是在端点上发生的事情\n信号\n事件对应于与其相联系的信号。\nMGCP 消息\n类型 1. 命令 2. 响应 命令消息由命令行和若干参数行组成 响应消息中带有3位数字的响应码 MGCP采用UDP传送，有相应的重发机制 信令交互流程\n网关注册 控制驻地网关 MGCP协议单独负责用户终端接入的功能 MGCP协议不是一种呼叫发起协议，而是一种基于Master-Slave结构的网关控制协议，关注于MGC和MG之间的交互 控制中继媒体网关 SIP Session Initiation Protocol 会话发起协议\nSIP协议的基本特点 应用层协议，独立于较低层次的传输协议 基于文本的消息编码，使用UTF-8字符集，易于实现、调式方便，便于跟踪和手工操作 具有多个层次的可实现性，最小的实现非常简单。最完全的实现相对复杂，但能够完成非常多的功能 通过代理、重定向功能支持用户的移动性 易实现性 易扩展性 SIP系统中各种设备的作用 位置服务器\n配合代理服务器和重定向服务器提供可能的被叫用户的地址 重定向服务器\n允许SIP代理服务器将SIP会话邀请信息定向到外部域 SIP重定向服务器可以与SIP注册服务器和SIP代理服务器同在一个硬件上 注册服务器\n包含域中所有用户代理的位置的数据库。 在SIP通信中，这些服务器会检索参与方的IP地址和其他相关信息，并将其发送到SIP代理服务器。 代理服务器\n接收SIP UA的会话请求并查询SIP注册服务器，获取收件方UA的地址信息。 然后，将会话邀请转发给收件方UA（如果它位于同一域中）或代理服务器（UA在另一域中） 用户代理\nUA-终端用户设备，用于创建和管理SIP会话的移动电话、多媒体手持设备、PC、PDA等。 用户代理客户机发出消息，代理服务器对消息进行响应。 SIP消息 请求\n呼叫控制请求 INVITE 发起呼叫，并对会话进行描述 ACK 主叫确认收到被叫发送的对INVITE的确认响应 BYE 释放连接，可以由主叫方发出，也可以由被叫方发出 CANCEL 主叫取消呼叫，在连接建立起来之前发送 注册请求 REGISTER在注册服务器上注册用户代理 能力查询请求 OPTIONS 查询服务器的能 响应\n1xx：通知服务器或代理正在执行处理，终端应该等待响应 100：Trying 180：Ringing 2xx：请求成功 200：OK 3xx：重定向响应 4xx：请求失败，终端的请求被拒绝 5xx：服务器内部错误造成请求不能被响应 6xx：全局错误，所有未来对该用户的请求都将失败 消息体 SDP SIP协议头中的Content-Type字段可以定义为sdp类型的内容。\nSDP媒体协商的重点内容：媒体类型及编码、媒体地址与端口\nwebrtc两个客户端 / 浏览器进行 1 对 1 通话时，首先要进行信令交互，而交互的一个重要信息就是 SDP 的交换。 交换 SDP 的目的是为了让对方知道彼此具有哪些能力，然后根据双方各自的能力进行协 商，协商出大家认可的音视频编解码器、编解码器相关的参数（如音频通道数，采样率 等）、传输协议等信息。 举个例子，A 与 B 进行通讯，它们先各自在 SDP 中记录自己支持的音频参数、视频参数、 传输协议等信息，然后再将自己的 SDP 信息通过信令服务器发送给对方。当一方收到对端 传来的 SDP 信息后，它会将接收到的 SDP 与自己的 SDP 进行比较，并取出它们之间的交 集，这个交集就是它们协商的结果，也就是它们最终使用的音视频参数及传输协议了。 消息体主要是SDP会话描述协议\n用于描述这次会话的媒体信息\n话音流使用RTP/RTCP传输\nSDP的Header RTP\n用于Internet上针对多媒体数据流的传输协议 功能： 提供净荷类型指示 数据分组序号 数据发送时间戳 数据源标识 通常用UDP来传送数据 RTCP\n基本思想： 采用和数据分组同样的配送机制向RTP会话中的所有与会者周期性地传送控制分组，从而提供数据传送Qos的检测手段，并获知与会者的信息 功能： 提供数据传送质量的反馈信息 SIP基本消息流程 在相同的域呼叫过程\n注册流程 UA先发送REGISTER给代理\n代理服务器返回401，代表请求失败\n代理服务器返回200OK，表示注册成功 注销流程 基本呼叫建立过程 A发给代理服务器InviteB的消息 代理服务器解析，将InviteB消息发给B 代理服务器告诉A，它正在Trying B收到代理服务器的消息，返回Trying 然后B返回回铃音 代理服务器将回铃音转发给A B摘机，返回OK 代理服务器给A发OK A发送ACK给B，建立完成 正常呼叫释放过程 先挂机的收到OK，呼叫释放 被叫忙呼叫释放 被叫无应答流程 主叫主动取消 超时未回复 在不同的域呼叫过程 SIP消息与TUP对应转换 SIP网络域PSTN网络互通 UA发送INVITE，\n代理服务器收到请求，解析，并返回一个Trying\n代理服务器发现是PSTN网络的目的端，就发送初始地址消息IAM\n目的SPC收到IAM之后，返回ACM地址全消息，表示被叫空闲，呼叫建立成功，（相当于Ringing）\n在代理服务器收到ACM之后，给UA发回铃音\n在SPC同意邀请后，向代理服务器发送ANM，表示应答，免费。\n在代理服务器接收到ANM之后，给UA发送200 OK\nUA再返回一个ACK，这样通话建立完成\n6 移动通信系统 几个基本概念 入网\n入网是指移动用户设备UE首次连接到移动网络并进行注册的过程,目标是将设备注册到网络中。\n是用户设备首次或特定情况下的网络连接过程。\n过程：\n开机\n初始连接：设备选择一个基站进行连接，发送入网请求\n身份验证和注册：网络进行身份验证，验证通过后，网络将设备的信息注册到数据库中，并分配相关资源\n鉴权\n验证用户身份是否合法的过程，以确保用户是被授权使用网络服务的\n过程：\n鉴权请求：用户设备发送鉴权请求\n鉴权向量生成：网络侧生成鉴权向量，包括随机数（RAND）、预期响应（XRES）、加密密钥（Kc）等。\n响应验证：用户设备计算响应并发送给网络，网络将其发送给网络，网络将其与预期响应（XRES）进行比较\n鉴权结果：如果响应匹配，则鉴权通过，用户被允许访问网络\n切换\n切换是指用户设备在移动过程中，从一个基站切换到另一个基站的过程，以保持通信的连续性。\n过程：\n切换触发：当信号质量下降或用户移动到新的基站覆盖范围内时，触发切换。\n资源分配：目标基站分配必要的资源，准备接收用户设备。\n切换执行：用户设备切换到目标基站，释放源基站资源。\n切换确认：完成切换后，网络确认切换成功。\n漫游\n漫游是指用户设备在其主运营商网络覆盖范围之外，使用其他运营商网络的过程。\n一种是正在通话的客户从一个小区移向另一个小区 另一种是MS在两个小区覆盖重叠区进行通话，若当前占用的TCH所属小区业务特别忙，这时BSC通知MS测试其邻近小区的信号强度、信号质量，决定将它切换到另一个小区。这是业务平衡所需要的切换。 过程： 漫游协议：用户主运营商与其他运营商之间签订漫游协议。 位置更新：用户设备进入漫游区，向新的运营商网络发送位置更新请求。 鉴权与注册：新的运营商网络进行鉴权，并向用户主运营商确认用户身份。 服务提供：漫游网络为用户提供通信服务，费用由主运营商结算。\n位置更新\n位置更新是指用户设备在移动过程中，向网络报告其当前位置的过程\n网络附着\n网络附着是指用户设备在开机或重新连接到网络时，向网络注册并请求接入服务的过程。目标是让设备能够使用网络服务。\n是用户设备日常连接网络的过程，确保设备能够随时使用网络服务。\nGSM、GPRS的基本网络结构和网元功能 GSM移动通信 GSM网络结构 最左边为移动台子系统MS 红色的为无线基站子系统BSS 黄色的为操作维护子系统OSS 蓝色的为交换网络子系统OSS 棕色的为网关交换中心和PSTN网络 移动台子系统MS\n是移动客户设备部分，分手持机和车载台。 包括移动终端（ME）和手机客户识别卡（SIM） 无线基站子系统BSS\n由MSC控制，与MS进行通信的系统设备。 包括基站控制器BSC、基站收发信机BTS BTS基站收发信机的功能： 无线传输 完成无线与有线的转换 无线分集 无线信道加密 既然叫收发信机，那就是接收用户信号，并发出的，在网络结构中要与客户终端相邻 基站控制器BSC 是BTS和MSC之间的连接点，也为BTS和OMC（操作维护中心）之间交换信息提供接口 交换网络子系统NSS\n主要完成交换功能和客户数据与移动性管理、安全性管理所需的数据库功能。 包括 1. 移动交换中心MSC 2. 归属位置寄存器HLR 3. 访问位置寄存器VLR 4. 设备标识寄存器EIR 5. 鉴权中心 MSC移动交换中心\n蜂窝通信网络的核心，其主要功能是对位于本MSC控制区域内的移动用户进行通信控制和管理。 信道的管理和分配 呼叫的处理和控制 用户位置信息的登记与管理 越区切换和漫游的控制 用户号码和移动设备号码的登记和管理 服务类型的控制 对用户实施鉴权 为系统中连接别的MSC及为其它公用通信网络（PSTN、ISDN和PDN）提供链路接口，保证用户在转移或漫游的过程中实现无间隙的服务 和固定网络的交换设备功能相似，但又有特殊的要求功能\n归属位置寄存器HLR\n用来存储本地用户位置信息的数据库。在蜂窝通信网中，通常设置若干个HLR，每个用户都必须在某个HLR（相当于该用户的原籍）中登记。 登记了用户的永久性参数，以及暂时性的需要随时更新的参数，如用户所处位置 即使用户漫游到HLR所服务的区域外，HLR也要登记由该区传送来的位置信息 保证当呼叫一个移动用户时（不知它处于哪一个地区），均可由该移动用户的HLR获知它当前处于哪一个地区，进而建立起通信链路\n访问位置寄存器VLR\n存储来访用户位置信息的数据库。 一个VLR通常为一个MSC控制区服务，也可为几个相邻MSC控制区服务。\n当移动用户漫游到新的MSC控制区，向该地区的VLR申请登记 VLR从该用户的HLR查询有关参数，给该用户分配一个新的漫游号码，并让HLR修改该用户的位置信息 如果从一个VLR移动到另一个VLR时，HLR不仅要更改该用户信息，还要通知原来的VLR，删除之前的位置信息。\n鉴权中心AUC\n可靠地识别用户的身份，只允许有权用户接入网络并获得服务。\n设备标识寄存器EIR\n通过对用户的国际移动设备识别码IMEI（International Mobile Equipment Identification Number）的识别，对移动设备进行鉴别和监视，并拒绝非法移动台入网。\n短信息业务中心 SMS-SC\n操作和维护中心OMC\n任务是对全网进行监控和操作 系统的自检、报警 备用设备的激活 系统的故障诊断与处理 话务量的统计和计费数据的记录与传递 各种资料的收集、分析与显示等。 网关交换中心GMSC\n负责移动交换网络与固话网络（PSTN）的互联互通。需要进行呼叫接续控制（信令控制）和话音转发。 GSM 系统的信令过程 MS至PSTN用户呼叫建立过程\n1. MS要求系统分配信道，用户控制呼叫建立 2. BSC收到请求后，将分配的信道号，送回MS 3. MS在该信道上发呼叫信息，经BSS至MSC/VLR。之后，与建立呼叫有关的控制信息就在这个信道上传输 4. 若一切正常，MSC/VLR令BSC分配一个空闲的TCH给该MS，TCH号由BSC通过BTS送到MS，并且被激活，同时，MSC-BSC-BTS的链路建立 5. MSC/VLR将收到的被叫号码送到PSTN交换机，并建立至该交换机路由 PSTN用户至MS的呼叫建立过程 位置更新与鉴权\nMS从一个位置区移到另一个位置区时，必须进行登记，也就是说一旦MS发现其储存器中的位置区标识（LAI）与接收到的LAI发生了变化，便执行登记，这个过程就叫位置更新。 不同MSC业务区间的位置更新。 相同MSC不同位置区的位置更新 MS使用网络之前，网络检查其合法性的过程为鉴权 HLR/AUC中的位置更新和鉴权过程 切换\n同一BSC内小区间的切换 同一MSC内不同BSC小区间切换 越区切换 GPRS网络 网络结构 在GSM基础上进行了扩充，由GSM升级得到，网络结构基本保持不变，新增加了分组交换域。在BSS中的BSC之上增加了分组控制单元PCU，用以提供分组交换通道。在NSS中增加了与MSC和GMSC并列的用以提供分组交换服务的SGSN和GGSN，功能相对应。 不同业务会选择不同的交换技术，选用分组交换时，MS需要附着在GPRS网络中，由GGSN为其分配IP地址后，方可通过分组交换进行通信。 SGSN\nService GPRS Support Node 功能类似于GSM中的MSC/VLR 记录移动台的当前位置信息，对其进行鉴权、移动性管理和路由选择 在MS和GGSN之间完成移动分组数据的发送和接收 GGSN\n网关作用，功能类似GMSC，提供GPRS和多种不同的数据网络的互连 GGSN把GPRS分组数据包进行协议转换，从而可以把这些分组数据包传送到远端的TCP/IP或X.25网络 为MS动态分配IP地址,或接入DHCP服务器来实现动态分配IP地址 由于分组业务没有明显的呼叫建立释放过程，因此，其协议流程更多的参照IP网络。唯一比较特别的是信道管理和IP管理部分 GPRS信令过程 GPRS分组域数据通道 BSSGP BSS GPRS Protocol\n该协议用在SGSN与BSC之间 在SGSN和PCU之间提供虚电路，透明地在SGSN和PCU之间传输信号和数据 管理SGSN和PCU之间的包交换链路资源 GTP GPRS Tunnel Protocol\nSGSN与GGSN之间 采用隧道技术，允许多协议包在GPRS骨干网和GPRS支持节点GGSN 之间的传输 MS 的三种状态\nIDLE\n没有附着在GPRS网络上，不能接收、传输数据\nSTANDBY\n附着在GPRS网络上，可以接收GPRS的寻呼消息，但不能传输数据\nREADY\n可以进行数据传输\n了解手机从开机到可以进行数据传输的过程\n入网过程\n移动台发GPRS入网附着请求 网络鉴权 SGSN向HLR发位置更新请求 HLR将用户签约信息传送给SGSN SGSN接收GPRS MS的入网请求 移动台确认收到该消息 PDP上下文激活\nPDP上下文保存了用户面进行隧道转发的所有信息 激活过程用于激活IP协议，保证数据能以IP包的形式进行传送。使移动台与GGSN建立一条逻辑通路，进行数据传输。 MS向SGSN发送激活PDP上下文的请求 MS和SGSN进行安全性功能 SGSN向GGSN建立PDP上下文请求 GGSN向SGSN返回回应 SGSN向MS发送激活请求接受的信息 3G 了解3G网络结构演进过程\n3G UMTS协议中，组网架构为4层：终端（UE），基站（NodeB），无线网络控制器（RNC），核心网（CN）。RNC位置的网元在2G中称为基站控制器（BSC），RNC直接由Iur接口，不仅仅是基站控制器，还是无线接入网络的控制器。UMTS 4层网络架构如图所示 4G LTE/SAE的无线接入网叫eUTRAN（Evolved UMTS Terrestrial Radio Access Network，演进的通用陆地无线接入网络，3G叫UTRAN），网络架构如下图\neUTRAN和UTRAN比，去掉了RNC，减少了一层，减少了基站与核心网之间信息交互的多节点开销，更加扁平化。带来的好处是：\n（1）节点数量减小，用户面时延大大缩短 （2）简化了控制平面从睡眠状态到激活状态的过程，减少了状态迁移的时间 （3）降低系统复杂性，减少了接口类型，系统内部相应的交互操作也随之减少。 网络结构和网元功能 基本网元eNodeB\neNodeB的功能主要是由3G阶段的NodeB、RNC、SGSN、GGSN四个网元的部分功能演化而来。 MME Mobility Management Entity 移动管理实体\nMME属于控制面设备，负责信令传输； SGW 服务网关\n是EPC和eUTRAN的一个边界网关，不和其他系统网关如GGSN、PDG直接相连，主要功能是LTE系统内的分组数据路由及转发、合法监听、计费。 PGW 公共数据网关、PDN网关、分组数据网关\nSGW和PGW属于用户面设备，负责用户数据包的过滤、路由、转发。 和运营商外部或内部的分组网络连接的网关，功能类似UMTS或EDGE中的GGSN，是所有3GPP系统或者非3GPP系统非组网络的统一出口。 HSS Home Subscriber Server，归属签约用户服务器 交换方式——全IP 从单纯的电路交换向分组交换过渡，并最终演变为基于分组交换的全网络；\nLTE的核心网是Evolved Packet Core EPC EPC的演进表现在：\n取消了CS域（电路域），CS域业务承载在PS域，实现了核心网的IP化。语音业务（Voice）在以往无线制式中有CS承载，在LTE中则完全由PS域承载，即所谓的VoIP（Voice over IP）。 全网IP化，各网元节点之间的接口也都使用IP传输。LTE全网IP化的关键支撑就是端到端的QoS保障机制。\nLTE/SAE在核心网演进中实现了用户面和控制面的分离，即用户面和控制面功能分别由不同的网元实体完成。可降低系统时延，提升核心网处理效率。\n控制平面与用户平面 LTE空中接口协议栈 LTE协议栈的两个面： 用户面协议栈：用户数目传输 头压缩、加密、调度 控制面协议栈：系统信令传输 PDCP层完成加密和完整性保护 RRC层完成广播，寻呼，RRC连接管理... NAS层完成核心网承载管理，鉴权及安全控制 用户面（接入网+核心网全程）\n用户面基于IP，端到端（从UE到PGW），中间的eNodeB和SGW通过GTP隧道方式提供中继，eNB负责完成空中接口PDCP的数据包与GTP数据包的转换 控制面（接入网+核心网全程）\n控制面协议包括UE到MME的端到端的接续控制，MME与HSS之间关于用户当前信息查询的协议，MME与SGW和SGW与PGW之间关于媒体通道控制的协议 LTE中的数据传输过程 UE开机附着网络(Attach)\n先进行物理下行同步，搜索测量进行小区选择，选择到一个suitable或者acceptable小区后，驻留并进行附着过程。附着完成后，默认RRC承载建立成功，UE可获得PDN ddress信息\nUE发起的service request流程\nUE在IDLE模式下，需要发送业务数据时，发起service request过程。 完成Initial context setup，在S1接口上建立S1承载，在U u接口上建立数据无线承载，打通UE到EPC之间的路由，为后面的数据传输做好准备\n5G 网络架构特点 控制面和用户名分离 在5G核心网中，控制面与用户面的分离是一个重要的特征。控制面主要负责处理连接的建立和断开等任务，而用户面则专注于数据包的传输。这种分离架构不仅简化了网络管理，而且允许分别增强控制面和用户面的功能。更重要的是，用户面可以下沉到离用户更近的地方，从而大幅降低网络时延。\n5G网络架构主要由接入网、核心网和传输网三部分组成。接入网负责连接终端设备和基站，核心网负责处理网络逻辑，传输网则负责数据的传输和交换。\n网元 -\u0026gt; 微服务 在5G网络中，传统的单一网元（Network Element）架构逐渐被基于微服务的架构取代。微服务架构将网络功能分解为多个独立的服务，这些服务可以独立开发、部署和管理。\n微服务架构将网络功能分解为一系列独立的、可重复使用的小服务。每个微服务负责特定的功能，可以独立开发、测试、部署和扩展。这种架构更灵活、可扩展性更好，便于快速迭代和优化。\n关键技术 高频段高带宽传输\n毫米波通信实现极高速短距离通信 但是毫米波直线传输没定向性强，传输距离短，穿透和绕射能力差，容易受气候环境影响\n新型多天线传输\n手机中的毫米级多天线阵列与基站形成很多对的信道并行通信，每一对天线都独立传送一路信息，经汇集后可成倍提高速率 基站支持多用户波束智能赋型，减少用户间干扰 大规模MIMO：基站使用上百根天线，波束窄，指向性传输，高增益，抗干扰，提高频谱效率\n同时同频全双工\n多种多址接入方式\nDevice to Device\n短距离直接通信，信道质量高，D2D能够实现较高的数据速率、较低的时延和较低的功耗； 通过广泛分布的终端，能够改善覆盖，实现频谱资源的高效利用； 支持更灵活的网络架构和连接方法，提升链路灵活性和网络可靠性\n微基站构建密集完了过\n新型网络架构\n7 新一代交换控制技术 软交换 软交换的系统结构、四层结构 软交换既体现网络体系的概念，又是一个具体的设备\n它独立于传送网络，主要完成呼叫控制、资源分配、协议处理、路由、认证、计费等主要功能，同时可以向用户提供现有电路交换机所能提供的所有业务，并向第三方提供可编程能力。\n软交换技术特征 业务处理与呼叫控制相分离 呼叫控制与承载相分离 融合异构网络统一传输\n分层体系架构 业务驱动网络 基于分组交换 融合异构网络 四层体系结构，各层典型设备 软交换系统组成： SSC 软交换控制器：呼叫控制、资源管理、路由控制、地址解析/翻译 MG 中继媒体网关：连接PSTN与IP网络，实现媒体传输格式转换，主要用户中继接入 AG 接入网关：用于终端用户/PBX/无线基站的接入，完成媒体流转换和用户信令处理等功能 MS 媒体服务器：提供特殊媒体资源，提供IVR功能 SG 信令网关： 连接SS7和IP网络，实现SS7信令传输格式转换 IAD 综合接入设备：用于传统用户终端设备的接入，完成用户端数据、语音等接入 AS 应用服务器：提供也二五执行，管理，开发环境 NMC 系统管理中心：提供系统挂你了功能，连接运行支持系统 IMS IP Multimedia Subsystem IMS 特点 SIP——易与互联网互通 全SIP信令 借鉴移动网络“归属/拜访原理”、设置HSS——支持移动性 借鉴软交换控制承载分离思想、设置CSCF等实体——开放体系架构 Parlay/OSA——业务开放 呼叫控制与承载相分离 业务处理与呼叫控制相分离 IMS具有开放的体系结构，支持电路交换和分组交换网络上的一系列基于IP的业务，支持无线和固定的接入\nIMS 能做什么\n业务控制 呼叫控制 媒体控制 接入网关 3GPP IMS 网络架构 1）IMS最大限度地重用了互联网技术和协议 2）IMS继承了移动通信特有的网络技术 3）IMS充分借鉴了软交换网络技术 软交换与IMS技术的比较\n软交换与IMS是两种下一代网络交换技术。 软交换和IMS实现的目标一致：构建一个基于分组的、层次分明的、控制和承载分离的、开放的下一代交换网络。 软交换技术提出得比较早，对电话语音业务、IP接入、非IP接入以及与PSTN、VoIP互通等方面考虑较多，但对移动性管理、多媒体和增值业务的提供却考虑不多，故缺乏比较整体的标准。因此，目前的软交换只是下一代交换网络的初级阶段技术。 IMS是3GPP在R5版本核心网络结构上引入的一个多媒体子系统。其最初的出发点是为了在移动网上以最大的灵活性提供IP多媒体业务而设计的一个业务体系框架。后来，由于其良好的开放性和全分布式架构，能做到控制与业务分离、与接入无关和支持移动性管理，而得到了ETSI、ITU-T等NGN相关标准化组织的认可，并作为研究下一代网络的基础。 SDN 软件定义网络 SDN 网络概述 设计理念是将网络的控制平面与数据转发平面进行分离，并实现可编程化的集中控制。\n传统网络设备紧耦合的网络架构被分拆成应用、控制、转发三层分离的架构。\n控制功能被转移到了服务器，上层应用、底层转发设施被抽象成多个逻辑实体。\n本质和核心特点\n1. 控制和转发分离（设备开发者） 2. 集中化的网络控制NOS（网络运维者） 3. 开放的编程接口（应用提供者） SDN = 控制与转发分离 + 逻辑集中控制 + 网络资源能力状态开放\n架构示意图 控制转发分离：\n传统网络设备的CP（控制平面）与DP（转发平面）不分离，设备之间通过控制协议交互转发信息 SDN的思路是将网络设备的控制平面集中上收至Controller 网络设备上指保留转发平面 通过Controller实现网络统一部署和网络自动化 业务控制分离：\nSDN可编程接口不是传统的网络管理，而是一种在应用与网元之间双向的、紧密联系的通信通道，可以实现传统网络不具备的网络快速优化能力 应用开发人员使用控制器提供的API，实现网络自动化、网络编排和操作网络。 SDN的关键技术体系\n转发层关键技术\n对转发面进行抽象建模。OpenFlow 协议，在该协议中转发面设备被抽象为一个由多级流表Flow Table驱动的转发模型 转发面的行为就是根据转发表和报文头决定下一跳以及新的报文格式。 SDN控制器就是控制转发表，并把转发面模型和控制协议标准化\nSDN难想接口关键技术\nOpenFlow只是实现网络数据屏幕可编程的一种方式 其他各种用于南向接口的技术/协议也在不同程度上可以实现类似功能\nSDN控制层的关键技术\n关键是SDN控制器，也可以称为网络操作系统NOS或网络控制器 网络所有智能、核心均在SDN控制器中 由SDN控制器对转发面进行转发策略的调度和管理\nSDN北向接口关键技术\n将网络能力封装为开放的REST API，供上层业务调用\nSDN应用层关键技术\n利用开放的北向API，调用网络能力\nSDN 的特征\n集中控制 开放接口 网络虚拟化 SDN 南向接口 SDN南向接口的关键技术是转发面开放协议，该协议允许网络控制器控制交换机的配置以及相关转发行为。\nOpenflow是ONF定义的一个转发面控制协议，它将转发面抽象为一个由多级流表组成的转发模型，网络控制器通过Openflow协议下发Openflow流表到具体交换机，从而定义和控制交换机的具体行为。\nOpenFlow流表概述 OpenFlow的基本原理 流表（Flow Table）\n每个OpenFlow交换机都维护一个或多个流表，流表由多个流表项（flow entries）组成。每个流表项包括以下几个关键部分：\n匹配域（Match Fields）：定义流表项应用的条件，例如源IP地址、目标IP地址、源端口、目标端口、协议类型等。 优先级（Priority）：用于在多个匹配项之间进行选择。优先级越高，匹配时优先级越高。 指令（Instructions）：定义在匹配流表项后应该采取的动作，例如转发到特定端口、丢弃数据包、修改数据包头信息等。 计数器（Counters）：用于记录流表项的匹配次数、数据包数和字节数等信息。 时间信息：包括流表项的硬超时（Hard Timeout）和空闲超时（Idle Timeout），用于定义流表项的生存时间。 OpenFlow的工作流程\n数据包接收：\n交换机收到一个数据包，首先检查流表，尝试找到一个匹配项。\n流表匹配：\n交换机根据数据包头信息与流表项的匹配域进行比较，找到与数据包匹配的流表项。如果找到多个匹配项，则选择优先级最高的一个。\n执行指令：\n如果找到匹配的流表项，交换机按照该流表项的指令来处理数据包。例如，将数据包转发到指定端口、修改数据包头信息等。\n流表项不存在：\n如果没有匹配的流表项，交换机将数据包发送给控制器（通常称为Packet-In消息）。控制器根据自己的策略决定如何处理该数据包，例如：安装新的流表项、将数据包转发到特定端口、丢弃数据包等。\n控制器响应：\n控制器接收到Packet-In消息后，会基于全局网络视图和策略进行决策。它可以通过Packet-Out消息指示交换机如何处理该数据包，还可以通过Flow-Mod消息向交换机下发新的流表项，以便未来的类似数据包可以直接由交换机处理。\n流表项的老化：\n流表项可以有时间限制。硬超时（Hard Timeout）定义了流表项的生存时间，从流表项创建之时起计时；空闲超时（Idle Timeout）定义了流表项在没有匹配数据包的情况下的最大空闲时间。如果超时，流表项将被删除。\nOpenFlow控制器与交换机的交互\nOpenFlow控制器是SDN网络的“大脑”，负责全局网络状态的管理和策略的制定。它与交换机之间的交互主要通过以下几种消息类型实现：\nHello消息：用于交换机和控制器之间建立连接时的握手。 Error消息：用于报告错误。 Echo消息：用于维持连接的心跳检测。 Features消息：交换机向控制器报告其能力。 Flow-Mod消息：控制器向交换机下发流表项。 Packet-In消息：交换机向控制器报告未匹配的数据包。 Packet-Out消息：控制器指示交换机如何处理特定的数据包。 Stats消息：交换机向控制器报告流表项的统计信息。 OpenFlow 流表基本结构 整个OpenFlow协议架构由控制器（Controller）、OpenFlow交换机（OpenFlow Switch）、以及安全通道（Secure Channel）组成。控制器对网络进行集中控制，实现控制层的功能；OpenFlow交换机负责数据层的转发，与控制器之间通过安全通道进行消息交互，实现表项下发、状态上报等功能。\n流表是OpenFlow对网络设备的数据转发功能的抽象, 表项包括了网络中各个层次的网络配置信息 包头域：用于对交换机接收到的数据包的包头内容进行匹配 计数器：用于统计数据流量相关信息，可以针对交换机中的每张流表、每个数据流、每个设备端口、每个转发队列进行维护 动作（action）：用于指示交换机在收到匹配数据包后如何对其进行处理。决定了OpenFlow对转发面行为的抽象能力，OpenFlow交换机缺少控制平面的能力，因此需要用动作来详细说明交换机将要对数据包所做的处理 OpenFlow 流表动作 Openflow端口\n物理端口 逻辑端口 保留端口 OpenFlow定义了八种端口 OpenFlow交换机 OpenFlow 安全通道\nOpenFlow的集中控制架构对控制器与交换机之间信息传送通道提出了极高的要求 采用TLS（Transport Layer Security）技术 安全通道就是连接OpenFlow交换机与控制器的信道，负责在OpenFlow交换机和控制器之间建立安全链接。控制器通过这个通道来控制和管理交换机，同时接收来自交换机的反馈。 OpenFlow 协议主要交互过程\n建立连接 Switch registration\nOFPT_HELLO：协议协商，成功的话就建立连接 OFPT_ECHO：查询连接状态，确保通信通常。没有其他数据包交换时，Controller会定期循环给sw发送EFPT_ECHO_REQUEST\n获取交换机特性信息\nOFPT_FEATURES：当sw跟controller完成连接之后，控制器会向交换机下发OFPT_FEATURES_REQUEST的数据包，目的是请求交换机的信息。 在连接建立完成之后发送，目的是获取交换机的信息\n配置交换机\n通过SET_CONFIG消息来实现配置\nflags 用来只是交换机如何处理IP分片数据包 miss_send_len 用来指示当一个交换机无法处理的数据包到达时，发给控制器的数据包的最大字节数 网络topo检测\n通过LLDP数据包和广播包的混合使用来查询网络拓扑信息。\nPacket-in 事件\nOFPT_PACKET_IN\n当交换机收到一个数据包后，会查找流表，找出与数据包包头相匹配的条目。如果流表中有匹配条目，则交换机按照流表所指示的action列表处理数据包。如果流表中没有匹配条目，则交换机会将数据包封装在Packet‐in消息中发送给控制器处理。此时数据包会被缓存在交换机中等待处理。 交换机流表所指示的action列表中包含转发给控制器的动作(Output=CONTROLLER)。 控制器配置流表 Flow-Mod\n用来添加、删除、修改Openflow交换机的流表信息 一共五种类型\nADD类型的消息——添加一条新的流表项 DELETE类型消息——删除所有符合一定条件的流表项 DELETE‐STRICT类型消息——删除某一条指定的流表项 MODIFY类型——修改所有符合一定条件的流表项 MODIFY‐STRICT类型——修改某一条指定的流表项 交换机转发Packet-out\nOpenFlow流表与传统路由表的区别 匹配粒度: 流表: 可以基于多种字段（不仅限于目标地址）进行匹配，支持复杂的流量工程。 路由表: 基于目标网络地址进行匹配，主要解决路径选择问题。 控制方式: 流表: 由SDN控制器集中管理和下发，支持动态调整和编程。 路由表: 分布式协议生成，各路由器独立决策。 操作灵活性: 流表: 支持多种操作，如转发、丢弃、修改等，提供细粒度控制。 路由表: 主要用于选择下一跳和接口，操作相对单一。 适用场景: 流表: 适用于需要灵活控制和精细管理的SDN环境，如数据中心、企业网络等。 路由表: 适用于传统IP网络，广泛应用于互联网和广域网。 管理和监控: 流表: 通过SDN控制器统一管理，支持实时监控和动态调整。 路由表: 通过分布式协议和网管系统管理，监控手段相对分散。 SDN 北向接口 SDN的核心是实现网络的可编程控制，推动网络业务的创新，而北向接口恰恰是这一趋势的最关键推动力，通过北向接口，网络业务开发者能以软件编程的形式调用各种网络资源，同时上层的网络资源管理系统可以通过北向接口全局把控整个网络的资源状态，并对资源进行统一调度。\nSDN 技术应用 SDN 产业现状 SDN 研究方向 ","date":"2024-09-20T09:31:48+08:00","permalink":"https://ffirestorm.github.io/p/%E7%8E%B0%E4%BB%A3%E4%BA%A4%E6%8D%A2%E5%8E%9F%E7%90%86/","title":"现代交换原理"},{"content":"1 软件工程概述 软件定义 定义：软件是包括程序、数据及其相关文档的完整集合。\n程序和数据是构造软件的基础，文档是软件质量的保证，也是保证软件更新及生命周期长短的必需品。\n软件的特点：\n软件是一种逻辑实体，具有抽象性 软件开发过程中没有明显的制造过程，应理解为“创作” 不存在机械磨损和老化问题，但存在软件退化问题 软件的开发和运行受到计算机系统的约束和限制 软件的分类 根据软件服务对象范围不同分类\n通用软件：操作系统、数据库管理系统、IDE、CASE工具等； 定制软件：企业ERP、办公自动化系统等按照客户个性化要求实现的软件； 服务类软件：淘宝、京东、12306等等； 根据根据软件完成功能所处的层次不同：\n应用软件、中间件软件、系统软件\n系统软件 指能与硬件紧密配合在一起，使计算机系统各个部件、相关的软件和数据协调、高效地工作。 系统软件处于计算机系统的最底层，与计算机硬件紧密配合，使计算机系统各个部件、相关的软件和数据协调、高效地工作的软件，使计算机系统正常运行必不可少的组成部分 应用软件 应用软件是在特定领域内开发，为特定目的服务的一类软件，人们日常使用的软件大部分属于应用软件 中间件软件 中间件是位于操作系统和应用软件之间的通用服务，用来管理分布式计算资源和网络通信，这些服务具有标准的程序接口和协议 软件发展阶段 程序设计阶段：20世纪50至60年代\n这个阶段只有程序的概念，没有软件的概念 程序规模小，程序的开发者和使用者常是同一个个人，无须向其他人作任何的交代和解释 程序系统阶段：20世纪60至70年代\n计算机从单一的科学计算，扩展到数据处理、实时控制等方面，相继研制出了一批高级程序设计语言，使得该时期结构化程序设计称为主要的开发技术和手段，程序已不再是计算机硬件的附属成分，而是计算机系统中与硬件相互依存、共同发挥作用的不可缺少的部分 传统软件工程阶段：20世纪70至90年代\n软件的开发不再是“个体化”或“手工作坊”式的开发方式，而是以工程化的思想作指导，用工程化的原则、方法和标准来开发和维护软件，软件已经产品化、系列化、标准化、工程化 现代软件工程阶段： 20世纪90年代-21世纪20年代\n随着互联网技术的快速发展，软件开发技术也进入到敏捷时代。通过面向对象技术、软件复用技术（设计模式、软件框架、软件体系结构等）、构件设计技术、分布式计算技术、软件过程管理技术等的应用使得软件工程过程进入到以软件测试为导向的快速迭代和快速实现的节奏中，很大程度上提高了软件质量 软件工程3.0：AI 时代\n软件危机 1960年后至1970之间的软件快速发展阶段\n指由于落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。\n软件危机的解决途径\n1968年 软件工程大会第一次召开，并提出应用软件工程解决软件危机的问题 软件工程方法 1968年 Friedrich Ludwig Bauer （1924-2015） 提出运用工程化原则和方法，组织软件开发解决软件危机，并提出“软件工程 Software Engineering”的概念。 20世纪60年代后，随着计算机软件应用领域增多，软件规模不断扩大，软件系统功能多，逻辑复杂，不断扩充，从而导致许多系统开发出现了不良的后果和现象：\n软件开发计划难以制定和实施 软件开发费用和进度失控 软件的质量无法让用户满意 软件无法维护 软件没有适当的文档资料 产生软件危机的原因\n软件系统本身的复杂性 软件开发的方法和技术不合理及不成熟； 软件发展的三个阶段 软件工程 软件工程的定义 软件工程是为了克服软件危机而提出的一种概念，人们在实践中借鉴了工程学的某些原理、原则和方法，不断探索软件工程的原理、技术和方法，形成了一门新的学科：软件工程学\n1968年10月，F.L. Bauer首次提出了“软件工程”的概念：软件工程是为了经济地获得能够在实际机器上高效运行的可靠软件而建立和使用的一系列好的工程化原则。\nBarry Boehm（1935-2022）的软件工程定义：运用现代科学技术知识来设计并构造计算机程序及为开发、运行和维护这些程序所必需的相关文件资料。\nRichard E. Fairley 认为：软件工程学是为在成本限额以内按时完成开发和修改软件产品所需的系统生产和维护的技术和管理的学科。\nIEEE计算机学会将“软件工程”定义为：\n⑴ 应用系统化的、规范化的、定量的方法来开发、运行和维护软件，即：将工程应用到软件； ⑵ 对⑴中各种方法的研究。 软件工程的三要素 方法、工具和过程\n方法：提供了“如何做”的技术\n给出需求、设计建模、编码、测试的方法； 工具：提供了自动或半自动的软件支撑环境\n给出各种建模、编码和测试所需要的自动化或半自动化的工具 ； 过程：将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的\n给出指导各种软件类型开发所需要的过程模型； 软件工程的目标 现实目标：\n在一个特定项目中，在给定成本和时间的前提下，开发出满足用户需求且具有正确性、可用性等因素的软件产品。 终极目标：\n摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。 软件工程的研究内容 软件开发技术 软件工程管理 软件工程应用的原则 原则：\n选择合适的开发模型； 采用合适的设计建模方法； 提供高质量的工程支持力度； 重视开发过程的管理； 2 软件生命周期模型 软件过程模型：从一个特定角度提出的对软件过程的概括描述，是对软件开发实际过程的抽象，包括构成软件过程的:\n1、各种活动（Activities→How）； 2、软件工件（Artifacts→What）； 3、参与角色（Actors/Roles→Who）。 软件生命周期模型是一个框架，描述从软件需求定义直至软件经使用后废弃为止，跨越整个生存期的软件开发、运行和维护所实施的全部过程、活动和任务，同时描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。\n软件工程过程 工程项目的三个基本目标：\n合理的进度； 有限的经费； 一定的质量； 美国质量管理专家戴明博士针对工程项目的质量目标，提出了PDCA循环，称为戴明环 Plan, Do, Check, Action 软件工程过程是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动，包括下面四项对应于戴明环的PDCA思想活动。\n编写软件规格说明：规定软件的功能及其使用限制； 软件开发：产生满足规格说明的软件； 软件确认：通过有效性验证以保证软件能够满足客户的要求； 软件演进：为了满足客户的变更要求，软件必须在使用过程中进行不断地改进。 软件过程模型 从一个特定角度提出的对软件开发过程的简化描述或称之为框架描述，是对软件开发实际过程的抽象，它包括构成软件过程的各种活动、软件工件以及参与开发的角色等元素。\n软件生命周期 指软件产品从考虑其概念开始，直至废弃为止的整个时期，包括概念阶段、分析与设计阶段、构造阶段、移交和运行阶段等不同时期。\n软件生命周期的六个基本步骤\n制定计划\tP 需求分析\tD 设计\tD 程序编码\tD 测试\tC 运行维护\tA 制定计划 确定要开发软件系统的总目标； 给出功能、性能、可靠性以及接口等方面的要求； 完成该软件任务的可行性研究； 确定软件的过程模型及建模方法； 估计可利用的资源 (硬件，软件，人力等)、成本、效益、开发进度； 制定出完成开发任务的实施计划 任务列表 每个任务的起止时间 每个任务的责任人 责任人：项目负责人 需求分析 对用户提出的要求进行分析并给出详细的定义，确定软件的功能； 编写软件需求规格说明书或系统功能说明书及初步的系统用户手册； 提交管理机构评审； 责任人：软件开发人员（泛指）/需求分析人员（具体） 设计 概要设计：把各项需求转换成软件的功能结构。结构中每一组成部分都是意义明确的功能模块，每个功能都和某些需求相对应； 详细设计：对每个模块要完成的工作进行具体的描述，为源程序编写打下基础； 编写设计说明书，提交评审。 责任人：软件开发人员（泛指）/软件架构师、软件设计人员、DBA等（具体） 程序编码 把软件设计转换成计算机可以接受的程序代码，即写成以某一种特定程序设计语言表示的“源程序清单”； 写出的程序应当是结构良好、清晰易读的，且与设计相一致的； 责任人：软件开发人员（泛指）/编码工程师（具体） 测试 单元测试，查找各模块在功能和结构上存在的问题并加以纠正； 组装测试，将已测试过的模块按一定顺序组装起来； 按规定的各项需求，逐项进行一系列有效性测试，决定已开发的软件是否合格，能否交付用户使用； 责任人：软件测试人员、编码工程师、客户（具体） 运行维护 软件交付给用户后的软件开发活动 改正性维护：运行中发现了软件中的错误需要修正； 适应性维护：为了适应变化了的软件工作环境，需做适当变更； 完善性维护：为了增强软件的功能需做变更。 软件维护是更加复杂的软件开发活动 责任人：软件维护人员（泛指）、软件开发工程师（各种岗位） 传统软件生命周期模型 瀑布模型（Waterfall Model） 演化模型（Evolutional Model） 增量模型（Incremental Model） 喷泉模型（Fountain Model） V模型和W模型（V \u0026amp; W Model） 螺旋模型（Spiral Model） 构件组装模型（Component Assembly Model） 快速应用开发模型（Rapid Application Development Model） 原型方法（Prototype Method） 瀑布模型 Winston W. Royce 在1970年提出瀑布模型\n六个基本工程活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落 。\n系统需求 软件需求 分析 程序设计 编码 测试 运行 瀑布模型将软件生命周期划分为定义阶段、开发阶段和维护阶段\n在定义阶段部署了计划和需求分析活动； 在开发阶段部署了设计、编码和测试活动， 维护阶段部署了运行/维护活动。 它在软件开发早期为消除非结构化软件、降低软件复杂度、促进软件开发工程化方面起着显著的作用。\n瀑布模型的特点：\n本阶段的工作对象来自于上一阶段活动的输出，这些输出一般是代表上一阶段活动结束的里程碑式的文档。 根据本阶段的活动规程执行相应的任务。 产生本阶段活动相关产出—软件工件，作为下一阶段活动的输入。 对本阶段活动执行情况进行评审。 但是需求很难调研充分，所以很难一次性开发成功。 演化模型 ps: 有点小作坊的味道 第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求； 第二次在此基础上获得较为满意的软件产品。 演化模型的特点：\n优点： 明确用户需求、提高系统质量、降低开发风险； 缺点： 难于管理、结构较差、技术不成熟； 可能会抛弃瀑布模型的文档控制优点； 可能会导致最后的软件系统的系统结构较差 ； 演化模型使用范围：\n需求不清楚； 小型或中小型系统； 开发周期短 增量模型 Mills等人于1980年提出 ，指 首先对系统最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中。 再按优先级逐步对后续的需求进行上述工作， 逐步建设成一个完整系统的开发方法。 结合了瀑布模型和演化模型的优点。 从最核心的需求入手，先写出系统，再一步一步添加。体会“增量”的意思\n增量模型的优点：\n客户可以在第一次增量后就使用到系统的核心功能，增强了客户使用系统的信心； 项目总体失败的风险较低，因为核心功能先开发出来，即使某一次增量失败，核心功能的产品客户仍然可以使用。 由于增量是按照从高到低的优先级确定的，最高优先级的功能得到最多次的测试，保障了系统重要功能部分的可靠性。 所有增量都是在同一个体系结构指导下进行集成的，提高了系统的稳定性和可维护性。 增量模型的缺点：\n增量粒度难以选择； 确定所有的需求比较困难 ； 迭代模型/喷泉模型 喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠和多次反复的，就象喷泉一样，水喷上去又可以落下来，既可以落在中间，又可以落到底部。\n各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求。\n优点：\n提高开发效率 缩短开发周期 缺点\n难于管理，工作计划要随时更新 V模型和W模型 V模型：\nPaul Rook 在1980年代提出的，是瀑布模型的变种 将测试活动提前，使得瀑布模型能够驾驭风险 V模型将测试分等级，并和前面的开发阶段对应起来 V模型的优缺点（测试重点）\n优点： 包含了底层测试（单元测试）和高层测试（系统测试）； 清楚的标识了开发和测试的各个阶段； 自上而下逐步求精，每个阶段分工明确，便于整体项目的把控。 缺点 自上而下的顺序导致了，测试工作在编码之后，就导致错误不能及时的进行修改； 实际工作中，需求经常变化，导致v模型步骤，反复执行，返工量很大，灵活度较低。 在V模型中，只是把测试作为编码之后的一个阶段，并没有在需求开发阶段就进入测试。这也算是他的一个缺点了。 改良：每个步骤都可以进行小的迭代工作。 W模型：\nEvolutif公司在V模型的基础上提出了W模型。 W模型增加了软件各开发阶段中应同步进行的验证和确认活动\nW模型由两个V字型模型组成，分别代表测试与开发过程，图中明确表示出了测试与开发的并行关系。\nW模型特点：\n测试的对象不仅是程序，需求、设计等同样要测试，测试与开发是同步进行的 优点\n测试伴随着整个开发周期，需求和设计同样要测试； 更早的介入测试，可以发现初期的缺陷，修复成本低； 分阶段工作，方便项目整体管理。 缺点\n开发和测试依然是线性的关系，需求的变更和调整，依然不方便； 如果没有文档，根本无法执行w模型； 对于项目组成员的技术要求更高！ 螺旋模型 主要针对大型软件项目\n四个象限\n制定计划 风险分析 需求不清晰的风险，需要开发一个原型来逐步明确需求； 可靠性要求较高的风险需要开发一个原型来试验技术方案能否达到可靠性要求； 对于时间性能要求较高的风险需要开发一个原型来试验算法性能能否达到时间要求等。 风险管理措施应该纳入选定的项目实施方案中。 实施工程 针对每一个开发阶段的任务要求参照某一种生命周期模型执行本开发阶段的活动。 客户评价 根据客户的反馈，决定是否要进行下一步的迭代 构建组件模型 利用模块化思想将整个系统模块化， 并在一定构件模型的支持下复用构件库中软件构件， 通过组装高效率、高质量地构造软件系统。 构件组装模型本质上是演化的，开发过程是迭代的 。\n开发过程就是构建的组装过程，维护和升级过程就是构建的更新替换过程\n优点： 充分利用软件复用，提高了软件开发的效率。 允许多个项目同时开发，降低了费用，提高了可维护性，可实现分步提交软件产品。 缺点： 缺乏通用的构件组装结构标准，风险较大； 构件可重用性和系统高效性之间不易协调； 由于过分依赖于构件，构件质量影响着最终产品的质量。 快速应用开发模型 RAD 使用构件组装方法进行快速开发。\n是一个增量型的软件开发过程模型，强调极短的开发周期\n缺点 并非所有应用都适合采用RAD 由于时间约束，开发人员和客户必须在较短的时间内完成一系列的需求分析，沟通配合不当都会导致应用RAD模型的失败 RAD适合于管理信息系统的开发，对于其他类型的应用系统，如技术风险较高、与外围系统的互操作性较高等，不太合适 新型软件生命周期模型 UP模型 UP是一个二维可视化的软件开发模型。 横轴在时间上将什么鬼周期过程展开成四个阶段，每个阶段特有的里程碑是该阶段结束的标志。从第二个阶段开始又划分为多次的迭代，体现了软件开发过程的动态灵活性； 纵轴按照活动的内容进行组织，包括活动、活动产出的工件、活动的执行角色以及活动执行的工作流，体现软件开发过程中每次迭代做必须执行活动的静态结构\nUP模型的特点就是突出表明软件开发活动中的每一项活动不是一次性能完成的。下图曲线展示了每一项活动在不同阶段的工作量的动态分配；而且说明了每一项活动在不同阶段与其他活动之间的关系，也展示了每一个迭代所必须执行的活动。UP的特点可以用三段话来概述：用例为驱动，以架构为核心的迭代增量式开发模型。通过多次迭代将瀑布一个完整的开发过程分解成多个小的瀑布过程，其优点正好解决了瀑布模型开发周期太长的问题，并且在短时间内可以给客户和用户呈现系统的结构以及对需求理解是否正确。\n敏捷建模 为了解决多变的用户需求以及能够快速迭代和交付软件，一些软件工程咨询性质的组织结合在一起，对现存的一些基于变更的软件开发方法进行分类，并将其共性归纳出来取名敏捷，并正式成立了敏捷联盟，并共同起草了敏捷宣言\nWe are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value: Individuals and interactions over processes and tools 个人和交互 胜过流程和工具 Working software over comprehensive documentation 工作软件胜过全面的文档 Customer collaboration over contract negotiation 客户协作胜过合同谈判 Responding to change over following a plan 响应变化胜过遵循计划 That is, while there is value in the items on the right, we value the items on the left more. 极限编程 作为敏捷思想的核心代表，Kent Beck 在为Daimler Chrysler 所做的一个项目中引入了新的软件开发方法：极限编程XP\n极限编程的特点\n一种轻量级的软件开发方法，以实践为基础的软件工程过程和思想。 它使用快速的反馈，大量而迅速的交流，通过及时和大量的测试来最大限度的保证和满足用户的需求 强调用户满意，开发人员可以对需求的变化做出快速的反应 任务代码质量的重要程度超出其他所有的内容 强调团队合作，除了开发人员还特别将用户置于开发团队之内，他们之间的关系不是对立的，而是互相协作的，具有共同的目标：提交正确的软件。 最上层工作流程 用户故事\n用户故事由客户编写，是站在用户角度描述具体的期望需求。它不局限于只描述用户界面，还推动了验收测试的创建。开发过程中，团队必须创建一个或多个自动接受测试，以验证产品是否正确实施了用户案例。 用户故事不宜过大。每个故事的“理想开发时间”分别为1、2或3周，理想的开发时间是在团队没有正在进行的其他任务，没有干扰，并且有明确计划的情况下用代码实现用户故事所需的时间。\nSpike 方案架构\n当团队开发过程中遇到棘手的技术或者技术问题的时候，需要创建一个spike解决方案。\nspike解决方案是一个非常简单的程序，通过构建峰值来解决正在检查的问题。因此团队往往将它用于探索潜在的解决方案，以降低技术问题的风险或增加用户故事估算的可靠性。\n发布计划\n该计划对整个项目进行总体布局，再为每个迭代周期创建迭代计划，其实质是让开发团队根据理想的编程周来评估每个用户故事 发布计划的基本原理是，一个项目可以通过四个变量来量化。范围、资源、时间和质量：范围是要完成的工作量；资源是多少有空的人；时间是项目或发布完成的时间；质量是软件的质量以及测试的质量。没有人可以控制所有4个变量，当一个变量改变时，其他三个都会随之变化。因此，发布计划会议中最重要的是，客户、经理、开发团队需要协商出一个可接受的发布计划，然后在执行计划中合理地控制变量以达到理想效果。\n迭代开发\n极限编程将复杂的开发过程分解成一个个小的开发周期，对需求分析、设计、编码、测试进行反复迭代。每个迭代周期为1到3周，在每次迭代开始都召开一次迭代会议，计划要完成的工作，及时调整工作规划。 在每个开发周期中，通过客户、业务人员和开发人员的交流、反馈能够清楚地发现软件开发过程中现存的问题并进行及时调整。另外，极限编程还要求将每次迭代看作最后一次迭代，团队中每个人都要时刻为按时交付产品做好准备。\n验收测试\n在迭代过程中，迭代计划会议期间选择的用户案例将转换为验收测试。该客户指定测试场景，以验证用户故事是否被正确执行。 每个验收测试代表系统的预期结果。客户负责验证验收测试的正确性，并检查测试分数，以确定哪些失败的测试需要优先进行调整。在最终产品发布之前，验收测试还用作回归测试。 此外，每个迭代中都要创建验收测试，只有通过了验收测试才能进行迭代的交付，否则进度依然为零。\n频繁发布小版本\n迭代流程示意图 Release Plan（发布计划）：\n在开始时，根据用户故事（User Stories）制定一个发布计划。这些用户故事描述了系统需要实现的功能和特性。\nIteration Planning（迭代规划）：\n迭代规划会考虑项目的进度（Project Velocity），用户故事以及之前迭代中未完成的任务（Unfinished Tasks），还有未通过的验收测试（Failed Acceptance Tests）和发现的缺陷（Bugs）。\n制定一个迭代计划（Iteration Plan），确定在接下来的迭代中需要完成的工作。\nDevelopment（开发）：\n开发阶段是迭代的核心，团队每天进行开发工作，包括实现新功能（New Functionality）和修复缺陷（Bug Fixes）。\n在这个过程中，团队成员会不断学习和交流（Learn and Communicate）以提高开发效率和代码质量。\nLatest Version（最新版本）：\n每天的开发结果会集成到系统的最新版本中，确保系统始终处于可运行状态。 最新版本中包含了新功能和已修复的缺陷。\nNext Iteration（下一次迭代）：\n每次迭代结束后，项目团队会评估迭代成果，并将未完成的任务、未通过的验收测试和发现的缺陷带入到下一次迭代中。 基于项目进度和新的用户故事，重新规划下一次迭代的工作内容。\nBugs（缺陷）：\n在整个迭代过程中，发现的缺陷会记录下来并进行修复。 缺陷修复是日常开发工作的一部分，确保系统的质量不断提升。\n开发流程示意图 Iteration Plan（迭代计划）：\n从迭代计划中分配任务，这些任务可能包括新的功能开发和修复缺陷。\nStand Up Meeting（站立会议）：\n每天的站立会议（Daily Standup）讨论当前任务的进展、存在的障碍以及下一步的计划。 会议还会讨论未完成的任务（Unfinished Tasks）和未通过的验收测试（Failed Acceptance Tests）。\nCollective Code Ownership（集体代码所有权）：\n团队中的所有成员对代码拥有共同的责任，任何人都可以修改任何代码。 集体代码所有权有助于提高代码的质量和一致性，同时避免单点故障。\nLearn and Communicate（学习和沟通）：\n团队成员通过结对编程（Pair Programming）、重构（Refactor Mercilessly）、移动人员（Move People Around）和使用CRC卡片（CRC Cards）来学习和交流。 CRC卡片（Class-Responsibility-Collaborator Cards）用于设计和讨论系统的类和职责。\nNew Functionality（新功能）：\n在开发过程中实现新功能，确保通过100%的单元测试（100% Unit Tests Passed）和验收测试（Acceptance Test Passed）。\nBug Fixes（缺陷修复）：\n在开发过程中持续进行缺陷修复，确保系统的稳定性和可靠性。\n设计、编码及测试流程示意图 Next Task or Failed Acceptance Test（下一个任务或未通过的验收测试）：\n团队成员根据任务列表或未通过的验收测试选择下一个任务。\nPair Up（结对编程）：\n团队成员进行结对编程，共同编写代码，提高代码质量和知识共享。\nCreate a Unit Test（创建单元测试）：\n为每个新功能或修复创建相应的单元测试，确保功能实现符合预期。\nPass/Fail Unit Test（通过/未通过单元测试）：\n运行单元测试，确保代码正确性。 如果单元测试失败，则继续调试和修复，直到通过测试。\nContinuous Integration（持续集成）：\n持续将代码集成到主代码库中，运行所有单元测试和验收测试，确保系统的稳定性。 通过持续集成发现和修复集成问题，减少集成风险。\nRefactor Mercilessly（无情重构）：\n持续对代码进行重构，优化代码结构，提高代码的可维护性。\nMove People Around（人员轮换）：\n定期轮换团队成员，增加团队的灵活性和知识共享，避免知识孤岛。\nCRC Cards（CRC卡片）：\n使用CRC卡片进行简单设计和讨论复杂问题，有助于明确系统的类和职责。\n3 软件需求分析 需求的定义 IEEE定义 用户解决问题或达到目标所需要的条件或权能 系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或权能。 一种反应上面（1）或（2）所描述的条件或权能的文档说明 通俗的定义 软件开发人员通过与软件产品的拥有者和使用者的交流和调研获取相关的业务职能、业务知识和业务流程等信息，并对这些信息进行分析和整理后形成的有关该软件产品必须提供的功能和性能等指标的规格描述。\n软件需求分析的任务和目标 任务 研究一种无二义性的表达工具，它能为用户和软件人员双方都接受，并能够把“需求”严格地、形式地表达出来。\n通俗：确定系统的目标，回答系统必须“做什么”的问题并编制需求规格说明书\n目标 就是借助于（业务）系统的逻辑模型导出目标系统的逻辑模型，解决目标系统的“做什么”的问题 软件需求分析建模的原则 数据、功能、行为建模\n问题的信息域必须被表示和理解 软件将完成的功能必须被定义 软件的行为（作为外部事件的结果）必须被表示 软件需求工程 软件需求的获取 需求获取是在问题及其最终解决方案之间架设桥梁的第一步。其目的是清楚地理解所要解决的问题，完整的获得用户的需求，并提出这些需求实现条件，以及需求应达到的标准。获取需求的一个必不可少的结果是对项目中描述的用户需求的普遍理解，进而探索出描述这些需求的多种解决方案\n软件需求的管理 需求管理的目的是在客户与软件开发方之间建立对需求的共同理解，维护需求与其他工作成果的一致性，并控制需求的变更。需求管理过程有3个主要活动：\n需求确认：指软件开发方和客户或用户共同对需求文档进行评审，双方对需求达成共识后作出书面承诺，使需求文档具有商业合同效果。 需求跟踪：指通过比较需求文档与后续工作成果之间的对应关系，建立与维护“需求跟踪矩阵”，确保软件产品依据需求文档进行开发 需求变更控制：指依据“变更申请-审批-更改-重新确认”的流程处理软件需求的变更，防止需求变更失去控制而导致项目发生混乱。 软件需求的类别 功能需求：列举出所开发软件在功能上应做什么 性能需求：给出所开发软件的技术性能指标，尤其是系统的实时性和其他时间要求，如响应时间、处理时间、消息传送时间等；资源配置要求，精确度，数据处理量等要求 其它需求：包括环境需求、可靠性需求、安全保密需求、用户界面需求、资源使用需求、软件成本及开发进度需求等 需求分析说明书类别 用户需求说明书 需求分析员对收集到的所有需求信息进行整理和分析，消除错误，归纳与总结共性的用户需求，按照指定的文档模板撰写《用户需求说明书》，调查过程中获取的需求信息可以作为《用户需求说明书》的附件。《用户需求说明书》撰写完毕之后，需求分析员应当邀请同行专家和用户（包括客户和最终用户）一起评审《用户需求说明书》，尽最大努力使《用户需求说明书》能够正确无误地反映用户的真实意愿。\n软件需求规格说明书 软件开发人员需从《用户需求说明书》出发，对比较复杂的用户需求进行建模分析，以帮助软件开发人员更好地理解需求，进而逐步细化所有的软件功能，找出系统各元素之间的联系、接口特性和设计上的限制，分析它们是否满足功能要求，是否合理。依据功能需求，性能需求，运行环境需求等，剔除不合理的部分，增加其需要部分。最终综合成系统的解决方案，给出目标系统的逻辑模型。\n软件需求的确认和评审 需求确认是指开发方和客户方共同对需求文档如《用户需求说明书》和《软件需求规格说明书》进行评审，双方对需求达成共识后作出承诺。\n4 面向对象分析 OO建模的发展历程 OOA/OOD 方法：1991年由P.Coad 和 E.Yourdon Booch 方法：1986年由Grady Booch OMT方法：1991年J.Rambaugh OOSE方法：I.Jacobson\nUML建模语言 统一建模语言 UML 是由Grady Booch、Ivar Jacobson 和 James Rumbaugh 发起，在Booch方法、OOSE方法和OMT方法基础上，广泛征求意见，集众家之长，几经修改而形成的一个面向对象分析与设计建模语言。这种建模语言得到了工业界的广泛支持，由OMG组织采纳作为面向对象建模的行业标准，成为软件行业第一个统一的建模语言。\nUML发展历史 1996年由Booch、Rambaugh、jacobson发起形成第一个版本UML0.9\n1997年9月被OMG组织认可，并发布UML1.1\n目前OMG组织发布的最新版本是2017年的UML2.5.1\nUML定义 UML是一种标准的图形化建模语言，它是面向对象分析与设计的一种标准表示。\n它不是一种可视化的程序设计语言，而是一种可视化的建模语言；\n不是工具或知识库的规格说明，而是一种建模语言规格说明，是一种表示的标准；\n不是过程，也不是方法，但允许任何一种过程和方法使用它。\nUML基本结构 UML 语法定义了UML的概念、元素、符合表示法以及用法，为开发者或开发工具使用这些图形符号和文本语法进行建模提供了标准和规范。\n基本构造块：Thing, Relationship, Diagram\nStructural thing：Class，interface，collaboration，use case，component，node Behavior thing：Interaction，state machine Group thing：package Annotation thing：note Relationship：Dependency，Association，Generalization，Realization 语义规则：name、scope、cisibility、integrity、execution\n通用机制：specification、adornment、common division、extensibility mechanism\n4+1视图 UML是用来描述模型的，通过模型来描述系统的结构（或静态特征）以及行为（或动态特征）。它从不同的视角为系统的架构建模，以用例视图为核心描述系统的不同视图（view），称为4+1视图，如图所示 逻辑视图、组件视图、进程视图、部署视图、用例视图 用例视图\n强调从用户的角度看到的或需要的系统功能 逻辑视图\n展现系统的静态或结构组成及特征 进程视图\n描述设计的并发和同步等特性，关注系统非功能性需求 组件视图\n关注软件代码的静态组织与管理 部署视图\n描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等） 领域模型 活动图 活动图的起点用来描述活动图的开始状态，用黑的实心圆表示。 活动图的中止点描述活动图的终止状态，用一个含有实心圆的空心圆表示。 活动图中的活动既可以是手动执行的任务，也可以是自动执行的任务。 活动图的组成 动作状态\n原子性的动作或操作的执行状态，它不能被外部事件的转换中断 动作状态使用平滑的圆角矩形表示，动作状态表示的动作写在矩形内部 活动状态 活动状态可以分解成其他子活动状态或动作状态，可以被使转换离开状态的时间从外部中断。 活动状态可以有内部转换，可以有入口动作和出口动作。活动状态具有至少一个输出完成转换，当状态中的活动完成时该转换被激发。 活动状态和动作状态的表示图标相同，都是平滑的圆角矩形。不同的是，活动状态可以在图标中给出入口动作和出口动作等信息，如下图： 组合活动\n可以在活动中被中断 分叉与结合\n分叉表示将一个控制流分成两个或多个并发运行的分支，结合用来表示并行分支在此得到汇合 分叉具有一个输入转换，两个或多个输出转换，每个转换都可以是独立的控制流，如下图： 结合与分叉相反，结合具有两个或多个输入转换，只有一个输出转换。先完成的控制流需要在此等待，只有当所有的控制流都到达结合点时，控制才能继续进行，如下图： 分支与合并\n泳道\n对象流\nUML类图 每个类有三层：\n类名 成员变量 类方法 修饰符有四种——对应java的四种保护类型\n“+”表示 public； “-”表示 private； “#”表示 protected； 不带符号表示 default。 抽象类的类名以及抽象方法用斜体表示\n接口\n接口在类图中也是用矩形框表示，但是与类的表示法不同的是， 接口在类图中的第一层顶端用构造型 \u0026lt;\u0026lt;interface\u0026gt;\u0026gt;表示， 下面是接口的名字， 第二层是方法。 此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现。 包 类图中表示关系 由弱到强的排序：依赖关系、关联关系、聚合关系、组合关系、继承关系\n实现关系\n实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口 在Java代码中，实现关系可以直接翻译为关键字 implements 就是某个类实现了某个接口\n泛化关系\n指对象与对象之间的继承关系\n如果对象A和对象B之间的“is a”关系成立，那么二者之间就存在继承关系，对象B是父对象，对象A是子对象\nA is a B : B 是父类，A是子类\n泛化关系用空心三角和实线组成的箭头表示，从子类指向父类 关联关系\n它使一个对象知道另一个对象的属性和方法\n双向关联关系用带双箭头的实线或者无箭头的实线双线表示\n单向关联用一个带箭头的实线表示，箭头指向被关联的对象。\n数字：精确的数量\n或者0..：表示0到多个\n0..1：表示0或者1个，在Java中经常用一个空引用来实现\n1..*：表示1到多个\n依赖关系\n是一种弱关联关系。\n如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。 B为A的构造器或方法中的局部变量、方法或构造器的参数、方法的返回值，或者A调用B的静态方法。\n如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。\n聚合是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系。 此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。 例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。\nA has a B : A -\u0026gt; B 聚合关系两端的生命周期是不一样的\n组合关系\n组合关系的两端生命周期是一样的\nA contains a B ： A -\u0026gt; B\n如果A组合B，则A需要知道B的生存周期，即可能A负责生成或者释放B，或者A通过某种途径知道B的生成和释放。\n例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。\n用例模型 用例图 用例图由三个基本元素组成\nActor：称为角色或者参与者，表示使用系统的对象，代表角色的不一定是人，也可以是组织、系统或设备 Use_case：称为用例，描述角色如何使用系统功能实现需求目标的一组成功场景和一系列失败场景的集合（1. 如何使用系统功能实现需求目标 2. 成功场景和失败场景的集合） Association：表示角色与用例之间的关系，以及用例和子用例之间的关系 用例比传统需求分析的功能性列表更有效，原因如下：\n用例将系统的特性和功能放到面向用户目标的语境中去考虑，从而能使识别出来的功能是真正为用户提供价值的功能 用例描述功能的方式是让用户写出多种使用系统的场景，和用户日常工作序列一致，使得交流更简单有效 包含子用例\n在ATM的取款、查询余额、更改密码的操作场景中，经分析都存在一段验证银行卡有效性及身份验证的场景，而且都是基本用例必须执行的操作，为此可以将其抽取出来作为基本用例的包含子用例。 扩展子用例\n在取款和查询余额的操作场景中，存在一段是否打印操作凭据的情景，经分析该功能可以成为一个子用例，且符合在某种条件下可以执行的用例，为此该子用例应为基本用例的扩展子用例。 用例说明 基于已经找到的用例和子用例，并参考之前的需求定义以及场景描述的内容，将用例交互的成功场景和失败场景以标准的格式归纳描述。 例子 SSD图 系统顺序图 操作契约 1 2 3 4 5 6 7 8 Operation： Name Cross Reference：此操作所属用例的名字 Precondition：在执行此操作前领域模型的对象的状态 Postcondition：对象状态的变化 Postcondition中可以写： (1)实例的创建活消除； (2)关联的形成活消除； (3)属性的修改； 结构化需求分析方法（老师的知识点总结没有，不看了） 结构化分析由来 结构化设计 的目的是需要一种图形符号体系来表示数据和对数据进行变换的处理，这些处理最终能被映射到软件体系结构的设计中\n分析模型的结构 需求分析的分析模型必须达到三个主要目标\n描述客户的需求 建立创建软件设计的基础 定义在软件完成后可以被确认的一组需求 结构化分析模型的组成\n数据流图：描述功能模型 ER图、数据词典：描述数据模型 状态迁移图：描述行为模型 数据建模 概念性数据模型是一种面向问题的数据模型，是按照用户的观点来对数据和信息的建模，其表示方法称为ER法，也称实体关系模型。\n描述了从用户角度看到的数据，反应了用户的现实环境，但与软件系统中的实现方法无关。\n软件系统本质上是信息处理系统，因此在开发过程中必须考虑\n数据\n需要什么？数据之间的联系？本身的性质？数据结构\u0026hellip;\n对数据处理\n进行哪些处理？每个处理的逻辑功能是什么？\n数据建模的作用\n反映了与任何数据处理应用相关的一组特定问题 系统处理哪些主要的数据对象？ 每个数据对象的组成如何？ 哪些属性描述了这些数据对象？ 这些数据对象当前位于何处？ 每个数据对象与其他数据对象有哪些关系？ 数据对象和变换它们的处理之间有哪些关系？ 数据对象 通常将数据对象简称为实体\n数据对象的属性和关系\n数据对象的基数\n一对一、一对多、多对多 ER图 主要目的是以图形形式表示实体与实体之间的关系\n数据结构规范化 数据对象之间的基数关系，在关系型数据库中就会造成数据存储的冗余现象。为了消除数据冗余，就需要对实体-关系图中的数据进行规范化处理，即数据范式。\n规范化的好处：\n消除多义性 关系单纯化 是关系模式更灵活 6 软件设计 软件设计的目标 根据软件需求分析的结果，设想并设计软件，即根据“目标系统”的逻辑模型确定“目标系统”的物理模型，概况地描述系统如何实现用户所提出来的功能和性能\n软件设计包括：\n软件系统的结构设计、处理方式（性能）设计 数据结构和数据存储的设计 界面和可靠性设计 软件设计的过程 软件设计是一个把软件需求变换成包含软件功能模型、数据模型以及行为模型的过程。\n从工程管理的角度，软件设计分成：\n概要设计：只需描绘出可直接反映功能、数据、行为需求的软件总体框架； 详细设计：即过程设计，通过对软件结构进行细化，得到各功能模块的详细数据结构和算法，使得功能模块在细节上非常接近于源程序的软件设计模型。 从技术的角度看分为\n结构设计\n定义了软件系统各主要元素（主要指功能模块）之间的关系，其中包括软件的模块接口设计；\n数据设计\n软件各模块所需要处理的数据以及系统需要长久保存的数据进行数据结构和数据存储的设计；\n过程设计\n确定各功能模块内部结构的详细定义，包括模块主要算法逻辑和局部数据结构的定义。\n软件概要设计 制定设计规范\n在进入软件开发阶段之初，首先应为软件开发小组指定设计阶段应该共同遵守的标准，作为后续设计和编码工作的基础，方便协调组内各成员可以在一个相同认可的语境下工作和讨论的问题。\n软件系统结构的总体设计\n根据需求分析的结果，采用某种设计方法，将一个复杂的系统按功能划分成模块的层次结构。 确定每个模块的功能，建立需求与功能之间的对应关系 确定模块间的调用关系及模块间的接口 优化已有结构使系统达到要求的性能指标\n处理方式设计（性能设计）\n首先，为每一个已确定的功能模块定义所必须的算法，并评估算法的性能。 其次，还需要确定为满足软件系统的性能需求所必须的算法和模块间的控制方式\n数据结构设计\n确定软件涉及的文件系统结构以及数据库的模式、子模式，进行数据完整性和安全性的设计。\n可靠性设计（质量设计）\n软件可靠性指软件系统在长时间的运行过程中出现的错误数以及系统恢复的能力，以及由此而发现的各类文档中出现的描述性错误和设计性错误。\n界面设计\n软件详细设计 也称之为软件的过程设计。相对于概要设计而言，就是针对软件概要设计的结果进行功能模块内部结构的设计\n软件设计的主要内容 软件体系结构设计 结合软件体系结构已有的类型或风格，决定当前软件系统的体系结构和框架，作为后续软件设计活动的基础\n软件功能结构设计 根据需求分析的结果，并结合以及确定的软件体系结构，进一步确定需求对应的软件功能模块及其功能模块之间的关系\n软件的数据设计 软件的数据存储结构设计 根据需求分析结果中的领域模型或者问题域描述，并结合软件体系结构，确定系统需要持久保存数据的数据模型\n软件的局部数据结构设计 根据确定的软件功能结构以及相应的业务处理逻辑，确定每个功能模块内部所需要的局部数据结构，并满足功能模块之间调用接口的要求\n软件的接口设计 根据软件的功能结构，进一步确定功能模块之间调用的接口机制，以及软件层次结构之间功能模块调用的接口机制\n软件的过程设计 即软件的详细设计，根据已经确定的每个功能模块，进一步确定每个功能模块内部的处理逻辑，并结合软件的局部数据结构的设计，完善每个功能模块的处理过程\n软件设计模型 动态结构设计\n以某种方式表示功能响应客户请求时处理数据的过程或条件，用于进一步解释软件结构中各功能之间是如何协调工作的机制，解释这些功能存在的必要性。\n静态结构设计\n由软件的功能结构和数据结构组成，展示软件系统能够满足所有需求的框架结构；展示为了满足所有功能需求系统所必备的功能模块及其关系。\n软件设计基础 一般性原则 衡量设计过程的原则 设计过程应该是可追踪和可回溯的 设计必须实现分析模型中描述的所有显示需求，必须满足用户希望的所有隐式需求 设计说明文档必须是可读的、可理解的，使得将来已于编程、易于测试、易于维护 衡量设计模型的原则 设计模型应该展现软件的全貌，包括从实现角度可以看到的数据、功能、行为 设计模型应该是一个分层结构 设计应当模块化，应当建立具有独立功能特征的构件 设计应当建立能够降低模块与外部环境之间复杂连接的接口 设计应当根据将要实现的对象和数据模式导出合适的数据结构 软件结构的模块化 模块的定义 整个软件可被划分成若干个可单独命名且可编址组成部分，这些部分称之为模块。\n模块的3个基本属性\n功能：实现什么功能，做什么事情。 逻辑：描述模块内部怎么做。 状态：该模块使用时的环境和条件。 模块的表示 在表示一个模块的时候，须按模块的外部特性和内部特性分别描述\n模块的外部特性\n模块的模块名、参数表、以及给程序以至整个系统造成的影响 模块的内部特性\n完成其功能的程序代码和仅供该模块内部使用的数据 模块的独立性和耦合性 如果一个模块能够独立于其他模块被编程、测试和修改，而和软件系统中其它的模块的接口是简单的，则该模块具有功能独立性。\n1978年Meyer提出了两个准则度量模块独立性，即模块间的耦合和模块的内聚。\n模块的内聚性 内聚是模块功能强度的度量，一个模块内部各元素之间的联系越紧密，则它的内聚性就越高，相对地，它与其他模块之间的耦合性就会减低，而模块独立性就越强。\n巧合内聚\n当几个模块内凑巧由一些程序段代码相同，有没有明确表现出独立的功能，程序员为了减少存储，把这些代码独立出来建立一个新的模块，是内聚成都最低的模块 比如常见的一个项目下有Utils模块\n逻辑内聚\n这种模块把几种相关的功能组合在一起，每次被调用时由传送给模块的控制型参数来确定该模块应执行哪一种功能，比巧合内聚模块的内聚程度要高\n比如有一个文件操作模块A，还有一个调用模块B。A包含有读文件和写文件。B调用A的功能，然后A在该功能内部判断要用写还是读。\n时间内聚\n时间内聚又称为经典内聚。这种模块一般为多功能模块，但模块的各个功能的执行与时间有关，通常要求所有功能必须在同一时间段内执行。\n例如初始化模块和终止模块。\n过程内聚\n一个模块由几个部分（子模块）组成，且通过一定的次序执行，这种模块称为过程内聚。\n使用流程图做为工具设计程序时，把流程图中的某一部分划出组成模块，就得到过程内聚模块。 例如，把流程图中的循环部分、判定部分、计算部分分成三个模块，这三个模块就是过程内聚模块\n通信内聚\n如果一个模块内各功能部分都使用了相同的输入数据，或产生了相同的输出数据，则称之为通信内聚模块。 信息内聚\n这种模块具有多个功能，各功能都在同一数据结构上操作，每项功能有一个唯一的入口点。这个模块将根据不同的要求，确定该执行哪一个功能。\n可以看成是多个功能内聚模块的组合，并且达到信息的隐蔽\n功能内聚\n一个模块中各个部分都是完成某一具体功能必不可少的组成部分，或者说该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割的。则称该模块为功能内聚模块。\n模块的耦合性 耦合是模块之间互相连接的紧密程度的度量。模块之间的连接越紧密，联系越多，耦合性就越高，而其模块独立性就越弱。\n内容耦合\n如果一个模块直接访问另一个模块的内部数据 或者一个模块不通过正常入口转到另一个模块内部 或者两个模块有一部分程序代码重叠 或者一个模块有多个入口，则两个模块之间就发生了内容耦合 公共耦合\n若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。\n公共耦合的复杂程度随耦合模块的个数增加而显著增加。若只是两模块间有公共数据环境，则公共耦合有两种情况。松散公共耦合和紧密公共耦合。\n所有公共耦合模块都与某一个公共数据环境内部各项的物理安排有关，若修改某个数据的大小，将会影响到所有的模块。\n无法控制各个模块对公共数据的存取，严重影响软件模块的可靠性和适应性。\n公共数据名的使用，明显降低了程序的可读性。\n例题\n外部耦合\n一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。\n一组模块共享一个数据格式、通信协议或者外部接口定义\n控制耦合\n如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。\n标记耦合\n如果一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。\n一组模块共享一组数据结构，且只需要使用数据结构中的某一部分\n数据耦合\n如果一个模块访问另一个模块时，彼此之间是通过数据参数来交换输入、输出信息的情况。\n非直接耦合\n如果两个模块之间没有直接关系，它们之间的联系完全是通过主（上级）模块的控制和调用来实现的，这就是非直接耦合。这种耦合的模块独立性最强。\n面向对象的设计原则 单一职责 针对类，应该只有一个引起它变化的原因，“职责”定义为变化的原因\n如果有其他原因去改变一个类，那么这个类就具有其他的职责。类具有多个职责，等于这些职责具有耦合关系。\n为了提高类的内聚度，应将对象的不同职责分离至两个或多个类中，确保引起该类变化的原因只有一个。\n里氏替换原则 子类应当可以替换父类并出现在父类能够出现的任何地方。\n依赖倒置原则 高层模块不应依赖于低层模块，二者都应依赖于抽象；抽象不应依赖于实现细节，细节应该依赖于抽象。\n接口隔离原则 采用多个与特定客户类的接口 比 采用一个通用的涵盖多个业务方法的接口要好。\n迪米特法则 最少知识原则：一个对象应当可能少的了解其它对象。\n开闭原则 软件实体（类、模块、函数）可以扩展，但不能修改。\n对于已存在的软件类的扩展是开放的，对于更改是封闭的。当需求改变时，对模块进行扩展，以满足需求的变化。但对于更改已有类的功能是不允许的。\n组合/聚合复用 在一个新对象里面使用一些已有对象，使之成为新对象的一部分\n新对象通过向已有对象委托一部分责任而达到复用已有对象的目的\n7 面向对象设计方法 面向对象设计任务 基于UML建模语言，将 软件需求分析阶段获得的用例模型和领域模型的内容 运用 一系列软件设计原则 转换成 软件设计阶段设计模型的 动态结构和静态结构。\n在软件设计阶段考虑如何将系统职责映射到软件的功能上，并且还需要进一步定义哪些软件对象具有这些功能，以及这些对象之间如何协调完成用例规定的内容。\n软件概要设计\n系统的动态结构设计：\n用例实现过程设计，针对用例对应的SSD中的每个系统事件，运用UML的 sequence diagram / collaboration diagram 给出符合该系统事件定义的操作契约的内容；\n如果软件对象具有多种不同的职责（主要考虑对应于不同的用例）的情况下，需要运用 state machines diagram 对该软件对象进行状态迁移的设计；\n系统的静态结构设计\n对所有用例的交互图进行归纳，运用UML的 Class diagram 结合软件架构给出系统的静态结构； 如果系统规模较大，建议分为以下两个阶段进行设计 基于用例的功能结构类图 基于系统的功能结构类图 软件的详细设计\n针对系统静态结构中每个对象的方法，运用UML activity diagram 或程序流程图或NS图对其进行逻辑结构的设计 面向对象设计的关键步骤\n发现对象（发现软件类） 确定对象之间的关系 确定对象行为 软件的层次化结构 一共五层 用户界面层 控制器层 业务/应用层 持久化层 系统层 模型层次化的好处：\n增加软件的健壮性，易于扩展和维护 增加软件的可移植性 用户界面层 用户界面层指与用户进行交互的部分，代表客户端，包含应用程序中用户界面部分的代码。\n系统与用户的界面可以以多种形式出现：\n图形用户界面GUI 命令行界面 其他交互界面（语音等） 控制器层对象设计原则 根据分层的软件体系结构的框架，接收界面层消息请求的软件对象应该位于控制器层，这些对象称为控制器对象，\n通常为每一个用例设计一个控制器对象\n业务/应用层对象设计原则 应用逻辑层的这些软件对象应该选择代表具体的业务功能需求，为了保持OOA（OOA是面向对象分析，输出领域模型）和OOD（OOD是面向对象设计，输出类图和交互图）的一致性应该参考领域模型中相关的概念类作为设计参考\n在面向对象分析阶段，已经了解了业务对象是如何提供服务的（业务规则不会由于软件系统的引入而发生改变），为此在面向对象设计阶段，将会参考这些业务对象并将其转变为软件系统中应用逻辑层中的软件对象；为了增加可扩展性和可维护性可进行必要的修改和调整，最终使之成为设计模型中业务/领域层中的软件类。 持久化层对象设计原则 引入持久化层的目的在于当数据存储机制或策略发生变化的时候，能减少对应用逻辑层对象的维护工作。为了提高处理性能，则需要将经常性访问的数据同步到内存中，也就是初九话对象中，而不必每次请求都需要访问数据库\n该软件对象的职责就是管理（增删改查）经过业务逻辑对象处理后的需要持久保存的数据，又能与业务逻辑的功能相分离保持其独立性，又能与数据库保持同步，这些对象称为持久化对象。 基于类职责分配GRASP的设计 General Responsibility Assignment Software Patterns 通用之职责分配软件模式\nGRASP一共包括9种模式，描述对象设计和职责分配的基本原则。\n解决如何把现实世界的业务功能抽象成对象，如何决定一共系统有多少对象，每个对象都包括什么职责，GRASP模式给出了最基本的指导原则\n控制器模式 将前端发送过来的请求或系统事件分配给一各能够代表用例或者整个系统的类，进行必要的合法性判断和检查后转发给应用逻辑层对应的软件对象。\n它们只是接收系统事件消息，并没有实现系统操作的职责，系统操作应该委托给领域对象处理。\n它代表整个系统（系统简单且不复杂），称为外观（facade）控制器； 它代表一个发生系统事件的用例场景，这个类通常命名为“\u0026lt;用例名\u0026gt;控制器”，称为用例控制器或者会话控制器。 创建者模式 当控制器对象将系统事件转发或者派送给应用逻辑层对象时，该设计模式负责解决这些对象实例如何被创建以及哪个对象来负责创建对象的实例的原则\n创建者模式体现了低耦合的设计思想，是对迪米特法则的具体运用。 信息专家模式 用以解决给对象分配功能的模式，即将职责分配给拥有履行功能所必须信息的类，即信息专家。\n对象具有处理自己拥有信息的职责或能力。\n在UML交互图中接收消息的对象就应该具有处理该消息的职责和能力\n8 软件实现 软件实现是软件详细设计的后续阶段及任务，即程序编码\n软件实现的 目标就是选择某种程序设计语言，将软件详细设计结果进行编码实现，并形成可执行的软件系统的过程\n软件实现的任务包括 程序设计语言的选择 集成开发环境的选择 程序实现算法的设计 程序编码实现 源程序文档化 为了提高源程序的可维护性和可阅读性，要求源程序具有良好的风格，包括标识符命名、程序注释、程序布局等内容。\n标识符命名 根据所选择的编程语言，制定或使用编码规范的要求，规范化源程序中的标识符的命名规则\n源程序的注释 为了提高源程序的可阅读性，规定源程序必须提供以下两种注释\n序言性注释\n通常置于每个程序模块的开头部分，给出程序的整体说明，对于理解程序本身具有引导作用。要求逐项列出：模块名词、模块功能和目的 的说明、、主要算法、接口说明、有关数据描述、模块位置、开发简历等\n功能性注释：\n用以描述当前或其后的语句或程序段目的和逻辑\n源程序的布局 源程序布局指源程序的代码编排格式。\n合理的源程序布局能够提高代码的清晰性，增强代码的可读性，进而提高程序的可维护性\n9 软件测试（超级重点） 软件测试的定义 为发现软件中存在的错误，对软件开发过程中形成的各项输出进行检查的过程。以最少的事件和人力，系统地找出软件中潜在的各种错误和缺陷，并证明软件的功能和性能与需求说明相符合\n软件测试的目的 用户角度 通过软件测试暴露软件中的错误和缺陷，以考虑是否可接收该软件产品\n开发者角度 希望测试成为表明软件产品中不存在错误，验证该软件已正确地实现了用户的要求，确立人名对软件质量的信息\nGlenford J.Myers 认为 测试是程序的执行过程，目的在于发现错误\n一个好的测试用例在于能发现至今未发现的错误\n一个成功的测试是发现了至今未发现的错误的测试\n测试不能表明软件中不存在错误，只能说明软件中存在错误。\n软件测试的原则 所有测试都应该以用户的需求为依据 应当把“尽早地和不断地进行软件测试”作为软件开发者的座右铭 程序员应避免检查自己的程序 测试用例应由测试输入数据和对应的预期输出结果这两部分组成 在设计测试用例时，应当包括合理的输入条件和不合理的输入条件 充分注意测试中的群集现象，针对重点模块进行更充分的测试 完全测试是不可能的，测试需要终止 严格执行测试计划，排除测试随意性。应当对每一个测试结果做全面检查 妥善保存测试计划，测试用例，出错统计和最终分析报告，为维护提供方便 软件测试对象 软件测试对象包括软件开发过程中产生的各种里程碑文档，包括软件需求规格说明、软件概要设计说明、软件详细设计说明、源代码等文档\n软件测试流程 为了开展软件测试，就需要首先组建开发团队、进行软件测试活动之前的一系列准备活动，执行软件测试后还需要进行测试结果分析、软件排错以及必要的可靠性分析等活动。\n软件配置：软件需求规格说明、软件设计规格说明、源代码等； 测试配置：测试计划、测试用例、测试程序等； 测试工具：测试数据自动生成程序、静态分析程序、动态分析程序、测试结果分析程序、以及驱动测试的测试数据库等等。 软件测试方法 白盒测试 必考一题应用题 将测试对象看做一个透明的盒子，允许利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致，又称为结构测试或逻辑驱动测试。\n又称为结构测试、逻辑驱动测试或基于程序的测试，指根据软件产品的内部工作过程，设计测试用例，以证实每种内部操作是否符合设计规格要求，允许测试人员利用程序内部的逻辑结构及有关信息设计或选择测试用例，对程序所有程序元素进行覆盖测试\n白盒测试原则 程序模块的所有独立的执行路径至少测试一次 对所有的逻辑判定，取真与取假的两种情况都至少测试一次 在循环的边界和运行界限内执行循环体 逻辑覆盖 逻辑覆盖的种类\n逻辑覆盖是以程序内部的逻辑结构为基础设计的测试用例技术，包括以路径覆盖为基础的语句覆盖、判定覆盖、条件覆盖、判定+条件覆盖、条件组合覆盖的测试方法 确定测试路径的逻辑表达式\nL1 、L2 、L3 、L4 L1: a-\u0026gt;c-\u0026gt;e {(A\u0026gt;1) AND (B=0)} AND {(A=2) OR (X/A \u0026gt; 1)} = (A=2) AND (B=0) OR (A\u0026gt;1) AND (B=0) AND (X/A \u0026gt; 1) L2: a-\u0026gt;b-\u0026gt;d L3: a-\u0026gt;b-\u0026gt;e L4: a-\u0026gt;c-\u0026gt;d 要记得把变量值的更改也算进去 语句覆盖\n在图例中，整合所有的可执行语句都在L上，所以选择L1设计测试用例，就可以覆盖所有的可执行语句 判定覆盖\n使得程序中每个判断的取真分支和取假分支至少经历一次，又称为分支覆盖 根据要求，可以选择L1和L2，也可以选择L3和L4 就是几条路径加起来，可以覆盖所有的分支就行 条件覆盖\n使得程序中每个判断的每个条件的可能取值至少执行一次 判定-条件覆盖\n使得判断中每个条件的所有可能取值至少执行一次，同时每个判断的所有可能判断结果取值至少执行一次。 条件组合覆盖\n使得每个判断的所有可能的条件取值组合至少执行一次。 需要将多重条件判断分解成有多个基本判断组成的流程图 路径测试\n路径测试就是设计足够的测试用例，覆盖程序中所有可能的路径。 基本路径测试 要求对包含循环结构和分支结构的复杂程序确定必须被测试路径的方法，通过对原始的程序逻辑进行简化表示成一个控制流图，进而根据控制流图的节点、边以及区间确定必须被测试的路径。\n控制流图转换 顺序结构的多个结点可以合并成一个 在选择或多分支结构中，分支的汇聚处应有一个虚拟汇聚节点 如果判断中的条件表达式是由一个或多个逻辑运算符连接的复合条件表达式，则需要改为一系列只有单个条件的嵌套的判断 控制流图的的环路复杂度计算 控制流图的环路复杂度确定了程序中独立路径的上界，以此为依据可以找出程序中的全部独立路径。\n环路复杂度的三种计算方法\n等于控制流图中的区域数，包括封闭区域和开放区域 设E为控制流图的变数，N为图的结点数，环路复杂性V(G)=E-N+2 若设P为控制流图中的判定结点数，则有V(G)=P+1 基本路径集：指程序的控制流图中，从入口到出口的路径，该路径至少经历一个从未走过的边。\n基本路径集不是唯一的 最大的基本路径条数就是环路复杂度 黑盒测试 必考一题应用题 又叫做功能测试、数据驱动测试或基于规格说明的测试，指在不考虑程序内部结构和内部特征的情况下，根据软件产品的需求规格说明、功能设计规格说明 设计测试用例进行的测试，以证实各项软件功能是否符合要求\n等价类划分 等价类是指输入域的子集。在该子集中，各个输入数据对于揭露程序中的错误都是等效的。并合理地假定：测试某等价类值就等价于对这一类其他值的测试。因此，我们可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个典型值作为测试的输入，这样就可用少量代表性测试数据，取得较好的测试效果\n有效等价类\n指对于规格说明来说，是合理的、有意义的输入数据构成的集合。利用它，可以测试软件在合法输入的情况下，是否给出了符合规格说明的输出\n无效等价类\n指对于规格说明来说，是不合理、无意义的输入数据构成的集合。利用它，可以测试软件对于不合理的输入，是否进行了充分的判断并给出了提示。\n划分等价类的原则 按区间划分\n如果某个字段的输入条件属于一个取值范围[x,y]，则可以确立\n一个有效等价类 两个无效等价类 按数值集合划分\n如果输入条件规定了输入数据的集合，则可以划分\n一个有效等价类：所有符合输入条件的数据集合 一个无效等价类：所有不允许输入的数据集合 如果输入条件是一个布尔\n一个有效等价类 一个无效等价类 按数值划分\n如果规定了输入数据的一组值，而且程序要对每个输入值分别进行处理，这时可以划分为\n每一个输入值确立一个有效等价类 一个无效等价类，包含所有不允许输入的数值 按限制条件或规则划分\n如果规定了输入数据必须遵守的规则或限制条件，则可以确立\n一个有效等价类，即各方面均符合规则要求 若干个无效等价类，每个无效等价类从不同角度违反输入规则 等价类划分的方法 划分等价类，包括有效和无效等价类 对所有有效等价类进行顺序编号，对所有无效等价类进行顺序编号 设计测试用例，尽可能多的覆盖尚未覆盖的有效等价类，重复这一步骤，直到全部有效等价类均被覆盖到为止 设计测试用例，每次只覆盖一个无效等价类，重复这一步骤，直到全部无效等价类均被覆盖到为止 边界值分析 是对等价类划分方法的补充\n这里所说的边界是指，相当于输入等价类和输出等价类而言，稍高于其边界值及稍低于其边界值的一些特定情况。\n使用边界值分析方法设计测试用例，首先应确定边界情况。应当选取正好等于，刚刚大于，或刚刚小于边界的值做为测试数据，而不是选取等价类中的典型值或任意值做为测试数据。\n因果图 因果图法就是一种适合于检查软件多个输入条件的各种组合情况下，系统是否存在问题的黑盒测试用例设计方法，通过因果图可以有效降低黑盒测试用例的数量\n通常在因果图中用Ci表示原因，用Ei表示结果，各结点表示状态。\n表示约束条件的符号\n为了表示原因与原因之间，结果与结果之间可能存在的约束条件，在因果图中可以附加一些表示约束条件的符号 例子\n步骤：\n建立原因 建立结果 建立中间结果 绘制因果图并添加约束条件\n所有原因结点列在左边，所有结果结点列在右边。\n由于 2 与 3 ，4 与 5 不能同时发生，分别加上约束条件E。\n列出转换表\n有5个因，就有2^5 = 32列条件 对于不合法的输入，没有中间结果和果 对于合法输入，要判断中间结果和结果是否成立 最后判断测试用例是否成立\n软件测试的基本类型 单元测试 编码阶段运用白盒测试方法，对已实现的最小单位代码进行正确性检查\n单元测试是对软件基本组成单元进行的测试，其目的在于发现源代码中各单元模块内部可能存在的各种问题。 单元测试可以通过静态测试合动态测试来完成，一般是由开发人员为主，测试人员为辅来开展的测试活动\n集成测试 编码阶段在单元测试的基础上，运用黑盒测试方法检查被测单元的接口问题，并检查代码集成后各功能的完整性。\n集成测试是对集成到一起的功能单元进行测试，以检查这些单元之间的接口是否存在问题。集成测试需要开发人员与测试人员共同配合来完成相关的测试工作。主要采用黑盒测试用例设计方法来设计测试用例。\n确认测试 开发后期，针对系统级的软件验证所实现的功能合性能是否与用户的要求一致。\n当软件完成集成测试之后，已经形成了一个基本可运行的软件系统。这时，开发组织需要对系统的各方面进行确认测试。确认测试的任务是检查已实现的软件是否满足了需求规格说明中定义的各种需求，以及软件配置是否完全、正确。确认测试一般是由开发组织中专门的测试人员完成是系统级测试活动，采用黑盒测试的用例设计方法设计测试用例\n系统测试 在开发环境或实际运行环境中，以系统需求分析规格说明书作为验收标准，对软硬件系统进行的一系列集成和确认测试。系统测试的工作范围、测试方法合测试计划一般由甲方确定，具体测试执行可以由甲方测试小组与乙方测试小组共同完成。\n验收测试 在实际运行环境中，试运行一段时间后所进行的测试活动，确认系统功能和性能符合生成要求，验收通过后交付给用户使用。呀魔兽测试应该由软件的委托单位组织专门的验收小组完成，小组成员应该包括相关领导、业务人员、项目成员、领域专家等。\n10 软件项目管理 项目及软件项目的定义 项目定义 ppt:是一项为了创造某一唯一的产品或服务的时限性工作。具有以下特征\n需要由人来完成 收到有限资源的限制 需要计划、执行和控制 肖老师：是指为了提供某项独特的产品、服务或成果在有限的资源、有限的时间内为特定的客户完成特定目标的一次性的工作\n软件项目的定义： 肖老师：是一种成果体现为软件产品的项目，在有限资源、有限时间内为特定的客户完成特定的软件产品的一次性工作 ppt：软件项目是一种成功体现为软件产品的项目，其特有的特征表现为： 软件产品是无形的 软件产品没有标准的软件过程 大型软件项目开发常常是“一次性的” 软件项目管理的定义 在软件开发过程中，通过对各个开发环节的管理，在有限资源和规定时间内，完成客户要求的特定软件产品。为了实现项目目标，使软件项目开发获得成功，需要对软件开发项目的工作范围、可能遇到的风险、需要的资源（人力、硬件和软件）、要完成的任务、经历的里程碑、花费的工作量（成本）以及进度的安排等进行有效的管理\n项目管理包括以下九个知识领域\n范围管理 时间管理 成本管理 质量管理 人力资源管理 沟通管理 风险管理 采购管理 综合管理 软件项目管理的过程 项目管理过程是一组为了完成一系列事先指定的产品、成果或服务而须执行的相互联系的行动和活动。软件项目管理分为启动、计划、执行、监控和收尾5个过程\n软件项目计划 软件项目计划是一项软件开发活动中必不可少的任务，根据软件开发的任务分配适当的工作量及资源以适应整个软件项目的工期。\n软件项目估算 为了指定合理有效的项目计划，就必须事先进行项目估算，确定项目的范围、所需的资源、所能投入的成本以及项目开发所必需的时间。\n每个任务的期望值 = （1个最乐观时间 + 4个最可能时间 + 1个最悲观时间）/ 6\n软件的进度安排 根据项目的生命周期模型确定每个阶段的任务列表 为每一个任务确定起止时间 为每一个任务分配人力资源 确定任务之间的先后次序和关系，构建任务网络 确定每个阶段任务的关键路径，如下图 11 软件维护 软件维护的定义 软件维护就是在软件以及交付使用之后，为了改正错误或满足新的需要而修改软件的过程，即在软件运行/维护阶段对软件产品所进行的一切改动\n软件维护的类别 改正性维护 改正在系统运行过程中发现的一些潜在程序错误或设计缺陷\n适应性维护 为了适应在软件使用过程中数据环境发生变化或处理环境发生变化而进行的软件修改\n完善性维护 在软件的使用过程中，针对用户对软件提出新的功能与性能要求而进行修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性，称为完善性维护\n为了满足用户的其他要求\n预防性维护 为了提高软件的可维护性、可靠性等而事先进行的软件改动\n软件维护的活动 为了有效地进行软件维护，应进行维护的组织工作，建立维护的机构，确定维护申请报告的流程及评价过程\n为每一个维护申请规定标准的处理步骤\n建立维护活动的等级制度以及评审的标准\n维护周期的软件开发 进行软件维护时，须对源程序进行修改，通常对源程序的修改需要经历以下三个步骤：\n分析和理解程序 修改程序 重新验证程序 ","date":"2024-09-20T09:27:01+08:00","permalink":"https://ffirestorm.github.io/p/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","title":"软件工程"},{"content":"1 算法及其复杂性分析 1.1 渐进时间复杂性定义 只考大O、大Ω 1.1.1 渐进上界 big-O O f(n) 的渐进上界是 g(n)，0 \u0026lt;= f(n) \u0026lt;= cg(n)\n即，f(n)的阶不高于g(n)的阶 ——f上升规模/档次不快于于g 并不是f(n) \u0026lt;= g(n) 意味着f(n) 的最高阶 \u0026lt;= g(n) 的最高阶 找到一个 常数c 和n0\nf(n)=5n^2 +1, g(n)=2n^2, n0=1, c=3 6n^2 \u0026gt;= 5n^2 +1 当n \u0026gt;= 1 1.1.2 渐进下界 Ω f(n) 的渐进下界是 g(n)， 0 \u0026lt;= cg(n) \u0026lt;= f(n)\n即f(n)的阶不低于g(n)的阶——f上升规模/档次不慢于g 意味着 f(n) 的最高阶 \u0026gt;= g(n)的最高阶 例子\nf(n)=5n^2 +1，g(n)=10n^1.5 c = 1 0 \u0026lt;= g(n) \u0026lt;= f(n) 当n\u0026gt;4时 1.1.3 非紧上界 o 不考 要对于任何的正常数c，这就意味着，g的阶一定要比f的阶高 阶：g \u0026gt; f n -\u0026gt; ∞ 时， f/g -\u0026gt; 0 要求比渐进上界严格许多 1.1.4 非紧下界 w 不考 对于任意的正常数c f 的阶一定要比 g 的阶高 f(n) / g(n) -\u0026gt; ∞ ，当 n -\u0026gt; ∞ 1.1.5 紧渐进界 Θ 不考 1.2 例题 对于1：找到一个正常数c，和一个n0，使得对于任意的 n\u0026gt;n0 ， f(n) \u0026lt;= cg(n)\n对于2这种题，类似的有：证明O(f(n))+O(g(n)) = O(max{f(n),g(n)})\nStep1. 根据O的含义，对于任意f1(n) ∈ O(f(n)) ，存在正常数c1和自然数n1，使得对所有n\u0026gt;= n1，有f1(n) \u0026lt;= c1f(n) Step2. 类似地，对于任意g1(n) ∈ O(g(n)) ，存在正常数c2和自然数n2，使得对所有n \u0026gt;= n2，有g1(n) \u0026lt;= c2g(n) Step3. 令c3=max{c1, c2}， n3 =max{n1, n2}，h(n)= max{f1(n),g1(n)} ，则对所有的 n \u0026gt;= n3，有： f1(n) +g1(n) \u0026lt;= c1f(n) + c2g(n) \u0026lt;= c3f(n) + c3g(n)= c3(f(n) + g(n)) \u0026lt;= c3 * 2 *max{f(n),g(n)} = 2 * c3 *h(n) = c4 * h(n) = O(max{f(n),g(n)}) 1.3 算法时间复杂性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;class Type\u0026gt; void insertion_sort(Type *a, int n) { Type key; // cost times for (int i = 1; i \u0026lt; n; i++){ // c1 n key=a[i]; // c2 n-1 int j=i-1; // c3 n-1 while( j\u0026gt;=0 \u0026amp;\u0026amp; a[j]\u0026gt;key ){ // c4 sum of ti // ti：满足循环条件j\u0026gt;=0 \u0026amp;\u0026amp; a[j]\u0026gt;key的次数 a[j+1]=a[j]; // c5 sum of (ti-1) j--; // c6 sum of (ti-1) } a[j+1]=key; // c7 n-1 } } 2 递归和分治 审查一遍\n递归概念，递归法的原理/步骤（了解） 分治法基本原理/步骤、适用条件（了解） 递归函数（了解） 了解概念 用特征方程解递归方程 线性齐次递归方程 做题！ 注意：特征方程有重根的情况 不要求会线性非齐次递归方程 要求：面向特定问题的具体算法\n原理 步骤，或代码/伪代码， C/C++/Java/Python 说明时间复杂性 最好/最坏/平均时间复杂性，大O 计算示例：针对给定输入，给出算法步骤、执行结果 掌握以下算法：\n快速排序 合并排序 线性时间选择 分治经典算法 分治法设计方法 适用问题：\n1. 当问题规模缩小的一定程度就可以容易地解决 2. 可以分解为若干个规模较小的相同问题，该问题具有最优子结构性质 3. 利用该问题分解出的子问题的解可以合并为该问题的解 4. 该问题分解出的各个子问题是相互独立的 基本步骤\n1 2 3 4 5 6 7 8 devide_and_conquer(P){ if( |P| \u0026lt;= n0) adhoc(P); //解决小规模问题 divide P into smaller subinstances P1,P2...,Pk; // 分解问题 for(i = 1; i\u0026lt;=k; i++){ // 串行、并行地递归地解各子问题 yi = divide_and_conquer(Pi); } return merge(y1,...,yk); //将各子问题的解合并为原问题的解 } 在用分治法设计算法时，从平衡(balancing)子问题、提高算法效率角度出发，应尽可能使分解后的各个子问题的规模大致相同，即将一个问题分成大小相等的k个子问题 归并排序 原理\n将待排序元素分成大小大致相同的2个子集合，分别对2个子集合进行排序 目标：非递减序 合并两个排好序的子集合，得到排好序的原集合 递归合并排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Merge(Type c[ ], Type d[ ], int l, int m, int r) // 合并已经排好序（递增）的源c[l : m]、c[m+1: r]到目标数组d[l:r] { int i=l, //左子段的搜索比较指针的起点 j=m+1, //右子段的搜索比较指针的起点 k=l; //目标数组d的指针起点，符合递增顺序的c[ ]中的元素被拷贝至d[k] while (( i\u0026lt;=m) \u0026amp;\u0026amp; (j\u0026lt;=r)) //左子段比较元素c[i]小于右子段比较元素c[j]，左子段元素c[i]移至d[k]，指针i、k后移; 否则，右子段元素c[j]移至d[k]，指针j、k后移 if (c[i] \u0026lt;=c[j]) d[k++]=c[i++]; else d[k++]=c[j++]; while (i\u0026lt;=m) d[k++]=c[i++]; while (j\u0026lt;=r) d[k++]=c[j++]; } // 自顶向下 void MergeSort(Type a[], int left, int right) { if (left\u0026lt;right) { //*至少有2个元素 int i=(left+right)/2; //*取中点 mergeSort(a, left, i); //*左子问题求解 mergeSort(a, i+1, right); //*右子问题求解 merge(a, b, left, i, right); //合并、copy到数组b, 关键 ! copy(a, b, left, right); //复制回数组a } } 非递归合并排序\n改进\n省略自上而下的分解过程，将a[]中相邻元素两两配对，作为最底层子问题，由下而上使用merge过程，进行排序 消除排序中的递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //合并x[]中长度为s的内部已排序的多对相邻子数组；合并结果放在y[]中，y[]内部包括长度为2s的多对相邻有序子数组；x、y中元素总数n void MergePass(Type x[], Type y[], int s, int n) { int i=0; while (i\u0026lt;=n-2*s) { //合并x[]中的已排序的长度s的2个相邻子段x[i,i+s-1]、[i+s,i+2s-1]，结果放在y[]中, e.g.i=0, s=2时，x[0,1]、x[2,3] Merge(x, y, i, i+s-1, i+2*s-1); i=i+2*s; } // 剩下的元素x[i,n-1]的个数少于2s(e.g.2s=4) // 剩余未处理的子段x[i,n-1]，如果其长度大于s、小于2s，e.g. i=12, s=2， i+s=14 \u0026lt;= n=15， x[i,n-1]内部没有完全排好序，合并长度=s的x[i,i+s-1]={0,18}、长度\u0026lt;s的x[i+s,n-1]={16}; 如果子段x[i,n-1]长度n-i\u0026lt;s, i+s\u0026gt;n, e.g n=14, 不包括最后元素{18}，剩余子段{0，16}内部已排序，将其copy至y[] if (i+s\u0026lt;=n) Merge(x, y, i, i+s-1, n-1); else for (int j=i; j\u0026lt;=n-1; j++) y[j]=x[j]; } void MergeSort(Type a[], int n) { Type *b = new Type[n]; //创建数组b int s=1; //自下而上，从长度为s=1的子序列对（数组中2个相邻的元素对）开始 while (s\u0026lt;n) { MergePass(a, b, s, n); //将源数组a[]中长度为s的子序列对（2个长度为s的相邻子序列），合并到目标数组b； 合并完后，长度s增加，为下次合并做准备 s+=s; //将b []中长度为s的子序列对，合并到数组a； 合并完后，长度s增加，为下次合并做准备 MergePass(b, a, s, n); //合并到数组a s+=s; } } 快速排序 原理\n对输入的待排序数组a[p:r] 1. 分解 按照一定的规则，从中选择x=a[q]，以a[q]为基准元素，将数组a划分为三段a[p:q-1], a[q], a[q+1:r]，使得a[p:q-1]中的元素均小于等于a[q]，a[q+1:r]的元素均大于a[q] 2. 递归求解 递归调用快排算法，对a[p:q-1]和a[q+1:r] 分别排序 3. 合并 不需要做任何计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template\u0026lt;class Type\u0026gt; int Partition (Type a[], int p, int r) { int i = p, j = r + 1; Type x=a[p]; // *第1个元素作为比较基准 // 将\u0026lt; x的元素交换到左边区域 // 将\u0026gt; x的元素交换到右边区域 while (true) { while (a[++i] \u0026lt;x \u0026amp;\u0026amp; i\u0026lt;r); //扩展左端a[p:i]，左→右搜索大元素a[i]\u0026gt;=x while (a[- -j] \u0026gt;x); //扩展右端a[j:r]，左←右搜索小元素a[i]\u0026lt;=x if (i \u0026gt;= j) break; Swap(a[i], a[j]); } a[p] = a[j]; a[j] = x; return j; } void QuickSort (Type a[], int p, int r) { if (p\u0026lt;r) {//至少2个元素 int q=Partition(a,p,r); QuickSort (a,p,q-1); //对左半段排序 QuickSort (a,q+1,r); //对右半段排序 } } 算法复杂性分析\n非递减序\ne.g : 6、8、10、12、15、20\nPartition:\n以O(n)时间复杂度，将长度为n=r-p+1的a[p:r]划分为\n1. 长度为1的a[p:p] 2. 长度为n-1的非递减子序列a[p+1:r] 每次划分后，右端需要进一步处理的子序列长度减一\nQuickSort:\nn-1次调用Partition，对长度为n、n-1、\u0026hellip;、2的子序列a[p:r], a[p+1:r], a[p+2:r],\u0026hellip;,a[r-1:r]进行划分排序\n时间复杂性为O(n^2)\na[p:r]已排好序，Partition、QuickSort是多余的\n非递增序\ne.g : 20、15、12、10、8、6\nPartition\n以O(n)时间复杂度，将长度为n=r-p+1的a[p:r]划分为\n1. 长度=1的a[p:p] 2. 长度为n-1的a[p+1:r] 每次划分后，左端或右端需要进一步处理的子序列长度减一\nQuickSort:\nn-1次调用Partition，对长度为n、n-1、\u0026hellip;2的子序列a[p:r]，a[p:r-1]，a[+1:r-1]，\u0026hellip;，a[p:p+1]进行划分排序，从两端依次选取划分元素\n每次所选取的进行划分的子序列从左右两端依次减少一个元素，子序列长度为n、n-1、\u0026hellip;2、1\n时间复杂性为O(n^2)\n最坏：\n当选取数组中最小元素（或最大元素）作为划分元素x，划分产生的2个子序列不平衡、大小不一，1个有n-1个元素，而另一个只有0个元素，从分治法角度，两个子问题极度不平衡 最好：\n当选取数组中各个元素的中位数（或接近中位数）作为划分元素x，划分产生的2个子序列大小接近。从分治法角度，两个平衡子问题 线性时间选择 问题\n给定线性序集中n个元素和一个整数k，1≤k≤n，要求找出这n个元素中第k小的元素 n个元素存放在a[0:n-1]中 设计\nStep1. 从a[]中选取划分基准元素x=a[0]，将a[0:n-1]划分为2部分,得到a[0:q]： 1）a[0:q]，q+1个元素,包括a[q] 2）a[q+1, n-1]，n-q-1个元素 Step2. 1）L=q+1=k, x=a[q]为第k小元素，返回结果，算法结束 2）L=q+1\u0026gt;k, 则左半段至少有k个不大于x=a[q]的小元素，第k小的元素在左半段，递归搜索a[0:q] 3）L= q+1 \u0026lt; k, 左半段比x=a[q]小的元素少于k-1个，x=a[q]不可能是第k小元素，第k小的元素在右半段，递归搜索a[q+1:n-1] 算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 3，1，0，4，2，5，7，8，6 template\u0026lt;class Type\u0026gt; int RandomizedPartition(Type a[], int p, int r){ int i = p, j = r+1; Type x = a[p]; while(i \u0026lt; j){ while(a[++i] \u0026lt; x \u0026amp;\u0026amp; i\u0026lt;r); while(a[--j] \u0026gt; x); swap(a[i], a[j]); } a[p] = a[j]; a[j] = x; return j; } Type RandomizedSelect( Type a[], int p, int r, int k) { if (p==r) return a[p]; //只有1个元素 int i=RandomizedPartition(a,p,r), //*划分为2部分, e.g. i=p+5 j=i-p+1; //左端小元素个数，e.g. j=6 if (k\u0026lt;=j) // e.g. k=4， -\u0026gt; 第4小的元素3 return RandomizedSelect(a,p,i,k); //*在左半部分查找 else return RandomizedSelect(a,i+1,r,k-j); //*在右半部分查找 } 复杂性分析：\n最坏复杂性为O(n^2)，不行，要最坏的复杂性为O(n)的。 改进——划分基准寻找\nstep1. 将n个输入元素划分成m=n/5个组(取上界)，每组5个元素，只可能有一个组（最后一组）少于5个元素 这一步复杂性为O(n) step2. 选用某种排序算法，如冒泡排序，将每组中的元素排好序，取出每组的中位数，共m=n/5个 复杂性 [n/5] * 5lg5=O(n) step3. 递归调用select找出这[n/5]个元素的中位数，如果m=[n/5]是偶数，找它的2个中位数中较大的一个。以这个元素作为划分基准 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Type Select(Type a[], int p, int r, int k) { if (r-p\u0026lt;20) { // 用某个简单排序算法对数组a[p:r]排序; sort(a, p, r); return a[p+k-1]; //返回a[p:r]中的第k小元素 } // 找到各个区间的中位数，并放到数组的最前面 for ( int i = 0; i\u0026lt;=(r-p-4)/5; i++ ) ; { int s=p + 5*i, t=s + 4; // 一个区间的左右 for (int j=0; j\u0026lt;3; j++) bubble(s, t-j); swap(a, p+i, s+2); } // 选择中位数作为划分基准x，从存放各子段中位数的a[]前端部分a[p:p+(r-p-4)/5]中，选第(r-p+6)/10小的数。 // 一共有r-p+1个元素，[r-p+1/5]个组，要取上界。这些组里要找一个中位数 Type x = Select(a, p, p+(r-p-4)/5, (r-p+6)/10); //根据x将a[p:r]分成三部分 int i = Partition(a, p, r, x), j = i-p+1; //左子段长度 if(j==k) return a[i]; else{ if(k \u0026lt; j){ return select(a, p, i-1, k); }else{ return select(a, i+1, r, k-j); } } } 采用特征方程求解递归方程 线性齐次递归方程 —— 特别注意有重根的情况\n需要考虑两种情况：\n1. 特征方程的k个根不相同，即无重根 2. 特征方程有相重的根 无重根的例子 有重根的例子 f(n) = 5f(n-1)- 7f(n-2) + 3f(n-3) f(0) = 1 f(1) = 2 f(3) = 7 这里好像ppt写错了，但是最后的因式分解结果没错 先得到通解 再代入 最后算出c1、c2、c3，并带入通解中 3 动态规划 动态规划法的原理、要素（了解）\n最优子结构性质 要求：面向特定问题的具体算法\n原理 说明/证明最优子结构性质，递推/状态方程 步骤，或代码/伪代码，c/c++/Java/Python 说明/分析时间复杂性，大O 计算示例：针对给定输入，给出算法步骤、执行结果 掌握\n矩阵连乘 最长公共子序列 最大子段和 0/1背包问题 动态规划算法基本要素 具有两个性质\n最优子结构 子问题的解-原问题/规模更大子问题的解之间的递推关系，决定自下而上的求解方式 重叠子问题 动态规划法，寻找子问题解的最优组合 最优子结构 原问题/规模较大的子问题的最优解中包含了规模较小的子问题的最优解\n以矩阵连乘为例 全部矩阵的最少乘法次数的计算次序中， 包含着部分矩阵的最少乘法次数的计算次序 采用反证法，证明一个问题具有最优子结构性质\n首先假设由原问题的最优解推导出的子问题的解不是最优的， 然后再设法说明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾 例如矩阵连乘问题 1. 假设最优子结构性质不成立，即矩阵连乘中，最优解的子问题不是最优解 2. 我们假设在k处做了一个非最优决策，将矩阵链划分为两部分：A1 * A2 * ... * Ak-1 * (Ak * Ak+1 * ... * An)。 我们考虑将第k个矩阵与其前面的矩阵链合并，得到(A1 * A2 * ... * Ak) * (Ak+1 * ... * An)。由于我们假设在位置k处选择了非最优决策，所以这个新的矩阵链的乘法次数会比原最优解更少。 3. 通过将非最优决策变为最优决策，我们构造了一个乘法次数更少的解，原问题的最优解不是最优解，矛盾。 经典算法 矩阵连乘 给定n个可连乘的矩阵{A1, A2, …,An}，计算连乘积A1A2 …An\n2个矩阵A[pi, pj],B[pj, pk], A×B 为[pi,pk]矩阵，数乘次数pi×pj×pk 目标\n给定n个矩阵｛A1, A2,…,An｝，其中Ai与Ai+1是可乘的，i=1，2…，n-1，如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少？ 考察计算A[i:j]的最优计算次序\n设该计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k\u0026lt;j，则其相应完全加括号方式为 (Ai Ai+1...Ak)(Ak+1 Ak+2 ... Aj) 计算量为\nA[i:k]的计算量 + A[k+1:j]的计算量 + A[i:k]和A[k+1:j]相乘的计算量 最优解结构分析\n计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的（可以反证法证明），即： 矩阵连乘计算次序问题的最优解包含着其子问题的最优解， 这种性质称为最优子结构性质 建立递归关系\n设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n] 当 i=j 时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n 当 i\u0026lt;j 时，m[i,j]=m[i,k]+m[k+1,j]+ pi-1 * pk *pj 断开位置为k。这里的Ai维数为pi-1 * pi 两个矩阵相乘，结果有pi-1 * pi+1 个元素，每个元素需要计算 pi 次 m[i,j]可以递归的定义为： 最终得到多项式时间的算法，O(n3)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void MatrixChain(int *p，int n，int **m，int **s) { // 初始化数组 for (int i = 1; i \u0026lt;= n; i++) m[i][i] = 0; //自下而上，从规模为r=2的子问题开始， for (int r = 2; r \u0026lt;= n; r++){ //考察规模为r的子问题 for (int i = 1; i \u0026lt;= n - r+1; i++) { // [i:j]有r个矩阵 int j=i+r-1; // m[i:i] = 0，后面的m[i+1][j]已经在上一次迭代中计算了 m[i][j] =0+ m[i+1][j]+ p[i-1]*p[i]*p[j]; s[i][j] = i; // 记录初始最优断点位置 for (int k = i+1; k \u0026lt; j; k++) { int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if (t \u0026lt; m[i][j]) { m[i][j] = t; s[i][j] = k; } } } } } 复杂性 求解要素 状态\n自下而上求解过程中的不同阶段、步骤，状态A[i,j]代表规模为(j-i+1)的子问题已经解决，得到其最优解m[i: j] 初始状态：A[i: i], 1≤i ≤ n，规模为1的子问题 中间状态：A[i: j], 1 ≤ i \u0026lt;j ≤ n, 规模为j-i+1\u0026lt;n的子问题 目标状态： A[1: n]，规模为n的原问题 最长公共子序列 判断最优子结构性质\n设序列X(m)={x1,x2,…,xm}和Y(n)={y1,y2,…,yn}的最长公共子序列为Z(k)={z1,z2,…,zk} ，问题规模\u0026lt;m,n\u0026gt;，考察三种情况下问题结构 情况1：若xm=yn，则zk=xm=yn，且Z(k-1)={z1, z2,…,zk-1 }是X(m-1)= {x1,x2,…,xm-1}和Y(n-1)={y1,y2,…,yn-1}的最长公共子序列 \u0026lt;m, n\u0026gt; -\u0026gt; \u0026lt;m-1, n-1\u0026gt; 情况2：若xm≠yn且zk≠xm，则Z(k)是X(m-1)和Y(n)的的最长公共子序列 \u0026lt;m, n\u0026gt; -\u0026gt; \u0026lt;m-1, n\u0026gt; 情况3：若xm≠yn且zk≠yn，则Z(k)是X(m)和Y(n-1)的最长公共子序列 \u0026lt;m, n\u0026gt; -\u0026gt; \u0026lt;m, n-1\u0026gt; 由此可见，2个序列的最长公共子序列包含了这2个序列的前缀(i.e. 子问题)的最长公共子序列。 因此，最长公共子序列问题具有最优子结构性质 问题递归结构/状态方程\nc[i][j]：序列X(i)和Y(j)的最长公共子序列的长度， 1. 边界条件：X(i)={x1,x2,…,xi}，Y(j)={y1,y2,…,yj}，当i=0或j=0时，即其中1个序列为空，则空序列是Xi和Yj的最长公共子序列，故此时C[i][j]=0 2. 其它情况下，由最优子结构性质可建立递归关系如下： 算法设计\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void LCSLength(int m，int n，char *x，char *y，int **c，int **b) { int i，j; //初始化, Y[j]为空时，最小子问题\u0026lt;i,0\u0026gt; for (i = 1; i \u0026lt;= m; i++) c[i][0] = 0; //初始化， X[i]为空时，最小子问题\u0026lt;0,j\u0026gt; for (i = 1; i \u0026lt;= n; i++) c[0][i] = 0; //两重循环，自下而上，计算子问题{X(i), Y(j)} for (i = 1; i \u0026lt;= m; i++) { for (j = 1; j \u0026lt;= n; j++) { if (x[i]==y[j]) { //情况1 c[i][j]=c[i-1][j-1]+1; b[i][j]=1; } else if (c[i-1][j]\u0026gt;=c[i][j-1]) { //情况2 c[i][j]=c[i-1][j]; b[i][j]=2; } else { c[i][j]=c[i][j-1]; //情况3 b[i][j]=3; } } } } 每个数组单元的计算耗时O(1)，算法耗时：O(mn) // 构造最长公共子序列 void LCS(int i，int j，char *x，int **b) { if (i ==0 || j==0) return; if (b[i][j]== 1){ LCS(i-1, j-1, x, b); cout \u0026lt;\u0026lt; x[i]; } //第1种情况下，X(i)和Y(j)的最长公共子序列由X(i-1)和Y(j-1)的解LCS(i-1, j-1, x, b)，加上位于最后的x[i]组成 else if (b[i][j]== 2) LCS(i-1，j，x，b); else LCS(i，j-1，x，b); //其它2种情况下，原问题解等于子问题解 } 过程： 从b[m,n]开始，依其值在数组b中搜索 1. b[i,j]=1, Xi和Yj的最长公共子序列由Xi-1和Yj-1的最长公共子序列，在尾部加上xi得到 2. b[i,j]=2, Xi和Yj的最长公共子序列与Xi-1和Yj的的最长公共子序列相同 3. b[i,j]=3, Xi和Yj的最长公共子序列与Xi和Yj-1的的最长公共子序列相同 算法中，每次递归调用使i或j减一，算法计算时间复杂性为O(m+n) 最大子段和 二维表示：左端i，右端j 一维表示：b[j]，右端j 递归方程：\nb[j] = max{a[j]+b[j-1], a[j]} , 1 \u0026lt;= j \u0026lt;= n 算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxSum(int n, int * a){ int sum = 0; int b = 0; for(int i = 1; i \u0026lt;= n; i++){ if(b \u0026gt; 0){ b += a[i]; }else{ b = a[i]; } if (b \u0026gt; sum){ sum = b; } } return sum; } 0/1 背包 给定n种物品{1, 2, 3, …,n}和一背包，物品i的重量wi，价值为vi，背包的容量为C 应如何选择装入背包的物品，使得装入背包中物品在其总重量不超过背包容量C的前提下，背包中物品的总价值最大？ 最优子结构性质\n设(x1, x2, ... xn)是相对于n种物品{1,2,...,n}的1个最优解，则(x2,...,xn)是子问题{2,3,...,n}的1个最优解，即原问题最优解包括了子问题最优解 子问题1：{1} 子问题2：{2,3,...,n} 假设对于一个最优解 {x1,x2,...xn}，它的子问题{2,...,n}的解不是最优的。因此我们能够对于子问题2找出另一个更优的解{x2',x3',...xn'} 通过新的子问题最优解与原来的子问题1合并，我们得到了更优的问题解，推导出一开始的解不是最优解。这使得假设矛盾，因此该问题具有最优子结构性质 问题表示\n子问题\u0026lt;i, j\u0026gt;的最优值定义为m\u0026lt;i, j\u0026gt; 背包容量为j，可选物品为{i, i+1, ..., n}时，0-1背包的最优值 原问题\u0026lt;1, c\u0026gt;的最优解表示为m(1, c) 状态方程\n根据最优子结构性质，建立计算m(i, j)递归式 边界条件：i == n， 对于只有一个物品 —— 最有一个物品{n}，背包容量为j的子问题\u0026lt;n, j\u0026gt; 对于子问题\u0026lt;i, j\u0026gt;，有 当j的容量小于wi的时候，i物品肯定放不进去了 当j的容量大于等于wi的时候，i物品才有可能放进去， 此时要比较的是把物品置换出来的价值大，还是原来那样大 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // v:价值矩阵 w:重量矩阵, c:背包容量 n:物品总数 m:问题最优解m[i][j] Void Knapsack(Type *v, int w, int c, int n, type **m) { // 比较一下最后一个物品的重量和背包重量谁最小，方便初始化 int jMax= min(w[n]-1,c); // 初始化 for (int j=0; j \u0026lt;= jmax; j++) m[n][j]=0; // 将能放下第n个物品的空间先初始化为第n个物品的价值 for (int j=w[n]; j \u0026lt;= c; j++) m[n][j]=v[n]; for (int i=n-1; i\u0026gt;1; i--) { jMax= min (w[i]-1, c); // 先把放不下的赋值了 for (int j=0; j\u0026lt;=JMax; j++) m[i][j]=m[i+1][j]; // 再把放得下的赋值 for (int j=w[i]; j\u0026lt;=c; j++) m[i][j]=max( m[i+1][j], m[i+1][j-w[i]]+v[i] ); } m[1][c]=m[2][c]; // 根据子问题 \u0026lt;2, c\u0026gt;， \u0026lt;1, c-w[1]\u0026gt;，构造原问题\u0026lt;1, c\u0026gt;的解 if (c\u0026gt;w[1]) m[1][c]=max( m[1][c], m[1][c-w[1]]+v[1]) } 从m(i, j)的递归式容易看出，算法需要O(nc)计算时间 当背包容量c很大时，算法需要的计算时间较多 例如，当c \u0026gt; 2^n 时，算法需要Ω(n*2^n)计算时间 4 贪心法 算法基础(了解)：\n最优子结构性质、贪心选择性质 贪心算法与动态规划算法的差异 要求：面向特定问题的具体算法\n原理，采用的贪心策略 说明/证明问题满足贪心选择性质 步骤，或代码/伪代码 说明/给出时间复杂性 计算示例：针对给定输入，给出算法步骤、执行结果 掌握：\n单源最短路径 背包问题 最优装载问题 贪心选择性质 证明原理：数学归纳法，分两步\nStep1. 存在以贪心选择开始的最优方案，即最...的一定在最优解种 Step2. 每步所作的贪心选择，将问题简化为一个更小的、与原问题具有相同形式的子问题。据此，对贪心选择次数做归纳，可以证明：贪心法产生原问题的最优解 问题的全局/整体最优解可以通过采用一系列局部最优的选择，即贪心选择，来获得\n贪心选择性质是贪心算法可应用于求解问题全局最优解的第一个基本要素，也是贪心算法与动态规划算法的主要区别 确定具体问题是否具有贪心选择性质，须证明\n每一步所作的贪心选择最终导致问题的整体最优解 算法 背包问题 与0-1背包问题类似，但在选择物品i装入背包时，1≤i≤n，可以选择物品i的一部分，即0 ≤ xi ≤1，不要求物品全部装入背包\n但是背包问题具有贪心选择性质，可以用贪心法\n贪心选择性质证明： 首先将所有物品按照vi从大到小排列。问题的解X={x1,x2,...xn}是一个最优解 设k为最先装入背包中的价值最大的物品 当问题有最优解的时候，分两种情况： 1. x1被充分放入 2. x1没有被充分放入。 对于1，当x1被充分放入，已经时最优解了。 对于2，构造可行解Y，选择w1 \u0026lt; W的任意值，其中wi是x1的部分。此时将x1完全放入背包，即y1 = x1。然后根据贪心选择性质，选择单位重量价值次高的物品放入背包，直到背包装满。 由于y1=x1，此时Y的总价值不小于X的总价值，因为我们在构造Y时选择了相同或更高价值密度的物品。 因此，无论x1充分放入与否，都可以构造一个具有相同或更高总价值的解。这证明了分数背包问题具有贪心选择性质。 步骤\n计算每种物品的单位重量价值vi/wi ，作为贪心选择的依据指标 贪心选择策略: 选择单位重量价值最高的物品，将该物品尽可能多地装入背包 若将所选择的物品全部装入背包后，背包内的物品总重量未超过背包容量C，则选择单位重量价值次高的物品，并尽可能多地装入背包 依此策略一直地进行下去，直到背包装满为止 实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // n物品总数，M背包容量， void Knapsack(int n, float M, float v[], float w[], float x[]) { //对n个物品，计算其单位重量价值 v[i]/w[i]；n个物品，按照v[i]/w[i]从大到小重新排序编号！！ Sort(n, v, w); int i; for (i=1; i\u0026lt;=n;i++) x[i]=0; //解向量赋初值 float C=M; //当前可用背包容量C ←初始背包容量M for (i=1; i\u0026lt;=n;i++) { //从单位价值最大的物品开始，依次考虑物品i // 物品i的重量超出当前可用背包容量，结束循环，放入物品i的一部分 if (w[i]\u0026gt;C) break; // 物品i的重量没有超过当前可用背包的容量，将i全部装入 x[i]=1; // 调整当前可用背包容量，减少 c-=w[i]; } //通过for循环中各步骤装入的物品都是整体装入 //如果还有物品没有考虑且背包还有剩余容量(C\u0026gt;0)，将剩余容量分配给物品i if (i\u0026lt;=n \u0026amp;\u0026amp; C \u0026gt;0) x[i]=c/w[i]; } 算法knapsack的主要计算时间在于将各种物品依其单位重量的价值从大到小排序, 因此算法的计算时间上界为 O(nlogn) 最优装载问题 问题描述\n有n个集装箱要装上一艘载重量为C的轮船，其中集装箱i的重量为wi 要求\n装载体积不受限制的情况下，将尽可能多的集装箱装上轮船，且装载的集装箱总重量不超过C 优化目标：装载的集装箱数目极大化 约束条件：装载重量受限 算法描述\n贪心选择策略：先装重量最轻的，剩余重量空间最大化，以容纳更多的其它或物，可产生最优装载问题的最优解 贪心选择性质的证明（证明优先将最轻的放入能不能得到最优解）\n设集装箱已经按重量从小到大排序，X={x1, x2, ..., xn}是最优装载问题的一个最优解 设k为最先装入箱中的最轻货物 当问题有最优解（有可能是非贪心策略解）时，分两种情况 1. 当k=1，即最轻的第一个货物被装入，货物选择的放入顺序符合贪心策略，{x1，x2，...，xn}是满足贪心选择性质的一个最优解。 x1=0 2. 当k\u0026gt;1，即最轻的集装箱1没有被装入。此时，按如下方式从{x1,x2,...xn}构造出一个满足贪心策略的最优解Y={y1,y2,...yn}，y1=1 i. 对k，其中1\u0026lt;k\u0026lt;n, yk=1, 取y1=1，yk=0，将第1个集装箱放入，第k个集装箱拿出，即用第1个集装箱替换原方案中最轻的集装箱，而第1个集装箱比第k个集装箱更轻，即w1\u0026lt;=wk ii. yi=xi, 1\u0026lt;=i\u0026lt;=n, i≠k，其他集装箱是否被放入仍保持不变 新方案仍满足容量约束条件，因此新方案是满足贪心策略的可行解。需进一步判断装入的集装箱数是否最多? 由于 yi的总和 = xi的总和，集装箱数量一样。说明第2个方案Y={y1, y2, ..,yk, …, yn}具有与最优方案X一样的装箱数。 所以：优先将最轻的第1个集装箱装入可以使得装载的总箱数最大化！ 综上所述，Y是一个满足贪心策略的最优解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // X是解向量，w是重量向量，c是总装载量，n是集装箱总数 void Loading(int x[], Type w[], Type c, int n) { int *t = new int [n+1]; // 对n个集装箱，按照重量w[i]从小到大重新排序并排列编号，结果放在t中 // t放的是w从小到达排序的编号 Sort(w, t, n); //解向量赋初值 for (int i = 1; i \u0026lt;= n; i++) x[i] = 0; // 在有剩余容量的情况下，从轻到重，装入各个集装箱 for (int i = 1; i \u0026lt;= n \u0026amp;\u0026amp; w[t[i]] \u0026lt;= c; i++) { x[t[i]] = 1; c -= w[ t[i] ]; } } 单源最短路径 问题描述\n给定带权有向图G =(V, E)，V={1, 2, 3,..., n}, 其中每条边的权c[i][j]是非负实数 给定V中的一个顶点v，称为源 要求: 计算从源v到所有其它各顶点j∈V-{v}的最短路径长度\n路径长度：路径上各条边的权之和 Dijkstra算法: 贪心算法求解单源最短路径\n算法原理\n1. 设置集合S={i}⊆V，记录已经得到最短路径的顶点i（已经求出v至i的最短路径） 顶点i∈S，当且仅当从源v到该顶点i的（全局）最短路径已知 初始时，S中只有源点v 2. 对图G(V, E)中某一个顶点u∈V，将从源v到u且中间只经过S中的顶点的路径称为从源点v到u的特殊路径，用数组dist记录v到图中各点u的特殊路径长度，记为dist[u] v到u的特殊最短路径，长度dist[u] 从v到u、中间只经过S中的顶点 v到u的全局最短路径，长度d(v,u) d(v,u) ≤ dist[u] 可能经过不在S中的顶点，如k 3. 采用贪心选择策略，从V-S中挑选具有最小dist[uk]的顶点uk，将uk加入S，S={uk}∪S S0={v}, S1={v, u1}, …, Sn={un-1}∪Sn-1 4. 当S=V时，获得源点v至图中全部其它n-1个顶点的最短路径，算法结束 贪心策略\n扩展集合S时，从V-S中取出具有最短特殊路径长度dist[u]的顶点u，将u添加到S中 S发生改变，对数组dist应作必要修改，重新计算v到S外(?)各点u的dist[u] 算法例子及步骤 算法复杂性O(n2)\n算法主循环体需要O(n)时间，这个循环需要执行n-1次，所以完成循环需要O(n^2)时间 算法的其余部分所需要时间不超过 O(n^2) 贪心选择性质证明\n首先知道该算法的贪心选择策略：循环/迭代计算中每一步，从V-Si中选择具有最短特殊路径dist[u]的顶点u，加入Si得到Si+1 为了证明贪心选择性质，需要证明： 对任意已经在Si中的顶点u，从v开始、经过G中任意顶点到达u的全局最短路径的长度d(v, u) = 从v开始、只经过Si中顶点到达u的最短路径的长度dist(u)：u一旦放入S，dist[u]就是d(v,u) 即证明：不存在另一条v到u的全局最短路径，该路径上某些节点x不在V-S 中，且该路径长度d(v,u)\u0026lt;dist[u] 使用反证法，假设 在迭代求解的过程中，顶点u是遇到的集合S中第1个满足d(v,u)\u0026lt;dist[u]的顶点，即d(v,u)≠dist[u]且全局最优路径经过S之外的顶点 从v到u的全局最短路径上，经过的第1个属于V-Si的顶点为x 对v到u的全局最短路径d(v ,u) ，根据d(v, x) + distance(x, u) = d(v ,u) ，由于distance(x, u) \u0026gt;0，有 d(v, x) \u0026lt; d(v ,u) 进一步地，根据假设d(v,u) \u0026lt; dist[u], 有 d(v, x) + distance(x, u) = d(v ,u) \u0026lt; dist[u] 由于distance(x, u) \u0026gt;0, 因此 dist[x]= d(v, x) ≤ d(v,u)= d(v, x) + distance(x, u) \u0026lt; dist[u], 即 dist[x] \u0026lt; dist[u] 但是根据路径p构造方法，在下图所示情况下，u、x都在集合Si之外，即u、x都属于V-Si，贪心选择S外顶点时，u被选中，并没有选x，根据扩展Si的原则：选dist最小的顶点加入Si，说明此时 dist[u] ≤ dist[x] 这与 前面推出的 dist[x]\u0026lt; dist[u] 相矛盾 算法实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 double* dijkstra(double **graph, int v, int n){ // 初始化 s 集合，只有一个起始点在里面 bool * s = new bool[n]; double * dist = new double[n]; for(int i = 0; i \u0026lt; n; i++){ dist[i] = graph[v][i]; s[i] = false; } // 先将起始点放入S中 s[v] = true; dist[v] = 0; // 进行最短路径算法 for(int i = 0; i \u0026lt; n; i++){ // 考虑原点v之外的其他点u，对于不同规模Si，逐步扩展 int temp = MAXINT; int u = v; //选取s外具有最小dist的点 for(int j = 0; j \u0026lt; n; j++){ if(!s[j] \u0026amp;\u0026amp; dist[j] \u0026lt; temp){ u = j; temp = dist[j]; } } s[u] = true; for(int j = 0; j \u0026lt; n; j++){ if(!s[j] \u0026amp;\u0026amp; graph[u][j] != MAXINT \u0026amp;\u0026amp; dist[j] \u0026gt; graph[u][j]+dist[u]){ dist[j] = graph[u][j] + dist[u]; } } } return dist; } 5 回溯法 要求：面向特定问题的具体算法\n原理 解向量，剪枝函数设计 步骤，或代码 说明/给出时间复杂性 计算示例：针对给定输入，画出搜索/剪枝过程及解空间树，给出执行结果 掌握\n0/1背包 旅行商问题TSP n皇后问题，图的m着色问题 算法 TSP 定义：\nt: 递归深度，当前解在解空间树中深度. 初始时，t=1, e.g. 结点B, t=2 f(n,t), g(n,t)：当前扩展结点处(e.g B)未搜索的子树的起始编号、终止编号, e.g. t=2, f(n,t)=C, g(n,t)=E h(i): 当前扩展结点处的第i个可选值，e.g. h(i)=C, D, E constraint(t): 当前扩展结点处的约束函数，e.g. 不允许城市重复出现；判断当前结点是否满足约束，决定是否舍弃当前结点对应分支 bound(t): 当前扩展结点的限界函数，用于判断当前结点是否越界，决定是否舍弃当前结点对应分支 剪枝条件\n1. 如果当前正在考虑的顶点j与当前已经在走过的部分路径末端结点i 没有边相连，即w[i, j] = ∞ ，则放弃搜索j所在分支 2. 令到第i层结点为止，构造的部分解路径为 \u0026lt;1, x[2], x[3],…, x[i-1], x[i], ?, ? , ?\u0026gt;, 该路径的权值总和 大于 bestw —— x[i] 无希望达到更优的路径，则停止搜索x[i]分支及其下面的层。bestw表示目前为止，找到的最佳完整回路的权和 当前已有的部分路径为\u0026lt;1,2, ?, ?\u0026gt;, 路径末端结点为2 根据路径组成规则，下一步可考虑n-2=2个顶点：顶点3、4，加入到部分路径中 但是，顶点2与4间无边，w(2,4)= ∞ 变量定义\nbestx[1:n]记录最佳路径 cw:当前已经走过的部分路径总长 x[1:n]搜索过程中生成的部分路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void backTrackTSP(i){ // 如果搜索到达叶节点，还没有考虑的城市只有x[n]，因此只能选择最后一个城市x[n] if(i == n){ // 最后一个城市与前一个城市相连，与第一个城市相连，并且路径更优 if(w(x[n-1],x[n]) != MAXINT \u0026amp;\u0026amp; w(x[n],1) != MAXINT \u0026amp;\u0026amp; (cw + w(x[n-1], x[n]) + w(x[n], 1) \u0026lt; bestw)){ // 更新最优路径及长度 for(int j = 1; j\u0026lt;= n; j++){ bestx[j] = x[j]; } bestw = cw + w(x[n-1], x[n]) + w(x[n], 1); } }else{ // 如果没有到达叶节点, 已有部分解，依次考察下一步x[i]的可能取值j for(int j=i; j\u0026lt;=n;j++){ if(w(x[i-1],x[j])!=MAXINT \u0026amp;\u0026amp; cw+w(x[i-1],x[j]\u0026lt;bestw)){ swap(x[i], x[j]) cw += w(x[i-1], x[i]) backTrack(i+1); cw -= w(x[i-1], x[i]) swap(x[i], x[j]); } } } } 排列树问题\n从n个元素组成的集合中，找出满足某种性质的n个元素的排列，构成问题解 排列树一般有n!个结点，树遍历时间Ω(n!)\nn-后问题 问题描述\n1）在n×n格的棋盘上，放置n个彼此不受攻击的皇后 2）按照国际象棋的规则，任何2个皇后不放在同一行或同一列或斜率为±1的同一斜线上 设计解向量\nX[i]表示第i行的皇后处在第几列 X= 4 6 8 2 7 1 3 5 约束\n1. 1 ≤ xi ≤ n, 即xi = 1,2, … ,n, 每个皇后只能位于1～n列 2. 1）任意2个皇后不同列： xi ≠ xj 2）任意2个皇后不处于同一正、反对角线：|i-j| ≠ |xi-xj| 迭代非递归回溯法\n1. 外层循环依次考虑1,2,…,n个皇后，对应棋盘上的1,2,…,n行 2. 内层循环对选定了行位置的皇后k，考虑应放置的列位置x[k]是否与1,…,k-1发生冲突 约束函数设计\n1. 判断部分解是否满足显式、隐性约束 2. 测试当前部分解中的皇后所处位置是否合适 对皇后k，当将其放置在第k行、x[k]列时，是否与前面已经放置好的皇后1、2、3、k-1相冲突——为第k个皇后选择合适列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // x[] 为包含皇后1，2，...k-1，k位置的1个部分解 bool place(x[], int k){ // 判断第k个皇后与前面位置是否冲突 for(int i = 1; i\u0026lt;k ;i++){ // 不能在对角线，不能同一列 if(abs(k-i) == abs(x[i]-x[k]) || x[i] == x[k]) return false; } return true; } // n：皇后个数，x[]：解向量 void nQueens(int n, int x[]){ x[1] = 0; int k = 1; // 外层循环，负责依次安排皇后1，2，...k，...，n的位置，本次循环安排第k个皇后 while(k \u0026gt; 0){ x[k] = x[k] + 1; // 内层循环，为第k个皇后选择合适的位置 while(x[k]\u0026lt;=n \u0026amp;\u0026amp; !place(x,k)){ // 如果当前位置有冲突，继续搜索下一个位置 x[k] = x[k] + 1; } if(x[k] \u0026lt;= n){ // 为第k个皇后搜索到了合适的列 if(k == n) // 最后一个皇后，可以了 break; else{ // 如果不k不是最后一个皇后，为继续搜索下一个k+1皇后做准备 k ++; x[k] = 0; } }else{ // x[k] \u0026gt; n，说明当前分支不能走了，要回退一个 x[k] = 0; //置空 k--; //回溯上一层，重新选择x[k-1] } } } N后问题属于排列树问题 回溯法最坏情况下的复杂性是O(n!) 算法由2层循环组成，算法运行时间与外部循环执行次数和内部循环体place函数的执行次数有关 每访问搜索树中的1个结点，就执行一次。 因此，算法运行时间取决于它所访问的结点个数c——搜索树的size 因此，计算约束方程的总次数为O(cn)，c是动态生成的，一般为n的多项式（见后面例子） 图的m着色问题 地图着色问题转换为图着色\n以地图中的区域作为图中顶点，2个区域如果邻接，则这2个区域对应的顶点间有一条边，即边表示了区域间的邻接关系 给定无向连通图G=(V, E)和m种不同的颜色, 用这些颜色为图G的各顶点着色，每个顶点着一种颜色 约束：相邻边不同着色 目标：使用的颜色尽可能少 图的m可着色判定问题\n是否有一种着色法，只使用m种颜色，使G中每条边的2个顶点着不同颜色？ 图的色数\n如果一个图最少需要m种颜色才能使图中每条边连接的2个顶点着不同颜色，m为该图的色数 问题的解空间\n给定n个顶点的图G=(V, E)，m种颜色, 解向量 x[1:n]=(x1, x2, … , xn) x[i]表示顶点i所着颜色 顶点i的颜色取值范围为1,2,...,m即x[i]∈{1,2,...,m} 搜索过程形成高度为n的完全m叉树 在第i层，i=0,1,..,n-1, 有mi个结点 约束函数：\n相邻结点不能着色相同，即x[i]≠x[j]，如果顶点i与顶点j邻接 数据结构设计\nint n 顶点个数 int m 最大颜色数 int x[n] 各顶点的着色 bool a[n][n] 图中顶点邻接矩阵，a[k][j] == 1表示k与j相邻 测试函数\nok(int x[], int k, bool a[][], int n) 假设当前已经对顶点1, 2, 3,…, k-1进行了有效可行（满足约束条件）的着色，考察顶点k，判断是否可将k着色为x[k] \u0026lt;x1, x2, xk-1, xk?, ?, ?, ?...\u0026gt; 要求： xk与之前的x1, x2, xk-1不冲突，即相邻顶点颜色不同 1 2 3 4 5 6 7 8 bool ok(int k){ for(int j = 1; j \u0026lt; k; j++){ // 邻接，且冲突 if(a[k][j] == 1 \u0026amp;\u0026amp; x[j] == x[k]) return false; } return true; } 算法设计\n2层循环： 1. 外层循环依次考虑不同顶点1, 2, ..., k,..., n 2. 内层循环为外层循环选定的顶点选择合适颜色：1,2,...,m 调用ok函数，测试当前顶点k的着色是否与已经着色的1,2,...,k-1的颜色想容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void m_coloring(int n, int m, bool a[][], int x[]){ int i, k; // 初始化 for(i = 1; i \u0026lt;= n; i++){ x[i] = 0; // 未着色 } x[i] = 0; k = 1; while(k \u0026gt;= 1){ x[k] = x[k] + 1; // 为顶点选择下一个颜色，从第一种颜色开始 while(x[k] \u0026lt;= m \u0026amp;\u0026amp; !ok(k)){ // 如果顶点k当前着色x[k]不合适 x[k] = x[k] + 1; } // 前面步骤为顶点k找到了合适的着色，如果没有，x[k] \u0026gt; m if(x[k] \u0026lt;= m){ // 当前顶点是最后一个 if(k == n) break; // 不是最后一个，判断下一个顶点 else k = k + 1; }else{ // 前面步骤没有为k找到合适着色，需要回溯 x[k] = 0; // k 回溯 k --; } } } 掌握 搜索树画法 复杂性分析\n对于每一个非叶节点，在最坏情况下，用OK检查当前扩展结点的每一个子节点所相应的颜色可用性, 需耗时O(mn) 该非叶节点对应的图中顶点与其它最多n-1个顶点均相邻，需要考察m种颜色 0-1 背包问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void backtrack(int t){ if(t \u0026gt; n) output(x); // 这里可以更新最优值 else{ for(int i=0; i \u0026lt;=1; i++){ x[t] = i; // 如果满足约束条件，就向下搜索 if(constraint(t) \u0026amp;\u0026amp; bound(t)) // 只要重量不超过背包载重量，就可以 backtrack(t+1); } } } 搜索树如下 n=3, 解向量\u0026lt;x1,x2,x3\u0026gt;, 4层 子集树的叶结点数目：2^n=2^3 全部树结点数目： 2^(n+1) -1 =2^(3+1) -1=15 子集树特征\n子集树的叶结点数目：2^n 全部树结点数目：2^(n+1) -1 算法复杂性：Ω(2^n) 6 分支限界法 要求：面向特定问题的具体算法\n原理 问题解上下界估计，非叶节点上界ub或下界lb估计 算法框架/步骤，或代码/伪代码，C/C++/Java/Python 说明/给出时间复杂性 计算示例：针对给定输入，画出搜索/剪枝过程及解空间树，给出执行结果 掌握\n0-1 背包 旅行商问题TSP 算法 分支限界法解空间书及搜索/扩展过程\n扩展结点 从活结点表ANT中（根据某种准则，e.g. bound值最大、最小，价值最大）筛选出来、当前准备进行扩展的结点，即当前进行处理的结点 1. 评估每个活结点的价值，按照价值最大/小化原则，从ANT表中选取扩展结点e_node 2. e_node 扩展方式： (1) 宽度优先，即生成e_node的全部子结点 (2) 评估这些子结点，满足界限约束，有可能产生更优解的结点被称为活结点，加入ANT (3) 不满足约束、或无法产生最优解的子结点被舍弃 3. e_node 结点被扩展后，该结点转换为死节点，以后将不会被再搜索 活结点 -\u0026gt; 扩展结点 -\u0026gt; 死结点 算法框架\n1. 根据初始结点，确定函数的上下界[down, up] 2. 将活结点表ANT初始化为空 3. 生成根节点v0的全部子结点——宽度优先 对每个子结点v，执行以下操作 (1) 估算v的目标函数值 bound(v) (2) 若目标函数值 bound(v) 不超过界限，将v加入ANT表 (最大化问题bound是上界，bound \u0026gt;= down；最小化问题bound是下界，bound \u0026lt;= up) 4. 循环，直到某个叶节点在目标函数值在表ANT中最大 (1) 从ANT中选择bound最大的结点vi，扩展其子结点 (2) 对vi的每个子结点c，执行下列操作 i. 估算c的bound ii. 如果bound满足约束，将c加入ANT iii. 如果c是叶节点 并且 bound(c) 在表中最大 则将叶节点c对应的完全解输出，算法结束 iv. 如果c是叶节点，但是bound(c) 在表ANT中不是最大 更新界限 删除ANT中不满足新界限的结点 旅行商问题 搜索空间树\nTSP 的上下界\n1. 利用贪心法 + 回溯 计算上界up 以起始城市1作为出发城市，每次从当前出发城市发出的多条边中，选择没有遍历过的最短边连接的城市，作为下一步达到城市，即：选择离当前出发城市最近的城市作为下一步出发城市 2. TSP 下界down (1) 矩阵中每一行的最小元素相加 —— 从每个城市走向下一个最近城市 (2) 在一条路径上，每个城市i有2条邻接边：进入该城市、离开该城市 第i个城市对应矩阵中第i行 将每一行最小的2个元素相加除以2，并向上取整，得到一个更合理的下界 3. 对于某个结点的下界down 剪枝\n对TSP等最小化问题，在问题求解过程中，如果1个部分解的目标值dist的下界估计值lb，超出问题完整解的上界，则该部分解对应了死结点，可剪枝 算法步骤\n1. 采用贪心法，计算问题上界up —— 用于后续结点剪枝 2. 将活结点ANT表置空 3. for(i = 1; i \u0026lt;= n; i++) x[i] = 0; // 解向量初始化 4. k = 1; x[1] = 1; // 从顶点1 出发 5. while( k \u0026gt;= 1) 5.1 i = k+1 ; 5.2 x[i]=1; 5.3 while(x[i] \u0026lt;= n) // 宽度优先，生成x[k] 的子结点x[i] = 1,2,...,n 5.3.1 if( 路径上城市顶点不重复 ) 5.3.1.1 计算x[i] 的下界lb 5.3.1.2 if (lb \u0026lt;= up) 将路径上的顶点和lb值存入活结点表ANT 5.3.2 x[i] = x[i] + 1; // 依次生成x[i] = 1 的各个兄弟结点 5.4 if(i == n \u0026amp;\u0026amp; bound(i)是ANT中所有叶节点中最小的) output(x) 5.5 else if(i == n) 更新上界 up = minlb 删除ANT表中bound(vi) \u0026gt; up的结点 5.6 k = 表ANT中lb最小结点中，已得路径上的顶点个数 0-1 背包问题 问题\nn个物品{1, 2,…, n}，重量w[1: n]，价值v[1: n]，背包容量C 4个物品，重量(4, 7, 5, 3 )，容量C=10， 价值(40, 42, 25, 12) 按照单位价值最大化排序 搜索树\n二分搜索树，依次考虑物品1, 2, 3, 4, …, n是否放入 k=0层：对应根节点，未考虑任何物品，部分解S={?, ?, ?, ?} k\u0026gt;0层： 物品1, 2, …, k-1已经确定是否放入， 部分解S={x1, x2, …, xk-1, xk?, ?, …, ?}中的x1, x2, ..,xk-1的值已经确定 考虑第k个物品是否放入，确定xk?，左分支→放入，右分支→不放入 界限函数\n下界down 贪心法，第1个可装入的、具有最大价值/重量比的物品所具有的价值 上界up 背包中全部装入第1个物品，且装满 对第k\u0026gt;0层（k=1,…,n）结点，代表对物品1~k-1已作出选择（装入、不装入），假设已经装入的物品总重量为w，获得的总价值为v，该结点的限界函数ub = 已装入背包中物品取得的价值v + 背包剩余容量(C-w)*剩余物品中的最大单位重量价值 ","date":"2024-09-20T09:23:06+08:00","permalink":"https://ffirestorm.github.io/p/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E5%A4%A7%E4%B8%89%E4%B8%8A/","title":"算法设计与分析 大三上"},{"content":"Chapter 2 关系r在数据库中是有限集合\n属性元组是无序的\n多个属性可能会有同一个domain\n对于每一个domain来说，null都是其中一个member\n超键用来区分某一行，候选键是最小的超键。主键是其中一个候选键，主键上的属性是主属性。\nQuery Language 语言有两类：\n1. procedual，过程化的 2. non-procedual， 非过程化的（SQL） Pure language：\n1. relation algebra 关系代数 2. tuple relational calculus 元组关系演算 3. domain relational calculus 域关系演算 纯语言在实际使用中构成了查询语言的基本基础\n关系代数操作 是过程化的\n6个关系代数操作：\n1. 选择 σ 2. 投影 Π 3. 笛卡尔积 Cartesion product X 4. 并 ∪ 5. 集合差 - 6. 自然连接 找到所有 上过所有生物相关课 的学生：\n1. 首先得找到所有的 学生-课程 对应关系 —— (1) 2. 找到所有 生物 相关的课程 —— (2) 3. 找到所有 上过课的学生 —— (3) 4. 用 (2) X (3) 得到的是所有学生和所有生物课的对应关系表 —— (4) 5. (4) 和 (1) 的相同表项就是那些学生和某个生物课的 对应关系 6. 将 (4) - (1)，会使得所有真正的 某个学生-某个生物课 的关系被删掉。 (5) 7. 上过所有生物课的学生就不在 (5) 表中了，但是那些只上过一部分生物课的学生还会在(5) 中 8. 因为这个时候存的是学生和他们没上过的生物课的对应关系，将这些学生投影出来 9. 最后用所有的上过课的学生减掉这些学生，就得到所有的上过所有生物课的学生 Chapter 3 SQL SQL的三种用途：\n1. data definition DDL，定义 2. query 查询 3. manipulation、modification，更改数据库 history\nsql 是基于relationla algebra关系代数和tuple relational calculus元组关系演算的 parts in SQL\n1. DDL：define、delete、modify on schemas、views、index；views definition 2. DML：query、insert、delete、update on tuples 3. integrity：integrity constraints 4. transaction management 5. authorization 6. embedded and dynamic SQL DDL create table/view：the schema for each relation or view the domain of values associated with each attribute，定义作用域 integrity constrains 定义一致性约束 index 定义索引 security，autorization 安全性和权限 physical storage structure of each relation on disk 物理存储结构 模式定义： 建表\n1 2 3 4 5 6 7 8 9 create table instructor( ID char(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8,2), primary key(ID), -- 主键一定非空 foreign key(dept_name) references department, check(salary \u0026gt; 0) ); insert into \u0026rsquo;tablename\u0026rsquo; values (\u0026hellip;)\ndelete from \u0026rsquo;tablename\u0026rsquo; \u0026lsquo;筛选条件\u0026rsquo;\n如果是delete from \u0026rsquo;tablename\u0026rsquo; 那就会将里面所有的元组都保留，只剩一个表结构\ndrop table：删除整个表里的所有元组，还有表本身\n和delete from table 区分开来。drop更为彻底\nalter table r add A D : 用来添加属性列，A是属性名，D是A的domain\nalter table r drop A : 用来删掉某一列，A是属性名\n总结：delete用来删某些元组（行），drop用来删表，alter用来修改表的结构\nselect query distinct：\n1 2 select distinct dept_name from instructor 可以在select子句中加入算数运算\n1 2 select salary/12 from instructor 可以给查询到的结果属性改名\n1 2 select id, salary/12 as monthly_salary from instructor from 语句连接表时，一定要在where子句中加入连接条件，不然多表笛卡尔积操作耗时费力\n查询中临时修改表名\n1 2 3 select distinct T.name from instructor as T, instructor as S where T.salary \u0026gt; S.salary and S.dept_name = \u0026#39;Comp.Sci\u0026#39; 字符串匹配\n% 匹配任意子串 _ 匹配任意一个字符 用escape 来声明转移符号 1 2 3 select name from instructor where name like \u0026#39;%100\\%\u0026#39; -- 匹配后缀为100%的字符串 排列\n1 2 3 select distinct name from instructor order by name, dept_name -- 默认升序 asc，先按name排列，相同name的按dept_name排 1 2 3 select name from instructor order by name desc 连接\n1 2 SELECT * FROM table1 AS t1 JOIN table2 AS t2 ON t1.A = t2.C AND t1.B = t2.D; 集合操作\n并 union 交 intersect 差 except 找到最大的salary of all instructors\n找不是最小的 找到所有的薪水 2 - 1 1 2 3 4 5 6 7 8 select distinct salary from instructor except select distinct T.salary from instructor as T, instructor as S where T.salary \u0026lt; S.salary 聚集函数\n聚集函数一般忽略空值\n但是count(*)也会把含有空值的元组计算进去\navg min max sum count 1 2 3 4 5 select {A1, A2...Ai} , ag_fun(Ai+1), ... , ag_fun(Ai+k) from r1, r2, ... ,rm where P1 group by A1, A2,..., Ai having P2 1 2 3 4 5 6 7 8 SELECT D.deptID, COUNT(E.employeeID) AS totalEmployees, SUM(CASE WHEN E.salary \u0026gt; 4000 THEN 1 ELSE 0 END) AS employeesAbove4000 FROM Department D JOIN Employee E ON D.deptID = E.deptID GROUP BY D.deptID HAVING COUNT(E.employeeID) \u0026gt;= 10 ORDER BY D.deptID DESC; select 中 聚合函数之外的属性必须按组显示，不能单独查一个不在group by 中的属性和一个聚合函数 错误例子：\n1 2 3 select dept_name , id, avg(salary) -- 错误，id不能查 from instructor group by dept_name 删掉id才能查询成功，因为只能查询同组的信息\n嵌套 nested subqueries\nsubqueries o经常 nested 在 where子句 或 having子句 或 from子句\n1 2 3 4 5 6 7 8 9 select distinct course_id from section where semester = \u0026#39;Fall\u0026#39; and year=2009 and course_id not in( select course_id from section where semestor=\u0026#39;Sqring\u0026#39; and year=2010 ) ; 嵌套查询会导致嵌套的子句被执行多次，实际使用中，应尽量避免\nsome 修饰符\n1 2 3 4 5 6 7 select from where salary \u0026gt; some( select from where ) 查询的结果要求大于嵌套中的某一个值就行\nall 修饰符\n同理，跟some差不多\nexists，not exists and except\n对于一个关系r来说，这三个修饰符代表的含义如下：\nexists r \u0026lt;==\u0026gt; r 不为空 not exists r \u0026lt;==\u0026gt; r为空 X except Y \u0026lt;==\u0026gt; X - Y 如果 X - Y = 空 \u0026lt;==\u0026gt; Y 包含 X，X是Y的子集 1 2 3 4 5 6 7 8 9 select course_id from section as S where semester = \u0026#39;Fall\u0026#39; and year = 2009 and exists( select * from section as T where semester = \u0026#39;Sqring\u0026#39; and year = 2010 and S.course_id = T.course_id -- 这里的S是在外部查询语句中声明的，是代表这个是对应于某个特定的S，当前查到的S ); 找到所有 上过所有生物相关课 的学生\n找到生物部门开的所有课 将某一个学生上过的所有课都列出来 两个集合，X - Y 如果为空集，说明 X 是 Y 的子集。所以如果1-2为空，那么说明这个学生上过所有的生物部门开的课 检查1-2是否为空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 select distinct S.ID, S.name from student as S where not exists( ( select course_id from course where dept_name = \u0026#39;Biology\u0026#39; ) except ( select T.course_id from takes as T where S.ID = T.ID -- S.ID 是当前外部查询语句查询到的这个学生 ) ) unique 如果作为参数的子查询结果中无重读元组，则unique返回true\n在from子句中也可以嵌套查询\nwith 子句，用来定义一个临时的关系\n找到所有薪水最高的部门\n先找到最高的薪水，然后再找到薪水等于这个的部门\n1 2 3 4 5 6 7 8 9 with max_budget(value) as ( select max(budget) from department ) select department.name from department, max_budget where department.budget = max_budget.value; 一个with子句可以构建多个临时表\n1 2 3 4 5 6 7 8 9 with view1(A1, A2...) as ( select... from where... ), view2(B1, B2...) as ( select... from... where... ) modification delete: 用来删除某些特定行\n注意：删除中若是使用聚集函数，比如avg等，会使让avg在删除时改变\n解决办法：提前计算出聚集函数的值，然后再删除\ninsert：添加元组\n1 2 3 4 5 6 7 8 -- 添加所有instructor到学生表，并把最后一项置零 insert into student select id, name, dept_name, 0 from instructor; -- 添加某行特定元素 insert into course values(\u0026#39;CS-437\u0026#39;, \u0026#39;DBS\u0026#39;, \u0026#39;Comp.Sci\u0026#39;,4); update，可以使用case when 的语句\n1 2 3 4 5 6 update instructor set salary = case when salary \u0026lt;= 10000 then salary * 1.05 else salart * 1.03 end; update中的标量子查询\n1 2 3 4 5 6 7 8 9 10 -- 更新所有学生的学分 update student S set tot_cred = ( select sum(credits) from takes, course where takes.course_id = course.course_id and S.ID = takes.ID and takes.grade \u0026lt;\u0026gt; \u0026#39;F\u0026#39; and takes.grade is not null ); update中的多表操作\n1 2 3 4 update student as A set grade=B.grade from Sgrade as B where A.S## = B.S## and A.C#=B.C#; Chapter 4 4.1 join expression 首先要区分：外连接和内连接\n外连接：如果指明了两个Table的A和B属性相等才能连接，那么最终连接结果会少掉一列B。\n内连接：加入两个Table的A和B属性相等才能连接，最终结果会同时保留A和B\n之后再搞懂左外连接、右外连接、全连接\n对于上图，上左下右，用id连接\n外连接：左外连接，右外连接\n左外连接：\n1 语文 null null 2 数学 70 2 3 英语 80 3 右外连接：\n2 数学 70 2 3 英语 80 3 4 null 90 null 内连接\n内连接可以用不同名称的两个属性相连。\n2 数学 70 2 3 英语 80 3 自然连接\n基本和内连接一样，但是要求连接的列名称一样\n4.2 views views 是一个虚拟表，可以用多个表来建立。\n只有views的定义存在DBS中，里面的元组都是存在相应的数据表中。\n1 2 3 4 5 6 7 create view faculty as select id, name, dept_name from instructor; select name from faculty where dept_name = \u0026#39;CS\u0026#39;; view的定义可以用其他的views。它还支持递归recursive，就是用自己来定义自己\nview1 depend on view2 表示view2 间接或直接的决定了view1\nview1 depend directly on view2 表示view2 直接的决定了view1\nview也可以更新数据行，\n（1）使用INSERT语句向数据表中插入数据时，用户必须有插入数据的权利。 （2）由于视图只引用表中的部分字段，所以通过视图插入数据时只能明确指定视图中引用的字段的取值。而那些表中并未引用的字段，必须知道在没有指定取值的情况下如何填充数据，因此视图中未引用的字段必须具备下列条件之一。 该字段允许空值。 该字段设有默认值。 该字段是标识字段，可根据标识种子和标识增量自动填充数据。 该字段的数据类型为timestamp或uniqueidentifier。 （3）视图中不能包含多个字段值的组合，或者包含使用统计函数的结果。 （4）视图中不能包含DISTINCT或GROUP BY子句。 （5）如果视图中使用了WITH CHECK OPTION，那么该子句将检查插入的数据是否符合视图定义中SELECT语句所设置的条件。如果插入的数据不符合该条件，SQL Server会拒绝插入数据。 （6）不能在一个语句中对多个基础表使用数据修改语句。因此，如果要向一个引用了多个数据表的视图添加数据时，必须使用多个INSERT语句进行添加。 4.3 transactions 4.4 integrity constraints primary key not null unique check(p) check (semester in (\u0026lsquo;Fall\u0026rsquo;,\u0026lsquo;Winter\u0026rsquo;,\u0026lsquo;Spring\u0026rsquo;,\u0026lsquo;Summer\u0026rsquo;))\n参照完整性约束\n添加级联操作\n1 2 3 4 5 6 7 8 create table course( ... dept_name varchar(20), foreign key(dept_name) references department on delete cascade on update cascade, ... ); 4.5 sql data types and schemas date \u0026lsquo;2017-7-27\u0026rsquo;\ntime \u0026lsquo;09:00:30.75\u0026rsquo;\ntimestamp : date + time\n\u0026lsquo;2017-7-27 09:00:30.75\u0026rsquo;\ninterval period of time\nintercal \u0026lsquo;1\u0026rsquo; day = \u0026lsquo;2017-7-27\u0026rsquo;-\u0026lsquo;2017-7-28\u0026rsquo;\ncast e as t: 将一个字符串e转换成type t\ncast \u0026lsquo;2017-07-20\u0026rsquo; as date\nextract : 对于一个day 或 time 的值d，里面的某个范围可以被提取出来\nextract(year from 2017-09-20) = 2017\n大对象类型\nblob 二进制大型对象 clob 字符大集合 注意：当一个query返回一个大对象时，是返回的指针而不是对象本身\n用户自定义数据类型\ncreate type T as \u0026hellip;\n用户自定义domains\ncreate domain D char(20) not null\n可以在创建表时给某一属性添加default values\n1 2 3 4 create table table1( id varchar(5), name varchar(6) default \u0026#39;0\u0026#39; ); 索引创建:\ncreate index idx on table(A)\n4.6 authorization 添加权限\ngrant \u0026lt; privilege list \u0026gt; on \u0026lt; relation name or view name \u0026gt; to \u0026lt; user list \u0026gt;\nprivileges:\nselect insert update delete all privileges 撤销权限\nrevoke \u0026lt; privilege list \u0026gt;\non \u0026lt;relation name or view name\u0026gt;\nfrom \u0026lt; user list \u0026gt;\ncreate role\nChapter 5 从编程语言访问SQL User \u0026ndash; DBMS \u0026ndash; DB file\nUser 和 DBMS之间，通过API，比如ODBC、JDBC、embedded SQL，通过SQL语句\nJDBC ：java\nODBC : c , c++, c## , viual basic\nADO.NET sit on top of ODBC\nJDBC 还可以查看元数据metadata，查看某个数据的名字、类型等等\\\n打开连接 创建SQL 对象 通过2的对象发送语句，获取信息 错误处理 ODBC通过driver来适应不同厂家数据库的物理结构，每个厂家有一个driver\nEmbedded SQL\n优点：交互式只能进行DB访问，不能对DB访问结果进一步的数据处理，而Embedded sql 将SQL的数据库访问功能与C语言等宿主语言的数据处理能力相结合，提高了数据应用系统的能力\n函数和过程构建 函数、存储过程 预先生成对应的查询执行计划（类似于目标代码），存储在DBMS中，应用程序直接调用，不需再进行查询处理和优化\n触发器 Chapter 6 E-R model 设计过程 两阶段：\n明确需求 设计DB 模式， 三层数据抽象 考试常考的：\n需求分析，需求分析说明书，设计数据字典，包括元数据 conceptual 概念设计， 通过E-R图 逻辑设计， 初始化关系模式，关系模式规范化——转成relationnal table 物理数据库设计 https://blog.csdn.net/qq_41956139/article/details/104302355\n建模 modeling E-R model：\nentity sets 实体集 relationship sets 联系集 attributes 属性 实体 entity 是实体集entity set 中的一个对象\n放到数据库中就是，某个数据行，和数据库之间的关系\n联系集：两个实体集之间的联系关系\n二元联系binary relationship 关联了两个实体集\nternary relationship 三元联系\u0026hellip;\u0026hellip;\nAttribute 属性 比关系数据库更为自由。\n简单属性和复合属性, 复合属性比如一个名字由姓和名组成\n单值和多值属性\nderived 属性:比如通过生日算年龄\nMapping cardinalities 映射基数 对于二元联系集\nfrom A to B\none to one one to many many to one mane to many note：有一些A或B中的元素可能没有mapped to 其他实体集中的元素\nCardinality constraints基数限制\n画图中，箭头指向的是one，无向线段连接的是many 如果是两条线段，表示连接的实体集上所有实体都参与\nParticipate Constraints\npartial total cardinality limits for participation\n参与的基数界限 从instructor往student看：对于一个instructor，他最少有0个student，最多有所有student\n从student往instructor看：对于一个student，他最少有1个instructor，最多也是1个instructor\n对于A，从A往B看，里面的元素最少有1个b，最多有3个，所以 la=1，ha=3\n对于B，从B往A看，里面的元素最少有0个a(bn)，最多有2个a(bj)，所以lb=0，hb=2\nla 为 0 时，A是部分参与\nla 大于 0 时，A是全部参与\n\u0026lt;hb, ha\u0026gt;描述了从A到B的映射基约束\nkeys 构造关系表时，如果有多个候选键，最好选取数值型候选键作为关系表主键，便于提高基于主键的查询速度\n联系集上的keys：\nsuper key 就是把联系起来的实体集 的主键合并\ncandidate key / primary key：\n对于在A和B实体集上的 binary relationship set R 如果R是many to many，那么primary key 就是A和B的主键合并 如果R是many to one，那么 主键就是many那一边的主键 如果是一对一的， 那么随便选择一个实体集的主键当主键 弱实体集 weak entity sets 弱实体集无主键\n弱实体集只能通过某个关系连接到的实体集来唯一保证\n弱实体集的主键是它所依附的强实体集的主键+弱实体集的discriminator，\ndiscriminator要用虚线下划\nE-R diagrams 矩形\u0026ndash;实体集 菱形\u0026ndash;关系集 椭圆\u0026ndash;属性\n双椭圆表示多值属性\n虚线椭圆表示派生属性 下划线标明了主键属性 双矩形表示弱实体集 标注规则：\n由联系发出的有向箭头指向one所对应的实体，无向线段指向many端所对应的实体 只有在many to many的情况下，E-R图中联系与实体间的线段全部是无向线段，其他三种情况下一定会有有向线段 全参与的要用双线段连接联系 弱实体集里的属性用虚线下划，表示部分键 name是复合属性\naddress是复合属性\nstreet是复合属性\nphone_number是多值属性\nage()是派生属性\nE-R 设计事项 design issues 对于一个多值属性，可以建立一个新的实体集，通过关系集来和原本的实体集联系\n规则：\n1. 不要将主键设置为其他实体集中的属性，最好是通过联系集来关联 2. 如果实体集E 参与了联系集R，则不将E的主键作为R的属性 3. 用联系集来表示实体集之间的联系 4. 最好是使用二元联系集 关系R的属性可以与其参与的实体集之一相关联\n一对一的联系中，联系集上的属性可以分配给其中一个实体集 一对多的联系中，联系集上的属性只能分配给多的那一边，比如instructor 和 student之间通过advisor联系，一个instructor可以有多个students，advisor有一个属性是date，date应该放在学生实体集里 对于多对多的联系中，联系集上的属性只能放在联系集中 extended E-R model overlaping 重叠 disjoint 分解\ngeneralization：将共享相同特性的实体集组合到更高层次的实体集中\nspecialization：将实体集中实体的差异，将实体集分成多个分组，每个分组与实体集中的其他实体不同\n低层实体集会继承高层实体集的属性和relationship\ndisjoint 表示高层的一个实体只能被划分到一个低层实体集中\noverlaping 表示高层的一个实体可以被划分到多个低层实体集中 total 表示高层的一个实体必须属于一个较低级的实体集\npartial 表示一个高层的实体不一定要属于一个低级的实体集 reduction to relation schema 复合属性要多建一张表，\n或者将复合属性中的值提取出来，放在原表中。\n多值属性要建立一张表，同时要包含原实体集中的主键\n将联系集变为关系数据库模型，要基于映射基数\n对于一对一的关系中，如果A是全参与，那么就将R中的主键和discriminator给A\n对于Specialization 和 Generalization的reduction\n1. 对于overlapping或者partial的：为高级实体集形成模式，为每个低级实体集形成模式，包括高级实体集的主键和本地属性。缺点：冗余信息多 2. 对于disjoint 和 complete的：为每个具有所有本体和继承属性的实体集形成一个模式。缺点：冗余信息多 Method1： c属性是主属性，同时是T2、T3的外键\nMethod2： 只有低层级表，每个表都包含高层表的所有属性。没有高层集表了。\nsymbols conclusion Chapter 7 schema normalization 7.1 一个好的关系设计的特点 原则 对初始关系模式集，需要根据关系规范化理论，在保证\n函数无损连接性 lossless join 函数依赖保持 dependency preservation 约束的前提下，对关系模式集进行规范化处理——等价变换 / 模式分解\n函数依赖是特殊的多值依赖 多值依赖又是连接依赖的特例 7.2 atomic domain 和 第一范式 对于一个关系模式R，每个属性的域都是atomic的，就说它符合第一范式\n7.3 用函数依赖分解 函数依赖：某一组属性的值唯一地决定另一组属性的值\nx值相等时，函数值相等；一个x只对应一个y\n对于一个关系（名字， 年龄）来说：同一个名字只有一个年龄。才能说这是有函数依赖（f : 名字-\u0026gt;年龄）的\nC对，ABD错 解析：\nA相同值t2、t3得出的B不一样 AC相同值t2、t3得出的B不一样 BC相同值——无相同的 B相同值t1、t3得出的C不一样 E-R图描述了对象以及它们之间的关联，FD说明了对象的特征之间的关系\n区分FD holds on R 和 FD is satisfied by r(R)\n前者是定义在R的属性间的语义约束，R应满足约束 后者是根据R构造的实际数据r(R)是否满足语义约束FD 前者说明：如果FD定义在R上，那么R上的所有实例都满足函数依赖FD 平凡函数依赖：一个函数依赖被所有关系实例满足，那么就是平凡的\n传递函数依赖 transitive 部分函数依赖 partial：非最小化冗余 函数依赖闭包： BCNF: 一个关系上的函数依赖闭包里的任意一个函数依赖： 1. 要么是平凡的 2. 要么α -\u0026gt; β 这个FD中α是R的superkey 将某个不符合BCNF的关系R分解成BCNF:\nα -\u0026gt; β 不是平凡的函数依赖，α也不是超键。R就会变成下面两个部分： 这样α∪β中，对于 α-\u0026gt;β， α做超键，满足BCNF\n3NF 定义如下：比BCNF宽松一些。如果α不是超键的话，那么β-α中的每个属性A都得在候选键中。\n可以在不同的候选键中 2NF 参考带有主键的关系数据库模型 不存在非主属性对候选键的部分依赖\n每一个非主属性都完全依赖于R的候选键\n但是可以有非主属性依赖于非主属性\n反例： 对于非主属性SD, SD依赖于S#, S#是主键的一部分，SD对(S#, C#)部份依赖\n分解后： 规范化的目标如下： 7.4 函数依赖理论 逻辑蕴涵 logically implied\n三条公理： 推广： 属性闭包\n计算方式如下： 如果一些属性闭包是所有属性的话，那么这些属性是关系的超键\n检查AG是否是R的候选键？ 先检查AG是否是超键 看AG的子集能否构成超键 属性闭包的三种用途：\n查看某些属性是否构成超键 查看某个函数依赖是否满足：比如α -\u0026gt; β是否满足就要看β是不是在α的属性闭包里 用来计算函数闭包 如果两个函数依赖集的函数依赖闭包是一样的，那么就说这两个函数依赖集是equivalent\n正则覆盖 extraneous attribute\nattribute A is extraneous in α： F implies/is equivalent to (F – {α → β}) ∪ {(α – A) → β} F将 α-\u0026gt;β 修改成 α-A -\u0026gt; β， 不改变函数闭包 attribute A is extraneous in β: the set of functional dependencies (F – {α → β}) ∪ {α →(β – A)} implies F 将 α-\u0026gt;β 修改成 α -\u0026gt; β-A，不改变函数闭包 to test if attribute A ∈ α is extraneous (α –A) → β under F ? 步骤如下：\n通过F，计算(α-A)的属性闭包 检查β在不在(α-A)的属性闭包中，如果在，则说明A是extraneous to test if attribute A ∈ β is extraneous in β\n即看 α→A 是否 under F’\n步骤如下：\ncompute α+ using only the dependencies in\nF’= (F – {α → β}) ∪ {α →(β – A)} check A ∈ α+ ? if it does, α→A holds, A is extraneous 正则覆盖要求：\nNo functional dependency in Fc contains an extraneous attribute, Each left side of functional dependency in Fc is unique, that is, there are no two dependencies α1 → β1 , α2→ β2 in Fc , such that α1 = α2 正则覆盖算法： 重复：使用合并律，合并相同左值的函数；减掉无关属性；直到不变\n对于单推单的，可以不检查，但是单推多，多推单的，一定要检查！！！不然容易漏掉\n无损连接分解：lossless join decomposition\nA decomposition of R into R1 and R2 is lossless join if at least one of the following dependencies is in F+ :\n◼ R1 ∩ R2 → R1\n◼ R1 ∩ R2 → R2\n无损连接分解中，R所对应的r被分成若干垂直片段ΠRi(r) , 各垂直片段通过自然连接可恢复r中的数据，保证了数据的完整性/分解可恢复性\n有损连接： 依赖保持 测试函数依赖保持的算法： 我看不懂\n7.5 algorithm for decomposition 分解成BCNF： to determine whether or not Ri is in BCNF, the restriction of F to Ri and the candidate keys of Ri should be computed !!!\n要先算出Ri的候选键\n其实就是循环这个过程：\n将某个不符合BCNF的关系R分解成BCNF:\nα -\u0026gt; β 不是平凡的函数依赖，α也不是超键。R就会变成下面两个部分： 这样α∪β中，对于 α-\u0026gt;β， α做超键，满足BCNF\n然后再对R-(β-α)来分解\n分解时出现无论如何都没法函数依赖保持的例子 分解的范例如下： 第一步，找到候选键，并分解 找到新的候选键 每分解一步都要算出相应关系集的函数依赖闭包 3NF 分解 因为BCNF有可能函数依赖不保持\n分解成3NF一定可以函数依赖保持！！！\n测试是否是3NF时也要先算出candidate key\n分解成3NF的步骤如下：\n找到候选键 求出F的正则覆盖Fc 如果对于某个F：α -\u0026gt; β，已有的子模式Rj都没有同时包含α和β，那么就构造一个Rj 如果没有一个子模式包含了原来R的候选键，那么就为每个候选键构造一个Rj 候选键查找 分类，令X = L ∪ N，Y代表LR类\nL：只出现在左边\nR：只出现在右边\nLR：两边都有\nN：两边都没有 求X的属性闭包，若X包含了所有属性，那么就X就是唯一候选键 X闭包没有包含所有属性，那么就从Y取出一个属性A，若(X∪A)的闭包包含R的所有属性，就说明找到候选键了。这一步中要多次调换，找出所有候选键 若只拿一个还不够找候选键，就要拿两个循环一遍\u0026hellip;拿三个\u0026hellip;直到找到候选键 习题类型 Chapter 13 文件记录的方式 Each file is a sequence of records, and a relational table is a set of tuples\n元组为单位的DB逻辑文件在以记录为单位的OS物理文件中的实现方式：\n定长 Fixed-length records 变长 Variable-length records 定长：\n一条记录不能跨块存储。 每条记录定长。 删除一条记录的三种操作： 1. 被删除的记录后面的依次前移 2. 将最后一条移到被删除的位置上，覆盖 3. 维护一个free list 变长：\n在一个文件中存储多种类型的记录 可以存储变长的变量，varchar 允许重复字段的记录类型，record里还有record 属性要先存定长，再放变长 变长的属性被定长的offset和length标明,如下： 还可以存储为slotted page Slotted page header contains头部包括： ◼ number of record entries record的数量 ◼ end of free space in the block free space的末尾 ◼ location and size of each record record的位置和大小 删除了某条记录就要改变头部 记录都是连续存储的 文件中记录的组织方式 逻辑组织方式有以下四种：\nheap sequential hash clustering 区别如下：\nheap：记录可以放在文件中的任意位置 sequential：记录通过各自的search key来连续组织 hash：通过某些属性的哈希函数 clustering：每个关系的记录可以存储在单个文件中；在多表集群的记录组织中，几种不同的关系记录可以存在一个文件里 heap：\n一般以记录输入的顺序存储 sequential：\n以search key的顺序存储，最好物理结构上也要按顺序来 删除：通过指针链 添加：往空位插入，没有空位则用overflow block 要实时维护顺序 clustering\n一个DB文件可以存储来自多个关系的记录。不同关系中有联系的记录存放在同一block，以提高查找和I/O速度 hash\n{search key} → {physical address of the records} 数据 dictionary storage 存储元数据metadata\nBuffering 有些固定不会被换出 执行完立马换出 执行时或还没执行的不能被换出 Chapter 14 Index 聚集索引：索引文件的search key所规定的顺序与被索引的顺序文件中的记录顺序一致\n主索引：建立在主属性上的索引\n主索引一定是聚集索引，反过来不是\n一个表上只能建立一个聚集索引，也只能有一个主索引。因为数据文件只能有一种排列顺序\n辅助索引 / 非聚集索引 ：secondary index\n索引顺序和文件顺序不一致\nhave to be dense indices 一定是稠密索引，否则可能找不到记录\ndense index 稠密索引\n文件中的每个搜索码值有一个索引记录 相同搜索码的排列在这个记录的后面 sparse index 稀疏索引\n只为搜索码的某些值建立索引记录，有些值没有出现 主索引可以不是稠密索引 可以按块来组织稀疏索引，不会影响查询 对于没有索引的记录来说，想要查询它，得找到比它小的前一个记录，再一个一个往后查 多级索引 multi-level indices\nB+树和B树 为索引建立索引 indices on multiple keys\n复合搜索键 左前缀原则\n举例：\n当使用(dept_name, salary)时，对于下述查询语句，分析： 1. where dept_name='Finance' and salary = 8000 可以很快的查询匹配上述语句的结果。因为先查dept_name，再筛选 2. where dept_name='Finance' and salary \u0026lt; 8000 也可以很快的查询到 3. where dept_name = 'Finance' 可以很快查询 4. where dept_name \u0026lt; 'Finance' and balance = 8000 由dept_name \u0026lt; 'Finance' 会查出很多结果，再做筛选就慢了 5. where balance = 8000 没用到索引 因为数据会是先通过dept_name进行排序的，相同的dept_name再通过salary排序。 Chapter 15 query processing 查询所需步骤：\n1. 用户通过查询语句query 2. 语法语义检查 parser and translator 3. 经过2的编译和翻译后变成关系代数表达式 4. 优化，依靠存储在data dictionary 里的 metadata 5. 执行计划 6. 经过evaluation engine，从DB file中取出数据 7. 查询结果输出 上述步骤中， step1 sparsing and translation：1 2 3 step2 optimization：这一步是选择关系代数表达式，选择索引 3，4 step3 evaluation plan execution：5，6，7 查询代价衡量 Measures of Query Costs 大致有 disk access，CPU， network communication\nCPU 忽略，network communication 管不了，一般只看disk access\ntT: 传输一个block的时间\ntS：寻道时间——\n传输b个block加上S个寻道的平均时间：b * tT + S * tS\n查询算法 A1 File scan by linear search 线性搜索\n必须扫描全部的blocks，才能找到全部满足查询条件的数据 把数据读到内存，一条一条扫描。 因为数据存储连续在一起，只需要一次寻道 br 是包含records的总块数 cost = (br/2) * tT + tS 一般二分查找是没有意义的，除非数据严格按照查询的顺序来 []：取上界 [log2 (br)] * (tT + tS),如果是等值查询，结果不唯一，还得加上后面满足块的开销 Index scan\nA2 主索引，值相等查询\n必须是在search key上的index 检索满足相应等式条件的单条记录，使用B+树作为聚类/主索引 cost = (hi + 1) * (tT + tS) 其中，hi是树深度 hi*(tT + tS) 表示读取索引的时间 1 * (tT + tS) 表示读取叶节点索引指向的记录所花时间。读数据的时间 A3 主索引，非等值查询\nb是要找的总块数，包含了所有匹配到的记录的总块数 cost = hi*(tT + tS) + tS + tT * b 同样，hi * (tT + tS) 表示找索引的时间 tS是找数据的寻道时间，只需找一次 后面是依次传输的时间 A4 辅助索引，等值查询\n获取一条记录： cost = (hi + 1) * (tT + tS) 获取多条记录：比如在instructor里找某个下面这个值是700的记录 cost = (hi + n) * (tT + tS) 因为不同记录不是连续的，所以需要多个寻道时间。 这里n为3：hi*(tT+tS)是找到700的索引在哪。3*(tT + tS)是获取700这三个索引指向的数据 范围查询\nA5 主索引，比较查询 A6 辅助索引，比较查询\n查索引值，比较 复合查询 —— 并（conjunction）\nA7 conjunctive selection using one index\n先用一个索引 选择 A1~A7 开销最低的算法来查找 将元组提取到内存缓冲区后，测试它上的其他条件 A8 conjunctive selection using composite index\n使用合适的组合 A9 conjunctive select by 标识符的交集来进行连接选择\n需要具有记录指针的索引 对每个条件使用相应的索引，获得记录指针集进行交集 从文件中获取记录 如果有些条件没有适当索引，就在内存中测试 A10 disjunctive selection by union of identifier\n只要有一个不能优化，就只能线性扫描 对每个条件使用索引，并对索引获得的记录取并集 然后从文件中获取记录 evaluation of express 评估包含多个计算原语的表达式，比如说投影+选择+比较\nmaterialization 实体化 pipeline 管道化、流水线 实体化：将中间结果写入磁盘\n作出语法树，从底向上评估\n所有的cost 大约是：单个操作的成本之和+中间结果写入磁盘的成本\n流水线\n同时评估管道的多个操作，并将一个操作的结果传递给下一个操作，而不需要在磁盘中存储临时关系\n可以并行评估\nChapter 查询优化 关系表达式等价\n关系表达式转换规则 运算中尺寸小的操作排在左边\n选择尽早执行\n优化后是branch和loan先连，因为这两个连接的结果会少于和borrower连接的结果\nChapter 17 transaction 事务是DBS中应用程序/数据库应用系统的基本逻辑单位，也是DBMS管理DBS运行的基本单位\nDBS中，从DBMS的角度，用户对DB的访问体现为DBS中1个或多个事务的执行\n多用户DBS中，多个用户对DB的并发访问体现为DBS中多个数据库事务的并发执行\n事务的四个特性：ACID\natomic 原子性\nconsistency 一致性\nisolation 独立性 / 隔离性：每个事务不能知道其他事务的中间结果\ndurability 持久性：事务提交之后数据永久生效\nconcurrency-control component保障独立性isolation recovery-management component保障永久性durability\n事务的定义\na collection of operations that form a single logic unit of application works, delimited by the statements of the form begin transaction and end transaction 是操作的集合组合成的逻辑单元 ACID在DBS 中的机制\nA：通过事务管理，恢复管理系统 C：通过程序、事务设计，一致性约束测试 I：并发控制 D：恢复管理 事务的状态 在Active中，事务对数据修改，可能只是修改在本地缓冲区中，并没有真正被修改到磁盘上的DB file中\n可串行化 serializability\n某个并发调度is equivalent to串行调度，那么它是可串行化的 n个事务，就有 n! 种串行调度方式，只要并发调度能和其中某个等价就ok 不同形式的调度等价性产生了以下概念：\nconflict serializability 冲突可串行化 view serializability 对同一个数据来说，读写、写写冲突\n冲突可串行化 conflict equivalent：\nS and S’ are conflict equivalent if the schedule S can be transformed into S’ by a series of swaps of non-conflicting instructions S 可以通过一系列不冲突的顺序交换得到 S’ read(A) read(B)调换顺序后不冲突，调换\nwrite(A) write(B)调换顺序后也不冲突，调换。\n这样就变成了S6这样的穿行调度\n只能交换不同事务的两个指令顺序\n交换后事务内的指令执行顺序不会被改变\n交换不能改变冲突指令的顺序\n如果并发事务S和串行事务S’等价，那么就说S是冲突可串行化conflict serializable\n下例就不是冲突可串行化的，因为不管怎么调换T3 、T4中指令的执行顺序，都会使冲突不等价\nT3 T4 read(Q) write(Q) write(Q) 判读某个并发调度S是否是冲突可串行化：\nprecedence-graph 前驱图 Ti 某条指令执行完 Tj有冲突操作，不管几个冲突都画一条边 i -\u0026gt; j 如果得到一个有向无环图，则说明是冲突可串行化的。 用拓扑排序，依次消掉没有入度的边。 如果有多少个拓扑排序法，就有多少种串行调度方法 T3 -\u0026gt; T2、T4 T3 -\u0026gt; T1、T4 T4 -\u0026gt; T1 通过 先做T3，再作T2，再做T4，在做T1 recoverability 事务Ti失败的时候，任何依赖于Ti的事务Tj也应该终止\n看谁读了谁写的数据，就要在谁后面提交 如果Ti 读了Tj 写的数据，Ti先提交了，Tj可能在之后执行中中断回滚，导致Ti读了错误的数据\n级联回归 cascading rollback 会导致大量的开销\n需要的是cascadeless schedule 无级联调度\n对于任意的Ti Tj，Tj读取Ti写入的数据项Q，要求Ti先commit，Tj再读取\n即Tj只能读取Ti提交过的数据\nEvery cascadeless schedule is also recoverable！！\n事务隔离级别 Chapter 18 concurrency control 使用数据的两种模式：\nexclusive (X) mode —— 互斥、排他 shared (S) mode —— 共享 lock compatibility matrix 只有S-S是相容的\n处理数据的步骤 用lock-S(Q) 或者lock-X(Q)获取锁 等待权限，执行 unlock-S(Q) 或unlock-X(Q)将锁释放 两阶段锁协议 Two Phase Locking protocol / 2PL 事务可以按照锁点(lock points)的顺序串行化\nlock points是单个事务获得最后一个锁的时间点\n2PL保证了冲突可串行化调度\n但是不能保证从死锁中摆脱\n也不能避免级联回滚\n构造符合2PL的调度 先给每个事务进行加锁解锁 根据锁相容性矩阵安排并发 两个阶段应尽可能错开，不允许访问 冲突事务 同时处于growing phase 因为对A的操作最高是write,所以一开始就要用lock-X 第二步要通过锁点的前后关系来确定顺序 要注意，由于T7对B只有一个操作，而T8也要用B，所以T7要尽快释放B\nStrict 2PL 严格2阶段锁协议 所有的互斥锁都得在事务提交之后才能释放\n这样避免了级联回滚\nRigorous 2PL 强2阶段锁协议 所有的锁都要在事务提交后才能释放\n能让事务按照它们提交的顺序串行化\ndeadlock handling prevention strategies 在事务开始前获取所有需要的锁 对所有数据项进行partial ordering，并要求事务只能按照partial ordering指定的顺序 基于超时的模式：事务只等待指定时间内的锁，之后等待超时，事务回滚 wait-die scheme\nTS是事务开始的时间戳timestamp 如果TS(Ti) \u0026lt; TS(Tj), 那么Ti等待。Ti更早开始，Ti等待 ———\u0026gt; 年老等待 否则的话，就让Ti回滚，重新开始Ti，但是Ti的时间戳不变。 意思就是年老等待，年轻的重做 年轻的回滚 这意味着，年轻的做的速度更快，但是遇到年老的总是要重做，年轻的可能会一次又一次的赶上年老的 wound-wait scheme 伤停等待\n如果TS(Ti) \u0026gt; TS(Tj) 那么久让Ti等待 Ti更年轻 否则的话，就让Tj回滚，但是Tj的时间戳不变 年老的回滚。但是由于时间戳总是增加的，所以被卷回的进程将具有较小的时间戳 伤害有锁的事务，正常进行的事务回滚 可能rollback的次数比wait-die少 意味着年老的做的慢，所以比较不可能赶上年轻的，回滚次数会少一些 deadlock detection 死锁可以被描述成 wait-for 图 Ti 等待 Tj 锁释放：i \u0026ndash;\u0026gt; j 的有向箭头 也是，用拓扑排序来看有没有死锁\nChapter 19 Recovery 在修改数据库本身前， 将日志信息输出到稳定的存储介质中\n日志数据比 执行本身 先完成\n\u0026lt;Ti start\u0026gt; \u0026lt;Ti X V1 V2\u0026gt; Ti事务，某个数据X，写前是V1, 修改后变成V2 \u0026lt;Ti commit\u0026gt; 在 partial committed状态写入 \u0026lt;Ti, X, V1\u0026gt; 补偿日志记录 compensate records 或者 叫redo-only record \u0026lt;Ti, abort\u0026gt; Deferred database modification (延时更新)\n直到committed之后才会修改数据库 Immediate database modification (及时/立即更新)\n在active状态的时候就会修改数据库 undo通过log record来将数据库数据设置为旧值\nredo通过log record来将数据库数据设置为新值\nRecovery scheme 要求在Ti修改数据项Q后，在Ti提交之前，没有其他事务Tj去修改这个数据项\n这个通过strict 2PL来保证\nundo：从最后一条日志记录向后回溯\\ redo：从第一条日志记录向前查找，每更新一个值，就重写一个值 undo: 事务主动回滚 事务被动回滚 redo: 事务被动回滚 情形1：事务主动回滚\n主动回滚中，日志记录本身就会有\u0026lt;Ti, abort\u0026gt;记录 从最后一条记录往前scan， 每找到一条表示修改的日志\u0026lt;Ti, X, V1, V2\u0026gt;，就撤销到原值 并写补偿记录 \u0026lt;Ti, X, V1\u0026gt; 直到找到\u0026lt;Ti, start\u0026gt; 最后写一个\u0026lt;Ti, abort\u0026gt;记录 情形2：事务被动回滚\n事务日志记录中没有事务结束标志\u0026lt; Ti, commit \u0026gt;或者\u0026lt; Ti, abort \u0026gt;，需要undo 发生failure时，事务逻辑上结束了，日志中有上述两种标志了。需要redo 2-1 undo 2-2 redo undo和redo在立即修改的模式下 情形1和情形2-1 在日志上和 稍后修改 的一样，也是通过对日志的回溯，恢复原来的记录\n如果是情形2-2 partial committed，就需要先undo一遍，再redo\n这种效率太低，要查找整个log，因此引入checkpoints\ncheckpoints 串行调度 checkpoint的record是：\u0026lt; cpk \u0026gt;\n找到最近的检查点和该检查点最近的事务Ti\n方法：回溯，首先找到最近的checkpoint，然后继续找到最近的\u0026lt;Ti, start\u0026gt;\n比如找到的是这个T4\n在立即修改的模式下：\n在最近检查点的时候，T4还没committed，但是在出现错误的时候，T4已经committed了，所以要redo T4。T4之前的就不用管了。\n而在T4之后直到failure的地方，里面所有没有committed的事务都要undo。上图中，undo的是T5\nredo的是检查点committed的；undo的是没有committed的\n在延迟修改的模式下，undo就不需要了\n并发调度 首先要满足严格2PL\n并发中，checkpoint的标志是\u0026lt; checkpoint L \u0026gt; L是当前还active的事务list\n对于正常执行的，且是以\u0026lt; Ti abort \u0026gt;结束的调度，将会从后往前回溯\n对于不正常进行的，crash掉的调度来说 ( 没有\u0026lt;Ti, abort\u0026gt; ) ：\nredo的情况：\nStep1. Find last \u0026lt;checkpoint L\u0026gt; record, and set the undo-list to L 找到当时还没执行完的事务，加入到undo-list中 Step2. Scan forward from above \u0026lt;checkpoint L\u0026gt; record 从检查点记录开始向前看，就是往时间正方向 ——\u0026gt; ，redo每一条log。 如果发现一个\u0026lt;Ti start\u0026gt;的记录，就把Ti加入到undo-list 如果看到一个\u0026lt;Ti commit\u0026gt;或者\u0026lt;Ti abort\u0026gt;记录，就把Ti从undo-list移走 step3. Scan log backwards from end, to roll back all transactions in undo-list 往后回溯，对于每一个undo-list中的事务Ti，只要有Ti的log record就undo一次，并记录到redo-only的记录中 比如遇到 \u0026lt;Ti, X, V1, V2\u0026gt;，那么就把X恢复成V1，并且写一个\u0026lt;Ti, X, V1\u0026gt;到redo-only的record上。 如果遇到\u0026lt;Ti, start\u0026gt;, Ti又是undo-list中的，那么就写一个\u0026lt;Ti, abort\u0026gt;的记录，并且将Ti从undo-list移除 step4. 一直到undo-list为空 ","date":"2024-09-20T09:20:26+08:00","permalink":"https://ffirestorm.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/","title":"数据库系统原理"},{"content":"1 概述 人工智能及发展 研究基础内容 研究领域 不同定义\n人工智能是指由计算机实现的人造智能。人工智能就是用人工的方法在机器（计算机）上实现的智能。作为一门学科，人工智能可定义为：人工智能是一门研究如何构造智能机器（智能计算机）或智能系统，使它能模拟、延伸、扩展人类智能的学科。（能力） 人工智能是一门交叉边缘学科，与人工智能有关的学科有：计算机科学、数学、哲学、语言学、神经生理学、神经心理学、脑科学、认知科学、逻辑学、控制论等.（学科） 人工智能是一种使计算机能够思维，使机器具有智力的激动人心的新尝试（Haugeland,1985） 人工智能是那些与人的思维、决策、问题求解和学习等有关活动的自动化（Bellman,1978） 人工智能是用计算模型研究智力行为（Charniak和McDermott,1985） 人工智能是研究那些使理解、推理和行为成为可能的计算（Winston,1992） 人工智能是一种能够执行需要人的智能的创造性机器的技术（Kurzwell,1990） 人工智能研究如何使计算机做事让人过得更好（Rick和Knight,1991） 人工智能是一门通过计算过程力图理解和模仿智能行为的学科（Schalkoff,1990） 人工智能是计算机科学中与智能行为的自动化有关的一个分支（Luger和Stubblefield,1993） 为什么要研究人工智能\n1、现有计算机系统智能的局限性。 2、人类智能的局限性。学习能力因人而异、学习速度慢、效率低。 3、信息化社会的迫切要求。 目标\n近期：用机器来模拟和实现人的部分/某些智力功能； 远期：全部甚至可以延伸人的智慧。 智能\n有效获取、传递、处理、再生和利用信息，从而在任意给定的环境下达到预定目的的能力。 智能特征\n具有感知能力。通过视觉、听觉、触觉、味觉和嗅觉感知外部世界。 具有记忆与思维能力。记忆能存储由感知器官感知到的外部信息以及有思维所产生的知识。思维用于对记忆的信息进行处理。思维可分为逻辑思维和形象思维。 具有学习能力及自适应能力。 具有行为能力。 分类\n计算智能（能存会算）：快速计算、记忆和储存能力 感知智能（能听会说、能看会认）：视觉、听觉、触觉等感知能力，人脸识别、语音识别等 认知智能（能理解会思考）：分析、思考、理解、判断的能力 相关学说\n思维理论/认知科学： 研究人们认识世界规律和方法的一门学科，在于揭开大脑思维功能的奥秘； 知识域值理论： 智能行为取决于知识数量及一般化的程度； 人工智能研究方法\n结构派：（神经计算、生理学派、连接主义）\n网络连接为主的联结主义；\n主要观点：\n智能活动的基元是神经细胞；\n智能活动过程是神经网络的状态演化过程；\n智能活动的基础是神经细胞的突触联结机制；\n智能系统的工作模式是模仿人脑模式。\n主要特征：\n1、通过神经元之间的并行协同作用实现信息处理，具有并行性、动态性、全局性。\n2、通过神经元间分布式的物理联接存储信息。联想记忆、容错性。\n3、通过神经元间连接强度的动态调整实现自学习和自适应功能。\n4、善于模拟人类的形象思维过程。\n（符号主义、心理学派、逻辑学派）\n符号处理为核心的方法；\n主要观点:\n思维的基元是符号； 思维的过程是符号运算； 智能的核心是知识，利用知识推理进行问题求解； 智能活动的基础是物理符号系统，人脑电脑都是物理符号系统； 知识可用符号表示，可建立基于符号逻辑的智能理论体系。 主要特征：\n1、立足于逻辑运算和符号操作，适合于模拟人的逻辑思维过程。 2、知识用显式的符号表示，容易表达人的心理模型。 3、现有的数字计算机可以方便地实现高速的符号处理。 4、能与传统的符号数据库进行链接，易于模块化。 5、以知识为基础。 行为模拟派（行为主义、进化主义、控制论学派）\n基于感知-行为模型的研究途径和方法。\n主要观点：\n智能行为的基础是感知－行动的反应机制； 智能系统的智能行为需要在真实世界的复杂境遇中进行学习和训练，在与周围环境的信息交互与适应过程中不断进化和体现;、 强调智能系统与环境的交互，认为智能取决于感知和行动； 智能行为可以不要知识。 人工智能的发展 history\nYears Description 1950–1956 The Birth of AI AI的诞生 1956–1974 The Golden Years 黄金之年 1974–1980 The First AI Winter 第一个AI之冬 1980–1987 The Boom of AI AI的繁荣期 1987–1993 The Second AI Winter 第二个AI之冬 1993–Present The Breakthrough 突破 孕育期（1956年以前）\n古希腊的Aristotle（亚里士多德）（前384-322），给出了形式逻辑的基本规律。 英国的哲学家、自然科学家Bacon（培根）（1561-1626），系统地给出了归纳法。“知识就是力量” 德国数学家、哲学家Leibnitz（莱布尼茨）（1646-1716）。提出了关于数理逻辑的思想，把形式逻辑符号化，从而能对人的思维进行运算和推理。做出了能做四则运算的手摇计算机 英国数学家、逻辑学家Boole（布尔）（1815-1864）实现了布莱尼茨的思维符号化和数学化的思想，提出了一种崭新的代数系统——布尔代数。 美籍奥地利数理逻辑学家Godel（哥德尔）（1906-1978），证明了一阶谓词的完备性定； 英国数学家Turing(图灵)（1912-1954）,1936年提出了一种理想计算机的数学模型（图灵机），1950年提出了图灵试验，发表了“计算机与智能”的论文。图灵奖。 美国数学家Mauchly，1946发明了电子数字计算机ENIAC 美国神经生理学家McCulloch，建立了第一个神经网络数学模型。 美国数学家Shannon（香农）,1948年发表了《通讯的数学理论》，代表了“信息论”的诞生。 形成期（1956\u0026ndash;1969）\n起源于美国1956年的一次夏季讨论会（达特茅斯会议）（确立性事件） 1956年提出了“Artificial Intelligence（人工智能）” 创始人中有：McCarthy, Minsky, Rochester, Shannon, Moore, Samuel, Selfridge, Solomonff, Simon, Newell等数学家、信息学家、心理学家、神经生理学家、计算机科学家。 McCarthy（麦卡锡）——人工智能之父 。 50年代初开始有了符号处理。（搜索法）。机器翻译、机器定理证明、跳棋程序等。 60年代Simon由试验得到结论：人类问题的求解是一个搜索的过程，效果与启发式函数有关。叙述了智能系统的特点：智能表示、智能推理、智能搜索。 Nilson发表了A*算法（搜索方法） McCarthy建立了人工智能程序设计语言Lisp 1965年Robinson提出了归结原理，（于传统的自然演绎法完全不同的消解法）（第一个AI语言） 1968年Quillian提出了语义网络的知识表示方法 1969年Minsky出了一本书“感知机”，给当时的神经网络研究结果判了死刑 70年代，开始从理论走向实践，解决一些实际问题。同时很快就发现问题：归结法费时、下棋赢不了全国冠军、机器翻译一团糟。 1966年，机器翻译失败了。 1970年，连接主义遭到遗弃。 1971年至75年，美国DARPA对卡内基梅隆大学的语音理解研究项目感到沮丧。 1973年，受莱特希尔的“人工智能：综合调查”报告的影响，英国大幅度缩减AI的研究。 1973-74，美国DARPA削减了一般性AI学术研究经费。 发展期（1970\u0026mdash;80年代）知识工程时代\n1970 年，知识工程的提出。\t以Feigenbaum为首的一批年轻科学家改变了战略思想，1977年提出了知识工程的概念，以知识为基础的专家咨询系统开始广泛的应用。（第一次推向应用） - 专家系统 - 知识工程 - 知识工程席卷全球 - 各国发展计划： 美国星球大战计划 英国ALVEY计划 法国UNIKA 计划 日本五代机计划 中国“863”计划 第四阶段（80年代中～90年代初） 新的神经元网络时代\nBP网（算法），解决了多层网的学习问题 Hopfield网 存在问题： 理论依据 解决大规模问题的能力 1980年，美国人工智能学会（AAAI）在斯坦福大学召开了第一届全国大会。 1982年，日本启动了第五代计算机系统（FGCS）项目，用于知识处理。 1980年代中期，机器学习出现了，当时发明了决策树模型并且以软件形式推出。该模型具有可视化、易说明的特点。 1980年代中期，还发明了多层人工神经元网络（ANN）。具有足够多的隐藏层，一个ANN可以表达任意的功能，因此突破了感知的局限性。 1987年，Lisp机的市场崩溃。 1988年，美国政府的战略计算促进会取消了新的AI经费。 1993年，专家系统缓慢滑向低谷。 1990年代，日本第五代计算机项目未能达到其初始目标，悄然退场。 第五阶段（90年代初～现在） 数据与网络时代\n网络给AI带来无限的机会 知识发现与数据挖掘 机器学习，深度学习 AI走向实用化 IBM 深蓝\nIBM的研发团队计划研发一种能够理解人类语言，并能利用已知信息给出最佳答案的电脑，这种计算机系统不仅要能听懂不同口音的发音，还需要能理解包括俚语和双关语等语言在内的复杂表述，并剔除一些错误信息，而最后IBM制造出了现在这台以创办人沃森名字命名的超级电脑。\u000b“沃森”数据库中包括辞海和《世界图书百科全书》等数百万份资料，而构成“沃森”的是90台Power 7服务器，占地面积接近一个房间，每台服务器中拥有4个8核Power 7处理器，使得其能在3秒钟之内检索数亿页的材料并给出答案。 17秒，Watson可以阅读3469本医学专著，248000篇论文、69种治疗方案、61540次实验数据、106000份临床报告，最终提出三个最优选的治疗方案； 129天，Watson大脑让机器人Pepper识别出货架上绝大多数商品，售卖咖啡与手机，洞察消费者，感知细微的情绪变化 Alphago\n阿尔法围棋（AlphaGo）是由谷歌（Google）旗下DeepMind公司团队开发。其主要工作原理是“深度学习”。 2016年3月，该程序与职业九段选手李世石进行人机大战，并以4:1的总比分获胜； 2016年末2017年初，该程序在中国棋类网站上以Master为注册帐号与中日韩数十位围棋高手进行快棋对决，连续60局无一败绩。不少职业围棋手认为，阿尔法围棋的棋力已经达到甚至超过围棋职业九段水平。 ChatGPT\nGPT是Generative Pre-trained Transformer（生成型预训练变换模型）的缩写。一种基于自然语言处理的人工智能模型，是美国OpenAI“开放人工智能研究中心”研发的聊天机器人程序。 2018年起，OpenAI开始发布生成式预训练语言模型GPT，可用于生成文章、代码、机器翻译、问答等各类内容。ChatGPT 是基于GPT-3.5架构开发的对话AI模型。 ChatGPT的主要特点：\n（1）敢于质疑； （2）承认无知； （3）支持连续多轮对话； （4）主动承认错误； （5）大幅提升准确度； （6）支持上下文理解； （7）提升对用户意图的理解。 其他历史\n2005年，斯坦福的自主机器人车辆Stanley，赢得了DARPA无人驾驶汽车挑战赛。 2006年，在杰弗里·辛顿和鲁斯兰· 萨拉赫丁诺夫在科学杂志上发表了有关“深度学习”的论文之后，该术语成了热门。 2011，谷歌启动了深度学习项目，谷歌大脑，作为Google X项目之一。谷歌大脑是由1万6千台计算机连成的一个集群，致力于模仿人类大脑活动的某些方面。 通过1千万张数字图片的学习，已成功地学会识别一只猫。 2012年，苹果公司引进了Siri，从iPhone 4S上运行的iOS5开始，已作为iOS的一个组成部分。使用自然语言用户接口来回答问题、做出建议和执行动作。支持英语、法语、德语、日语、中文、韩文、意大利语、西班牙语 2012年,瑞克·拉希德，微软首席研究官，演示了一款实时的英语-中文通用翻译系统，可以保持声音和口音。 2014年6月，微软中国推出了聊天机器人小冰。 2014年6月，聊天机器人尤金·古斯特曼，在纪念图灵逝世60周年的一个比赛上，被该活动33%的评委认为古斯特曼是人类，因此组织者认为它已经通过了图灵测试。 2015年9月8日，百度在2015百度世界大会上推出了一款机器人助理—度秘，可以为用户提供秘书化搜索服务。 2016年 AlphaGo 新一轮人工智能的标志性成果； 2019 年 3 月 27 日，深度学习 Yoshua Bengio（约书亚本希奥）、Yann LeCun（杨勒丘恩）、Geoffrey Hinton（杰弗里辛顿） 因“在概念和工程方面使深度神经网络成为计算的关键组成部分的突破”获得了 2018 年的图灵奖。 2020+：自动驾驶 脑机接口 VR 元宇宙 文心一言、讯飞星火 1.人机物互联互通成趋势，数据量呈现爆炸性增长 2 、数据处理技术加速演进，运算能力实现大幅提升 3、深度学习研究成果卓著，带动算法模型持续优化 4 、资本与技术深度耦合，助推行业应用快速兴起 人工智能研究基础内容 研究角度分：\n符号智能：运用知识解决问题； 计算智能：神经计算、模糊系统、遗传算法、进化程序设计； 人工生命：生成或构造表现自然生命系统行为特点的仿真系统或模型系统 功能分：\n机器感知/知识获取：机器听觉、视觉 机器思维/知识处理：知识推理、问题求解、学习、理解 机器行为/知识运用：智能机器系统 研究领域\n传统领域：\t专家系统； 决策支持； 机器学习； 模式识别； 自然语言理解； 智能软件工具/平台； 博弈 智能体/主体理论 当前人工智能的研究热点\n深度学习 分布式处理 智能Agent 数据挖掘（Data Mining）知识发现 知识图谱 与各应用领域的结合 语音、图像识别 技术层面的问题：\n1 数据瓶颈：基于小数据样本的智能； 2 泛化问题：样本表现好；迁移学习； 3 能耗：降低能耗； 4 语义鸿沟：缺乏真正的语言语义理解能力； 5 可解释性：知其然而不知其所以然；获取可解释性和结果重现性； 6 可靠性：自动驾驶等。。。 可信人工智能：\n稳定性：指人工智能系统抵抗恶意攻击或者环境噪声的能力； 可解释性：人工智能系统能够对决策过程以及相关数据给出正确的、可以让人理解的解释； 隐私保护：是希望人工智能系统能够保护用户的个人隐私信息不被泄露； 公平性：是希望人工智能系统能够不因人种、性别、年龄等特定特征对用户产生系统性的歧视或者偏差。 人工智能是把双刃剑：\n霍金：“人工智能的短期影响取决于由谁来控制它，而长期影响则取决于它是否能够被控制。” “人工智能技术发展到极致程度时，我们将面临着人类历史上的最好或者最坏的事情。” 马斯克：“人工智能对人类的威胁，比核武器还要大”。 比尔盖茨： “人工智能可以成为我们人类的朋友。” 主要人物 阿伦·图灵（Alan Turing）\n1912年出生于英国伦敦，1954年去世 1936年发表论文“论可计算数及其在判定问题中的应用”，提出图灵机理论 1950年发表论文“计算机与智能”，阐述了计算机可以具有智能的想法，提出图灵测试 1966年为纪念图灵的杰出贡献，ACM设立图灵奖 马文•明斯基（Marniv Lee Minsky）\n人工智能之父 框架理论的创立者 首位获得图灵奖的人工智能学者 1927年出生于美国纽约 1951年提出思维如何萌发并形成的基本理论 1956年达特茅斯会议的发起人之一 1958年在MIT创建世界上第一个AI实验室 1969年获得图灵奖 1975年首创框架理论 约翰•麦卡锡 John McCarthy\n人工智能之父 LISP语言的发明人 首次提出AI的概念 1927年出生于美国波士顿 1956年发起达特茅斯会议，并提出“人工智能”的概念 1958年与明斯基一起创建世界上第一个人工智能实验室 发明α－β剪枝算法 1959年开发LISP语言 开创逻辑程序研究，用于程序验证和自动程序设计 1971年获得图灵奖 爱德华•费根鲍姆（Edward A. Feigenbaum）\n知识工程的提出者 大型人工智能系统的开拓者 1936年出生于美国的新泽西州 通过实验和研究，证明了实现智能行为的主要手段是知识 1977年提出知识工程，使人工智能从理论转向应用 名言：知识蕴藏着力量 1994年和劳伊•雷迪共同获得图灵奖 1963年主编了《计算机与思想》一书，被认为是世界上第一本有关人工智能的经典性专著 1965年开发出世界上第一个专家系统 开发出著名的专家系统MYCIN 80年代合著了四卷本的《人工智能手册》 开设Teknowledge和IntelliGenetics两个公司，是世界上第一家以开发和将专家系统商品化的公司 2 问题和知识表示 知识基本内容 知识表达方法 知识的组织与管理 2.1 知识及其特性 知识的特性\n客观性； 相对正确性： 一定条件、时间、环境； 进化性； 依附性：离开载体的知识是没有的； 不确定性： 信息和关联的随机性、模糊性、不完全性、\t经验性； 可表示性； 可利用性； 可重用性； 共享性。 总之：\n知识表示是如何将已获得的有关知识以计算机易于接受的形式加以合理地描述、存储、有效地利用。 基于逻辑的知识的表达：\n一阶谓词，非经典逻辑（模态逻辑、模糊逻辑、时序逻辑、非单调逻辑）； 面向对象的知识表示：\n对象、框架、语义网；Agent; 基于规则的知识表达：\n产生式系统； 基于模型的知识表示：\n2.2 状态空间表示 在状态描述中应用变量\n猴子、香蕉问题 2.3 与或树表示 2.4 产生式规则表示法 2.5 谓词表示法 2.6 语义网络法 一 概念\n语义网络是用图来表示知识，表示事物概念及语义关系。 节点：表示概念、实体、事物、事件等； 弧线或链线：表示关系。 二 表示\n1. 基本单元： \u0026lt;节点\u0026gt;\u0026lt;语义关系\u0026gt;\u0026lt;节点\u0026gt; 网络：\u0026lt;基本单元\u0026gt;组合 2.表示基本事物和概念： 三 求解\n四 特点\n2.7 知识图谱 知识图谱是一种揭示实体之间关系的语义网络，可以对现实世界的事物及其相互关系进行形式化地描述。现在的知识图谱已被用来泛指各种大规模的知识库。 知识图谱专注于如何以工程的方式，从文本中自动抽取或依靠众包的方式获取并组件广泛的、具有平铺结构的知识实例，最后再要求使用它的方式具有容错、模糊匹配等机制。 知识图谱是由一些相互连接的实体和它们的属性构成的，用于描述物理世界中的概念及其相互关系。 三元组是知识图谱的一种通用表示方式，即G=(E,R,S)。其中： E={e1,e2,...,e|E|}是知识库中的实体集合，共包含|E|种不同实体; R={r1,r2,...,r|E|} 是知识库中的关系集合，共包含 | R | 种不同关系; S 属于 E X R X E 代表知识库中的三元组集合。 三元组的基本形式主要包括实体、关系、概念、属性、属性值等： 实体是知识图谱中的最基本元素，不同的实体间存在不同的关系。 关系用来连接两个实体，刻画它们之间的关联。 概念主要指集合、 类别、对象类型、事物的种类，例如人物、地理等; 属性主要指对象可能具有的属性、特征、特点以及参数，例如国籍、生日等; 属性值主要指对象指定属性的值，例如中国、1988-09-08等。 每个实体(概念的外延)可用一个全局唯一确定的ID来标识，每个属性-属性值对(attribute-value pair，AVP)可用来刻画实体的内在特性。 知识图谱示例：中国是一个实体，北京是一个实体，中国-首都-北京 是一个（实体-关系-实体）的三元组样例北京是一个实体 ，人口是一种属性2069.3万是属性值。北京-人口-2069.3万构成一个（实体-属性-属性值）的三元组样例；国家是概念。 知识图谱构建：\n从最原始的数据（包括结构化、半结构化、非结构化数据）出发，采用一系列自动或者半自动的技术手段，从原始数据库和第三方数据库中提取知识事实，并将其存入知识库的数据层和模式层，这一过程包含： 知识抽取 知识表示 知识融合 知识推理 每一次更新迭代均包含这四个阶段。 知识抽取：\n主要是面向结构化、半结构化、非结构化数据中转为三元组表示的标准知识形态。 通过知识抽取技术抽取出可用的知识单元，知识单元主要包括实体(概念的外延)、关系以及属性3个知识要素，并以此为基础，形成一系列高质量的事实表达，为上层模式层的构建奠定基础： 实体抽取： 识别文本中指定类别的实体，主要包括人 名、 地名、 机构名、 专有名词等的任务。 基于规则与词典的方法、基于统计机器学习的方法以及面向开放域的抽取方法。 关系抽取：实体关系、事件关系等 面向开放域的信息抽取、基于马尔可夫逻辑网、基于本体推理的深层隐含关系抽取方法 属性抽取： 基于规则与启发式算法、从开放域数据集上抽取。。 知识图谱的表示及存储\n涉及知识表示及知识存储方式。 知识表示：知识图谱逻辑表示，即数据模型。从人的角度对知识图谱数据进行理解和描述。 属性图模型、RDF三元组、基于向量空间学习的分布式知识表示等。 物理存储：从计算机的角度对数据进行组织，两者密切相关。 关系数据库存储、图数据库、分布式存储等。 属性图：\n目前被图数据库业界采纳最广的一种图数据模型。 属性图模型要素： - 节点(Nodes)：是图中的实体，用表示其类型的0到多个文本标签进行标记，相当于实体。 - 边(Edges)：是节点之间的定向链接，每条边连接一个“from node”和一个“to node” 。边是定向的且每条边都有一个标签，它们可以在任何方向上导航和查询。相当于实体之间的关系。 - 属性(Properties)：是一个键值对，顶点和边都可以包含属性。 满足如下性质： 1）每个节点具有唯一的id 2）每个节点具有一组属性，每个属性是一个键值对； 3）每条边具有唯一的id 4）每条边具有一个标签，表示联系 5）每条边具有一组属性，每个属性是一个键值对 知识融合\n是高层次的知识组织，使来自不同知识源的知识在同一框架规范下进行异构数据整合、消歧、加工、推理验证、更新等步骤，达到数据、信息、方法、经验以及人的思想的融合，形成高质量的知识库。 实体对齐：用于消除异构数据中实体冲突、指向不明等不一致性问题，可以从顶层创建一个大规模的统一知识库。 知识加工：本体构建、质量评估等。 知识推理\n通过算法对海量知识图谱数据进行学习与挖掘，从而推理出新的知识，服务于具体行业应用。 - 基于描述逻辑的推理：DL，是一种用于知识表示的逻辑语言，和知识推理的形式化工具。曼彻斯特大学研发的FaCT++、美国Franz公司研发的Racer、马里兰大学研发的Pellet、牛津大学研发的HermiT。 - 基于逻辑编程的推理：Datalog语言，Prolog。德国吉森大学研发的DLV ( Datalog with Disjunction )、由波茨坦大学研发的Clingo、由牛津大学研发的RDFox等。 - 基于图结构的推理：实体与实体之间的路径作为特征，从而对链接路径进行统计推理。 - 基于规则学习的推理：自动化的规则学习方法，快速有效的从大规模知识图谱中学习出置信度较高的规则，并且应用于推理任务。 - 基于表示学习的推理：将符号表示映射到向量空间进行数值表示，利用算法在学习知识表示的过程中自动捕捉知识推理所需的特征。 常见知识图谱列表 百科知识图谱\n1) Freebase Freebase是Google Knowledge Graph的早期版本，早期由Metaweb公司创建，后来被Google收购，成为Google知识图谱的重要组成部分。Freebase中的数据主要是由人工构建，另外一 部分数据则主要来源于维基百科、IMDB、Flickr等 网站或语料库。2015年6月，Freebase整体移入 至WikiData。 2) Wikidata Wikidata是维基媒体基金会主持的一个自由的协作式多语言辅助知识库，旨在为维基百科、维基共享资源以及其他的维基媒体项目提供支持。目前是一个可以众包协作编辑的多语言百科知识库。它是Wikipedia、Wikivoyage、Wikisource中结构化数据的中央存储器，并支持免费使用。 3) DBpedia DBpedia 始于2007年的早期语义网项目，也就是数据库版本的多语言维基百科。是由德国莱比锡大学和曼海姆大学的科研人员创建的多语言综合型知识库。从多种语言的维基百科中抽取结构化信息，并且将其以关联数据的形式发布到互联网上，提供给在线网络应用、社交 网站以及其他在线知识库。DBpedia还能够自动与维基百科保持同步，覆盖多种语言。 4) YAGO YAGO是由德国马普所(max planck institute，MPI)的科研人员构建的综合型知识库。YAGO整合了维基百科、WordNet以及GeoNames等数据源，特别是将维基百科中的分类体系与WordNet的分类体系进行了融合，构建了一个复杂的类别层次结构体系。 YAGO拥有10种语言约459万个实体，2400万个知识三元组。YAGO2包含了100个以上关系类型，20万实体类别，300万实体和2.2亿知识三元组等。是IBM沃森大脑的后端知识库之一。 常识知识图谱\nCyc\nCyc是1984年创建的，作为知识工程时代一项重要进展，最初目标是建立人类最大的常识知识库。 Cyc知识库主要由术语和断言组成，术语包含概念、关系和实体的定义。而断言用来建立术语间关系，通过形式化谓词逻辑进行描述，包括事实描述和规则描述。\nConceptNet\nConceptNet是一个大规模的多语言常识知识库，起源于一个MIT媒体实验室众包项目Open Mind Common Sense（OMCS），其本质为一个描述人类常识的大型语义网络。\nConceptNet目前拥有304个语言的版本，超过390万个概念，2800万个断言，知识三元组正确率约为81%，支持数据集的完全下载。\n中文类知识图谱\n中文开放知识图谱联盟（OpenKG）推动了中文知识图谱普及与应用。 OpenKG借鉴了Schema.org知识众包模式，搭建了中文知识图谱建模、推理、学习的可解释接口规范cnSchema，构建中文知识图谱核心数据结构，包括数据（实体、本体、陈述）、元数据（版本管理、信息溯源、上下文），支持RDF逻辑层、JSON-LD存储层和计算层三个层次的知识表示。 OpenKG技术平台目前已经包含了Zhishi.me、CN-DBPedia、PKUBase、XLore，以及常识、医疗、金融、城市、出行等15类开放中文知识图谱。 垂直行业知识库：特定的行业领域\n1) IMDB IMDB(internet movie database)是一个关于电影演员、电影、电视节目、电视明星以及电影制作的资料库。截止到2012年2月，IMDB共收集了2 132 383部作品资料和4 530 159名人物资料。 2) MusicBrainz MusicBrainz是一个结构化的音乐维基百科，致力于收藏所有的音乐元数据，并向大众用户开放。任何注册用户都可以向网站中添加信息或投稿。 3) ConceptNet ConceptNet是一个语义知识网络，主要由一系列的代表概念的结点构成，这些概念将主要采用自然语言单词或短语的表达形式，通过相互连接建立语义联系。ConceptNet包含了大量计算机可了解的世界的信息，这些信息将有助于计算机更好地实现搜索、问答以及理解人类的意图。 知识图谱应用：\n智慧检索：精准搜索意图理解；搜索对象、粒度多元化；跨媒体搜索； 数据分析：大数据精准分析、精细分析； 智能推荐：场景化推荐；冷启动阶段下的推荐；跨领域推荐；知识型的内容推荐； 自然人机交互：自然语言问答、对话、体感交互、表情交互等； 金融风控：利用实体之间的关系来分析金融活动的风险以提供在风险触发后的补救措施（如联系人等）； 公安刑侦：分析实体和实体之间的关系以获得线索等； 教育医疗：提供可视化的知识表示，用于药物分析、疾病诊断等； ...... 2.8 框架表示法 2.9 剧本表示法 2.10 面向对象的表示法 小结 题目\n3 推理及搜索 3.1 一般搜索原理 3.2 启发式搜索 3.3 与或树搜索策略 3.4 归结/消解演绎推理 ","date":"2024-09-20T09:15:22+08:00","permalink":"https://ffirestorm.github.io/p/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86/","title":"人工智能原理"},{"content":"Introduction OS structure 用户接口 CLI\nGUI\n系统调用 大多数程序通过API来使用系统调用，而不是直接使用系统调用\n1. 程序可移植性 portable 2. 系统调用更加详细且难以使用 system call 是系统主动请求的，而中断是被动的。所以它们本质上是不一样的。但是二者的实现方式是相同的\n系统调用参数传递方式：\n1. 寄存器参数传递 2. 内存块，参数存在内存的块或表中，块地址作为参数通过寄存器传递(Solaris 和 Linux) 3. 栈。程序将参数压入栈，并由os弹出 OS design and implementation 原则：将Policy 和 Mechanism 区分。\nPolicy：做什么 Mechanism：怎么做 区分开来提高灵活性\nOS structure Simple structure：\nMS-DOS UNIX Layered Approach\n每层只使用较低层的功能 major difficulty: careful definition of the layers. Microkernels\nModules\nprocess process concept 程序program 是存储在disk的 passive 实体，而process是active的。二者不是一对一关系的\n进程process包括：\ncode section 代码段 data section 数据段 heap 堆 process stack 进程栈 current activity 当前活动 process state 和 state transform\nPCB\nprocess state PC CPU registers CPU scheduling information: priorities, scheduling queue.. memory management infomation accounting information--CPU time used, clock time... I/O status information: open file list, I/O device list... process number: ID, user ID... process scheduling queues\njob queue: 所有在系统中的进程 ready queue: 已经ready的queue device queues: 每个设备都有一个queue scheduler：\nlong-term scheduler：job scheduler selects which processes should be brought into the ready queue. Short-term scheduler (or CPU scheduler) selects which process should be executed next and allocates CPU Primary distinction: execution frequency. 执行的频率 Medium-Term Scheduling： The process is swapped out, store on disk, and is later swapped in, by the medium-term scheduler. 处理器速度可能比I/O更快，因此可能大部分的进程都在等I/O。这时候可以把这些进程都换出（swap out）到磁盘中，来节省内存空间。等到到这些进程的时候，才把它们换入（swap in）。 context switch：\n上下文在进程的PCB中表示。当进程切换到另一个进程的时候，就要保存当前进程的状态到PCB中，并为新进程加载保存的状态。这称为上下文切换 process operation creation Assign a unique process identifier, an integer number. 分配唯一标识符\nAllocate space for the process 分配空间\nInitialize process control block (PCB) 初始化PCB\n建立适当的联系\n创建或扩展其他数据结构\n资源共享，三种情况：\nParent and children share all resources. 父子进程共享所有资源 Children share subset of parent’s resources. 孩子共享父母资源的子集 Parent and child share no resources. 不共享 进程创建时，获取从父进程传递给子进程的初始化数据\n要么子进程和父进程同时执行，要么父进程等待子进程执行完毕\ntermination 释放PCB还要回收PCB 不允许孤儿进程：父进程exiting后，子孙辈进程全部exiting\ninterprocess communication 进程通信 independent process 独立进程不能影响其他进程的执行或者被影响\ncooperating process 合作进程可以影响别的进程或被影响\ncommunication model\nshared memory\nmessage passing shared memory 运行最大许多和最便利的通信 message passing 当需要较少数据交换时很有用，因为不需要避免冲突\nshared-memory：生产者 —— 消费者问题\n数据结构：循环数组。两个指针：in 和 out 指针 in 指向下一个free position out 指向第一个 full position empty时：in == out full的时候：(in+1)% buffer_size = out Message-passing：interprocess communication (IPC)\n进程间通信无需借助共享变量 步骤： 1. 建立连接 2. 通过send/receive来交换消息 直接通信： 进程必须明确的互相命名 一个链路只与一对进程相关联 链接可以是单向或双向的 indirect communication： 消息从mailbox(ports)发出和接受 mailbox有unique ID 共享mailbox的才能通信 一条link可能有多个processes 每对进程可以共享多条link 链接可以单向也可以双向 threads A thread, called a lightweight process (LWP), is a basic unit of CPU utilization. 是CPU调度的最小单位\n和process的区别：process是资源分配的最小单位\n线程的状态：running、ready、waiting\nparallelism 和 concurrent 联想数据库中并发事务：一段时间内执行多个task\n并行：同个时刻执行多个task\n并行：\ndata parallelism： 可以多线程完成，单每个核处理的数据不同，任务一样 task parallelism： 任务并行，对同一批数据，分布到不同核去左不同任务，max、min、avg 等等 multithread model 多线程模型 两种： 1. user threads 用户线程，不需要kernel支持 2. kernel threads 需要OS直接提供threads\nuser threads:\n通过线程库提供支持，kernel意识不到这些线程 kernel threads:\n以线程为单位进行调度 在kernel space进行线程的creation、schedule、management Win XP、 Solaris、 Linux、 Tru64 UNIX、 MAC OS X user threads 和 kernel threads的三种映射关系：\nMany-to-one model one-to-one many-to-many Many-to-one：\n一个kernel thread对多个user threads 线程管理在用户空间进行 多个线程无法在多处理器上并行，因为一个线程只能访问一个内核 One-to-one\n每个user thread 对一个 kernel thread 在多处理器上可以并行多个线程 Many-to-many\n一个线程调用blocking system calls时，kernel可以调度其他线程 三种模型比较：\n多对一允许开发人员创建他们想要的线程数，但是并不能执行真正的并发 一对一允许更大的并发性，但是要小心不能创建太多线程 多对多可以创建想要的线程数，并且内核线程也可以并发 CPU scheduling 各级调度的区别： schedule criteria\nCPU utilization – keep the CPU as busy as possible MAX throughput (吞吐量) – the number of processes that complete their execution per time unit. MAX turnaround time (周转时间) – amount of time to execute a particular process. MIN waiting time – amount of time a process has been waiting in the ready queue. MIN response time – amount of time it takes from when a request was submitted until the first response is produced, not output (for timesharing environment) 请求到第一次回应 MIN schedule algorithm First-Come, First-Served (FCFS) Scheduling Shortest-Job-First (SJF) Scheduling Priority Scheduling Round Robin (RR) Scheduling Multilevel Queue Scheduling Multilevel Feedback Queue Scheduling Highest Response-Ratio Next (HRRN) scheduling* SJF: Priority——Two schemes:\nPreemptive: preempt the CPU if the priority of the newly arrived process is higher than the priority of the currently running process. 只要优先级最高，就可以直接执行 Nonpreemptive: simply put the new process at the end of the ready queue. 等待当前执行的进程执行完才能执行ready queue里优先级最高的 RR：\n是preemptive的。 时间片最好是能大于80% process的burst time。 ！！！注意调度的就绪队列：进程的时间片结束后追加到队尾，新来的进程也到队尾中 例子：时间片为1 进程 所需 到达 A 4 0 B 3 1-0.001 C 4 2-0.001 D 2 3-0.001 E 4 4-0.001 调度顺序如下： A B A C B D A E C B D A E C E C E multilevel queue scheduling\nmultilevel feedback queue scheduling 多级反馈队列\n会升级，会降级 Highest Rsponse-Ratio Next Scheduling 高响应比优先(HRRN)算法\nR = (W + T)/T = 1 + W/T\nW ： waiting time in ready queue T ： CPU burst time 将会选择R最大的作为下一个调度的\nmultiple-processor scheduling多处理器调度 Affinity(亲和力)：保持进程在同一处理器上运行\nprocess synchronization 进程同步 The critical-section problem Each process has a code segment, called critical section, in which the shared data is accessed.\n每个进程都有一个代码段，在这个代码段中它会访问共享的数据区，这个代码段叫做临界区 3个需求：\n1. mutual exclusion 互斥 2. progress 空闲让进 3. bounded waiting 优先等待 信号量机制 semaphores counting semaphores计数信号量：初始化为可用资源的数量\n当为0的时候，代表所有的资源都被占用了\n使用一个资源时，要先等待，用完再释放\n1 2 3 4 5 6 7 // process Pi while(true){ wait(mutex); critical section; signal(mutex); remainder section; } wait 会让mutex-- signal 会让mutex++ bounded-buffer problem 生产者消费者模型 生产者 —— 往空的地方放，有empty才能放，放好了full+1\n消费者 —— 从有东西的地方拿，full才能拿，拿好了empty+1\n对buffer一次只能一个操作，因此得有一个互斥锁\n初始化：\nmutex = 1; empty = n; full = 0; Reader-writer problem 读写者模型——读优先 读优先，因此要计算读者的数量 —— 资源：reader_counter 有了reader_counter，就要设置一个锁来防止多名读者争用 —— r_mutex 读写互斥，因此需要有一个对资源的锁mutex\n初始化：\nrw_mutex = 1; read_count = 0; rw_mutex = 1; 例题： 例1：4*100 米接力赛:\n本质是一个生产者——消费者模型，但是不用考虑资源争用 第一棒的人生产了一个接力棒给第二棒 第二棒的人消费了第一棒生产的接力棒，并生产了接力棒给第三棒 第三棒的消费第二棒的接力棒，生产了第三棒的接力棒给第四棒 第四棒消费了第三棒生产的接力棒 因此要初始化三个信号量：S12 = 0, S23 = 0; S34 = 0 例2：进程流水线 (1)\n和接力赛一样 (2)\nP1 和 P2是生产者，P3是消费者。但是P1和P2不会共享资源，不用考虑争用 (3) 例3：读者和阅览室\n阅览室管理问题： 某阅览室共有 100 个座位。 读者想进入阅览室，若还有空位，则先在登记本上登记(check in)，然后进入阅览室。离开阅览室之前还要注销登记(check out)。 （注意：每次只能有一个读者check in 或者check out） 若阅览室已经没有空位，则读者等待。 读者之间争用资源：1. 登记本 2. 椅子 不用判断资源是否够用，因为可以一直等。如果不能等的话，椅子就得初始化为一个int变量，这样才能查看椅子的数量。 看ready、running、waiting状态的最多和最少的数目：\nrunning最多：有几个processer就有几个在running的 ready最多：总的进程数减掉processer的数量 waiting最多：有可能所有的process都在waiting 最少的都是0 例4：生产线\n某工厂有一条生产线，其上可以放置10个零件。有三个工人小张、小王和小李。 小张每次生产1个零件A，并放置到生产线上； 小王每次生产1个零件B，并放置到生产线上； 小李每次从生产线上取1个A和2个B，组装产品C。 工人们不能同时使用生产线取放零件。 请用信号量机制实现三个工人进程，确保流水线能够正常工作。 （1）定义信号量及变量，给出其初值，说明其作用 （2）写出三个工人进程的代码结构 注意：和生产者——消费者模型不太一样。 A有上限8，B有上限9，且生产线的空位是10，因为要有一个代表10个位置的信号量。 roomA = 8， partA=0 roomB = 9， partB=0 room = 10， 不需要part 这里的生产者和消费者其实只是在A和B上，生产线只是用来限制的A和B的个数的\n例5：读共享，写优先\n某系统中有m个进程并发执行，分为A、B两组，他们共享文件F，A组进程对文件F进行写操作，B组进程对文件F进行只读操作。写操作需要互斥进行，读操作可以同时发生，即当有B组的某进程正在对文件F进行读操作时，若没有A组的进程提出写请求，则B组的其他进程可以同时对文件F进行读操作，如果有A组的进程提出写请求，则阻止B组的其他进程对文件F进行读操作的后续请求，等当前正在读文件的B组进程全部执行完毕，则立即让A组提出写请求的进程执行对文件F的写操作。 （1）定义信号量及变量，给出其初值，说明其作用 （2）写出A组和B组进程的代码结构 首先，写优先，因此读者争用资源前，看有没有写的已经在等了。 第一名写者要获取写优先的权力，如果后面还有写者，再交给下一位。没有写的，就释放 同一批读者读完之后，写的才能进入写 例6：三小或一大 deadlock 死锁特征：\n1. 互斥使用 Mutual exclusion 2. 占有并等待 hold and wait 3. 非抢占 no preemption 4. 循环等待 circular wait Resource-Allocation Graph\n圆圈：进程节点 方形：资源结点 方形内的圆圈：资源实例 进程到资源的边 Pi -\u0026gt; Rj 请求边 资源到进程的边 Rj -\u0026gt; Pi 分配边 死锁一定有环路，环路不一定有死锁\n死锁避免 avoidance 资源分配图算法\n用资源分配图，如果不成环，就可以分配资源\n银行家算法\nn个进程 m种资源类型 数据结构描述\nAvailable：一维数组，available[j] = k 表示Rj有k个可用 Max：二维矩阵n*m。Max[i, j] = K, 那么Pi进程就可能会请求k个Rj Allocation：n*m 二维矩阵。Allocation[i, j]=k, 那么现在Pi有k个Rj资源 Need：n*m二维数组，Need[i, j] = Max[i, j] - Allocation[i, j] 算法流程：safety algorithm\n初始化： Work = Available Finish[i] = false 工作流程： 找到一个Pi: (1)Finish[i]=false\n(2)Need[i]\u0026lt;=Work 如果没找到，就跳到4 Work += Allocation[i] // 表示当前进程结束后，资源可以变成多少 Finish[i] = true 转到2，继续找 如果所有的Finish都为true，那么就是safety状态，否则就不是safety 算法流程：resource-request algorithm 资源请求算法\n如果某一个进程当前急需某些资源，要检测该算法之后才能分配\n先征信：如果Request[i] \u0026gt; Need[i]，error 如果Request[i] \u0026gt;= Available, 那就等待。如果是\u0026lt;=的话，继续3 Available = Available - Request[i] Allocation[i] = Allocation[i] + Request[i] Need[i] = Need[i] - Request[i] 使用safety algorithm进行检测，如果处于安全状态，就可以分配，否则不行 死锁检测 Detection algorithm\nAvailable Allocation request n*m 初始化 Work = Available 在初始化的时候就要判断： 如果allocation[i] ≠ 0， 那么Finish[i] = false 如果allocation[i] ==0, 那么Finish[i] = true 基本上都是false了 遍历，找Finish[i]==false的，并且请求的数量小于当前的Work，即Request[i]\u0026lt;=Work,如果没右，就去4 Work = Work + Allocatoin[i]， Finish[i] = true 然后继续去2找 如果大家都是true，那么就不是死锁。如果有一个是false的，说明处于死锁状态 Main Memory 连续内存分配 可变分区方案\nHole：一块可用的内存 一开始是一个大的hole。内存中散布着大小不一的hole OS维护一个包含信息的table：哪块被分配给哪个进程了，哪块是hole 进程会被分配到和它需求相等的内存块 进程结束后，将它的内存释放。相邻的free block会合并成一个hole Many small holes in the memory, external fragmentation，外部碎片 三种分配方式：\n1. first fit 分配第一个满足大小的hole 2. best fit hole先按大小排序，分配最小的可以满足需求的hole 3. worse fit 分配最大的洞 三种分配方式都有外部碎片 外部碎片：\n总内存大小是满足分配需求的，但是分配的空间并不是连续的 内部碎片：\n分配的空间略大于需求的空间 page 页式管理 进程的物理地址可以不连续\n物理地址被分成相同大小的块，frames\n逻辑地址被分成相同大小的块，pages\n每个 frames/pages 的大小都是2的整数幂\n当一个进程要被使用的时候，它的pages从blocks中被加载到任意可用的frames\n避免的外部碎片，避免了不同大小的内存块(chunks)问题\nOS通过page table 来追踪某个逻辑page被分配到哪个frame。page number作为下标\n在最后一个page会有内部碎片\n每个逻辑地址都被分成：page number(p)、page offset(d)\n每个page都会有一个对应的逻辑地址和物理地址：\n逻辑地址，高位的n个bit受page数量决定的，offset是page_size决定的 物理地址，高位的k个bit受内存的总frames数量决定，offset是page_size决定的 这里的虚拟内存，表示有程序实际上大于了物理内存的大小，所以会对内存进行扩展，才能运行这些程序。\n逻辑地址转为物理地址的时候，用 逻辑地址/page size，得到商和余数。商是页码(从0开始)，余数offset\n物理设备支持：\nPage-table base register (PTBR) points to the page table. Page-table length register (PTLR) indicates size of the page table. 在该方案中，每次都要进行两次内存访问：1. table 2. 指令\n为了优化，引入TLB( translation look-aside buffers / associative memory)，可用类比cache\nTLB\n包含最近使用过的页表条目 TLB中，没条目都由键值对(page#, frame#)组成，代表逻辑地址到物理地址的映射 如果TLB里没有想要的页表条目，才会去页表中查找 Effective access time(EAT)有效访问时间\n假如在TLB中找到了，就只需根据TLB中的物理地址访问一次内存 如果在TLB中没找到，那么就得查page table，再根据page table查物理地址，这样需要两次访问内存。 ε是查TLB的时间，t是访问内存的时间，α是TLB的命中率 页式内存保护 Memory protection\n实现方式通过每一个frame对应的protection bit，这些信息存放在页表中 RW bit，只读或者可读可写 Valid-invalid bit, valid表示关联的页面在进程的逻辑地址中，invalid表示不在逻辑地址中 页表的结构 Hierarchical Paging\nTwo-level paging Hashed Page Tables Inverted Page Tables\nOne entry for each real frame of memory. 每个条目都有存储在该实际地址的 页面的虚拟地址，以及拥有该页面的进程信息 \u0026lt; process-id, page-number, offset \u0026gt; 通过pid 和 p来page table找，然后再从物理地址中读取 segment 段式管理 逻辑地址: a segment number and an offset, 段号和offset\n\u0026lt;segment-number, offset\u0026gt; segment table 段表：\n每个条目都是： Segment base – 每个段在内存中的起始地址 Segment limit – specifies the length of the segment.指定段的长度 Segment-Table Base Register (STBR) points to 内存中段表的位置.\nSegment-Table Length Register (STLR) indicates 一个程序用的段数.\nsegment number s is legal if s \u0026lt; STLR.\n该程序一共有5个段，每个段都分配了一个内存空间，它们在物理内存中不一定连续\n有外部碎片\n段页式管理 先分段，再分页。每一页可以放到不相邻的位置\n虚拟地址构成：\n进程的逻辑地址空间被划分成段，每个段有自己的段号S。 段内的代码或数据，按照内存页面的大小划分为若干页。 段表和页表\n每个进程有一张段表 管理内存的分配与释放、存储保护和地址变换等。 每个表项记录对应段的页表的起始地址和页表长度。 每个段有一张页表 保存段中的每个逻辑页在物理内存中的内存块号 逻辑地址转物理地址： 虚拟内存 demand paging 如果内存中没有free frame，就会找victim\n1. 如果要使用某一页，都是内存中没有，会产生一共trap ——\u0026gt; page fault 2. 保存用户寄存器和进程状态 3. 确定是不是page fault 4. OS 会查看是否合法。并确定页面在磁盘上的位置 5. 从磁盘向free frame读取page： 1 在设备队列中等待，直到读取请求被服务 2 等待寻道、延迟时间 3 开始传输 6. 等待的时候，CPU去调度其他用户进程 7. 从磁盘I/O子系统收到中断 —— 读取完成 8. 保存6.的其他用户进程状态信息 9. 判断中断来自磁盘 10. 更改页表和其他表的信息 11. Ready，等待CPU重新调度该进程 12. 恢复用户进程、用户寄存器等，然后restart 引起缺页中断的指令 Performance： p是缺页率。公式的意思就是，没有缺页的内存读取时间 加上 缺页的时候处理缺页的时间\n例题\nOn a system using paging, references to a swapped-in locations accessible through an entry in an associative table (TLB) take 150ns.If the main memory page table must be used, the reference takes 400ns. References that result in page faults require 8ms if the page to be eplaced has been modified, 3ms otherwise. If the page fault rate is 2%, the associative table(TLB) hit rate is 70%, and 50% of replaced pages have been modified, what is the effective access time? Assume the system is running only a single process and the CPU is idle during page swaps. 通过TLB表需要150ns，通过内存中的页表访问需要400ns，只写进需要3ms，写进+写出需要8ms。 不缺页：98%， 缺页：2% 不缺页时，TLB命中：70%， 剩下的去找页表 缺页时，只需要写进和需要换入换出的各为50% 答案就是：\n3ms*50%*2% + 8ms*50%*2% + 150ns*70%*98% + 400ns*30%*98% 如果题目直接给了memory access time，不用把它*2，因为它是到达内存中指定页面的时间。\npage replacement 页面置换 对用户透明\npage table 中，如果某个表项是invalid(valid bit是0)，说明不在内存中，使用到它的时候，要产生一共page fault reference string 这些是地址。页面大小是100B，所以每个地址除以100就得到page number\nFIFO 存在 Belady\u0026rsquo;s anomaly\nOptimal\n选择最远的将来才用到的页面置换出去 并且反序的缺页率和正序的一样。\nLRU\n置换出去的是最近最不常使用的 反序的缺页率和正序的一样\nframes allocation 一地址指令所需的最少frames：2(一个存放instruction， 一个存放地址指向的data)\n如果允许一级间址的话，那最少需要3个frames(一个存指令，一个存间址指向的空间，一个存间址空间指向的数据)\n如果是二地址指令，且允许间址的话，则至少需要5个frames：一个存指令，一个存源地址间址，一个存源间址指向的数据，一个存目的间址，一个存目的间址指向的数据\nthrashing 抖动 频繁swap，page in/out的时间远远多余进程执行时间\nworking-set model 工作集模型\n用来监控工作过程访问了哪些页面 working set是动态变化的，它存放了most recent Δ page references(这段时间内要用的page) 工作集的大小 WSS 是会变化的 WSSi 用来描述进程i的在这一段时间所需要的frames数 将所有进程的 WSS加起来看作为D 假如D \u0026gt; available frames，就会产生thrashing 现象 File-System Interface File concept contiguous logical address space 逻辑地址连续 file是命名相关信息的集合 文件是logical secondary storage的最小分配(allotment) 可以是自由形式，可以是严格格式化的 文件的属性：\nname ID 每个文件都有一个唯一的id Type Location size protection —— authority time， date， userid 属性防止目录结构中，目录结构保存在disk 文件操作：\nopen file table：一个kernel 的数据结构，保存了所有打开的文件 open(Fi)： 1. 找到Fi的目录结构中的entry 2. 将entry调到open-file table中 3. 返回一个指向open-file table 中该 entry的指针 close(Fi) 最新的文件写回目录结构中 internal table 的两级：\n1. 进程打开文件表 记录了该进程打开的文件 保存了该进程使用该文件的信息，比如当前指针，权限等 2. 系统打开文件表 记录了与进程无关的信息，如磁盘上的文件位置，访问日期，文件大小等 文件的结构：\n逻辑结构： 1. text 8bit 的字节序列 2. record 具有固定或可变长的记录序列 物理结构：a set of disk blocks directory structure 树形、无环图\n文件共享、同步\nFile-System Implementation 文件系统结构 最上层： 给文件操作提供的系统调用 逻辑文件系统层： 处理metadata，处理目录结构，通过FCB保存文件结构，还需要protection和security 通过FCB 将file name 转成 file number，file handle(在进程打开文件表的位置) 文件组织模块： 逻辑地址到物理地址转换 空闲空间组织 basic file system： 向适当的device driver发出命令，来读写disk上的物理块(将高级语言转成设备驱动的命令) 管理memory buffers 和 caches (做空间分配、释放、置换) I/O control： 设备驱动程序和中断处理程序。在主存和磁盘系统间传输信息。(将设备驱动程序命令转成低级硬件的控制命令) 底层设备 文件系统实现 长期保存、按名访问、工作效率\n不同进程共享同一个文件时，进程打开文件表表项都指向同一个系统打开文件表表项\n虚拟文件系统 Allocation Methods 分配方法 三种方法：\n1. contiguous allocation 连续 2. linked allocation 链接 3. indexed allocation 索引 连续分配 占用的磁盘块是连续的 只有一个表项在 file allocation table 保存起始块号 和 总的块数 （起始、长度） 可以顺序，也可以随机访问 性能最好：定位次数少，时间最少 逻辑地址向物理地址映射： LA / block size = Q ... R ——\u0026gt; Q 是逻辑块号，R是块内偏移量 链接分配\n目录中保存了文件的第一块和最后一块指针 每一块都有指向下一块的指针 没有外部碎片，任意空闲块都能使用 只能顺序访问，要预留指针，有可能断链（不可靠） 索引分配\n索引块依次记录物理块 目录包含了索引块的块号 没有外部碎片，随机access 空闲空间管理 Bit map / Bit vector Linked list Grouping Counting bit map 位图\nEach block is represented by 1 bit. 1 是空闲，0是被占据 grouping 分组 每组最后一个空闲块用来当指针域，指向下一组的空闲块 空间管理例题： (1) 7 + 3*10 = 37 (2) 2 mass storage disk schedule 磁盘调度 FCFS first come first served sstf shortest seek time first scan c-scan look c-look FCFS 183-53+183-37+122-37+122-14+...+67-65 = 640 SSTF 65-53+67-65+67-37+37-14+98-14+122-9+124-122+183-124 = 236 SCAN 来回扫描 199-53 + 199-14 = 400-69 = 331 C-SCAN 只在一个方向SCAN，不换方向。 199 + 199-53 + 37 = 400 - 18 = 382 LOOK LOOK是SCAN的升级版，它最远只会走到最远的那个请求点，然后就会返回 183-53+183-14 = 366-67 = 299 C-LOOK C-LOOK是C-SCAN的升级版，它到最远的需求点之后，会返回到另一头的最远需求点，然后继续向同一方向寻道 183-53+183-14+37-14 = 403-81 = 322 例子 disk management 先找到bootstrap， 通过bootstrap 找到boot block ，再找到system disk\n","date":"2024-09-20T08:35:32+08:00","permalink":"https://ffirestorm.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统"},{"content":"词法分析 正规表达式 所有不含子串011的01符号串\n首先构造自动机 将自动机变成单一结束状态，加上ε，连到最后的状态 合并状态 语法分析 （重难点） 自顶向下 LL(1) 自顶向下\n消除左递归，消除左公因子\nFIRST FIRST(a)是a可以推导出的开头终结符号集合 FOLLOW 文法判别 只要同一个非终结符推导出的不同字符串的首符不一样就可以了\n分析表构建 行有非终结符，列是终结符+$\n查看每个产生式A -\u0026gt; B\n查看整个字符串B的首符集，将 A -\u0026gt; B放到每个首符α 下：\nMap[A][α] = A -\u0026gt; B\n如果说ε在B的首符集里面，那就把 A -\u0026gt; B 放到每个A的FOLLOW符号β下：\nMap[A][β] = A -\u0026gt; B\\\n每个格子都可以放很多个生成式\n分析 字符串从左往右扫描，右边是字符串结束符合$\n符号栈栈底为$，开始时还要放入文法开始符号\n如果对于字符串的最左边的字符a，符号栈栈顶A来说，Map[A][a]有产生式的话，就将A弹出，用产生式A -\u0026gt; αBβ ，逆序入栈。并输出产生式\n如果字符串最左边字符和栈顶符号一样，那就两个一起弹出。\n自底向上 简单的LR方法(SLR)：易于实现，功能较弱\n规范的LR方法(LR(1))：功能最强，代价最大\n向前看的LR方法(LALR)：功能和代价介于两者之间，能分析大多数程序设计语言的结构，并且能比较有效地实现\nLR 进行规约的时候，要把符号栈中的符号和状态一起弹出来。\n注意：产生式 A -\u0026gt; ε 只有一个LR(0)归约项目 A -\u0026gt; ·\n闭包 SLR(1) SLR(1)的特征：\n如果文法的有效项目集中有冲突动作，多数冲突可通过考察有关非终结符号的FOLLOW集合而得到解决\n如项目集：I={X-\u0026gt;α·bβ，A-\u0026gt;α·，B-\u0026gt;α·}\n存在移进-归约冲突 (X和A、B产生式) 存在归约-归约冲突 (A和B产生式) 解决冲突的办法：\n假设： FOLLOW(A)∩FOLLOW(B)=空 b不属于FOLLOW(A) 并且 b不属于FOLLOW(B) 决策：\n当a=b时，把b移进栈里； 当a∈FOLLOW(A)时，用产生式A-\u0026gt;α进行归约； 当a∈FOLLOW(B)时，用产生式B-\u0026gt;α进行归约。 看是谁的FOLLOW符号，就用谁的产生式规约\n看是否是SLR(1) I5中，对于LR(0)有移进-规约冲突，但是S-\u0026gt;dAB·归于中，S的FOLLOW集是{$}，而B-\u0026gt;B·b当前如果是b才会移进。由于S的FOLLOW集和B的移进不一样，所以不冲突\nI4中，对于A-\u0026gt;a·, 由于A的FOLLOW集是{$,b}而这个项目里移进的只有a或者A，A的FIRST又是a，所以这两个不冲突。\n构造SLR(1)分析表\n要看规约项目的FOLLOW。\n例子 例子1 无冲突 +不是在E\u0026rsquo;的FOLLOW集中，所以可以移进，也可以规约\n例子2 有冲突 因为移进是=，而规约的FOLLOW也是=，存在冲突\nLR(1) 观察可以发现，I0的C是第一个C，第一个C后面跟着的是另一个C，所以I0对于C的产生式，它们的向前看符号是c/d，因为第二个C的FIRST是c/d，或者说，第一个C的FOLLOW是c/d\n而对于I2，它后面没跟其它符号了，所以后面跟着的是$，表示结束。\n对于I3和I4，由于它们是从第一个C推出来的，所以后面跟着的是第二个C，因此向前看符号也是c/d\n同理，对于这三个项目集，它们是第二个C推出来的，所以后面跟的是结束符号\nLR(1)分析表构造方法： 与SLR分析表构造方法的不同点：\n对归约项目，LR(1)用向前看符号，SLR用FOLLOW集\nLALR(1) 如果两个LR(1)项目集去掉向前看符号之后是相同的，则称这两个项目集具有相同的心（core），即这两个项目集是同心集。\n除去初态项目集外，一个项目集的核（kernel）是由该项目集中那些圆点不在最左边的项目组成。LR(1)初态项目集的核中有且只有项目[S\u0026rsquo;-\u0026gt;·S,$]\n合并同心集\n不会有新的移进-规约冲突，但是会有新的规约-规约冲突\nLALR(1)分析表构造思想：\n1. 首先构造LR(1)项目集规范族； 2. 如果它不存在冲突，就把同心集合并在一起； （如果冲突的话，就不是LR(1)文法了） 3. 若合并后的项目集规范族不存在归约-归约冲突，就按这个项目集规范族构造分析表。 tips:如果合并后得到的项目集规范族中含有冲突，则该文法是LR(1)文法，但不是LALR文法，因而，也不能为它构造LALR分析表。 语法制导翻译（重难点） 综合属性：\n分析树中，如果一个结点的某一属性由其子结点的属性确定，则这种属性为该结点的综合属性 如果一个语法制导定义仅仅使用综合属性，则称这种语法制导定义为S-属性定义 对于S-属性定义，通常采用自底向上的方法对其分析树加注释，即从树叶到树根，按照语义规则计算每个结点的属性值 继承属性：\n分析树中，一个结点的继承属性值由该结点的父结点和/或它的兄弟结点的属性值决定。 可用继承属性表示程序设计语言结构中上下文之间的依赖关系\n可以跟踪一个标识符的类型 可以跟踪一个标识符，了解它是出现在赋值号的右边还是左边，以确定是需要该标识符的值还是地址。 依赖图 为每个包含过程调用的语义规则引入一个虚拟综合属性b，以便把语义规则统一为b=f(c1,c2,…,ck)的形式。\n依赖图中：\n为每一个属性设置一个结点 如果属性b依赖于c，那么从属性c的结点有一条有向边连到属性b的结点。 计算次序：\n有向非循环图的拓扑排序 S属性定义和L属性定义\nS属性定义：仅涉及综合属性的语法制导定义 L属性定义：一个语法制导定义是L属性定义，如果与每个产生式 A-\u0026gt;X1X2…Xn 相应的每条语义规则计算的属性都是A的综合属性，或是 Xj（1\u0026lt;=j\u0026lt;=n）的继承属性，而该继承属性仅依赖于： A的继承属性； 产生式中Xj左边的符号X1、X2、…、Xj-1 的属性； L可以相当于Left，由左边的符号定义 每一个S属性定义都是L属性定义 L属性就是属性值都是由该符号左边的符号来定义的，上图中的Q.i是由右边的R.s来决定的，所以不是L属性定义。 左边计算的是综合属性， 右边计算的是继承属性，依赖于兄的继承属性，且兄的继承属性只能依赖于父的继承属性或者兄兄的属性 L属性计算顺序 以分析树的根结点作为实参 L属性定义的属性都可以用深度优先的顺序计算。 进入结点前，计算它的继承属性 从结点返回时，计算它的综合属性 翻译方案的设计： 对于S属性\n为每一个语义规则建立一个包含赋值的动作 把这个动作放在相应的产生式右边末尾 T-\u0026gt;T1*F {T.val=T1.val*F.val} 对于L属性\n产生式右部文法符号的继承属性必须在这个符号以前的动作中计算出来 计算该继承属性的动作必须出现在相应文法符号之前 一个动作不能引用这个动作右边的文法符号的综合属性 产生式左边非终结符号的综合属性只有在它所引用的所有属性都计算出来之后才能计算 这种属性的计算动作放在产生式右端末尾 1. 产生式右部的某文法符号的继承属性必须在该符号以前的规则中计算出来 2. 一个语义规则不能引用它右边的文法符号的综合属性 3. 产生式左部符号的综合属性只有在它所依赖的所有属性都计算出来之后才能计算。计算左部符号的综合属性的语义规则通常可以放在产生式的右端末尾 语法树 抽象语法：把语法规则中对语义无关紧要的具体规定去掉，剩下来的本质性的东西称为抽象语法。\n语法树\n分析树的抽象（或压缩）形式。 也称为语法结构树或结构树。 内部结点表示运算符号，其子结点表示它的运算分量。 L属性自顶向下翻译 由于L属性要自顶向下翻译，所以：\n消除翻译方案的左递归\n其中，(2)(4)包含左递归 并设计M的属性\n继承属性M.i：表示在M之前已经推导出的子表达式的值 综合属性M.s：表示在M完全展开之后得到的表达式的值 这是将M展开前的M.i赋值给M展开后的M.s，这样才能成功将值传递到E上\n可在设计翻译方案之前先画出语法分析树，并写出结点，以及结点的依赖关系\nE-\u0026gt;TM，在M展开前，先获得M.i的值，就是T的值，在M展开后，将M.s赋给E。\n其中，M.s是通过M-\u0026gt;ε 这条语句来赋值的\nM.i 是未展开前的，M.s是展开后的，因此M1.i依赖于未展开前的M.i，和它的兄结点T.val 可以这么说，对于一个表达式a+b+c+M，M.i存储的是a+b+c的结果，M.S存储的是加上M的结果。\n消除翻译方案中的左递归的一般流程：\n消除文法中的左递归 为R设计综合属性和继承属性 画分析树，转换翻译方案 预测翻译程序的设计 自顶向下的语法制导预测翻译程序\n(1) 为每个非终结符号A建立一个函数(可以是递归函数)\nA的每一个继承属性对应函数的一个形参 A的综合属性作为函数的返回值 A产生式中的每个文法符号的每个属性都对应一个局部变量 (2) A的函数的代码由多个分支组成\n(3) 与每个产生式相关的程序代码\n按照从左到右的顺序考虑产生式右部的记号、非终结符号和语义动作 对带有综合属性x的记号X 把属性x的值保存于为X.x声明的变量中 产生一个匹配记号X的调用 推进扫描指针 对非终结符号B 产生一个函数调用语句c=B(b1,b2,…,bk) bi(i=1,2,…,k)是对应于B的继承属性的变量 c是对应于B的综合属性的变量 对每一个语义动作 把动作代码复制到分析程序中 用代表属性的变量代替翻译方案中引用的属性 引入标记非终结符改造为LR方法翻译(重点) 所有语义规则都恰好在规约之前执行\n要对L属性定义改造，符号自底向上\n移走翻译方案中嵌入的语义规则 使所有嵌入的动作都出现在产生式的右端末尾\n在基础文法中引入新的产生式，形如：M-\u0026gt;ε M：标记非终结符号，用来代替嵌入在产生式中的动作 把被M替代的动作放在产生式M -\u0026gt; ε 的末尾 示例： 直接使用分析栈中的继承属性 终结符号的属性随着移进动作进入val栈 非终结符的属性随着规约动作进入val栈 对于产生式A-\u0026gt;XY\n假设有X.s综合属性，它在随着X一起进入栈中。由于在规约出Y之前，X.s就已经在val栈中，所以X.s可以被Y继承。\n如果Y的继承属性Y.i通过复制规则Y.i = X.s获得，那么在需要Y.i值的地方便可以直接使用栈中的X.s的值。\n对于这个例子，由于每次赋值的时候，都知道T的位置，就是id的位置下面3个，即top-3，所以可以使用在栈中的继承属性来赋值\n要想直接从栈中获取继承属性，\n当且仅当计算继承属性的语义规则是复制规则，\n并且继承属性的值在栈中的存放位置可以预测\n变换继承属性的计算规则 要想从栈中取得继承属性，当且仅当文法允许属性值在栈中存放的位置可以预测。 因为Z.i的值是由X.s的值决定的，X可能在Z的前一个或者Z的前两个位置，所以无法预测。\n对于不是复制规则的赋值来说，也可以引入标记非终结符号，来转变成复制规则 为了在分析的同时进行翻译，每个文法符号的属性都要入栈，综合属性可以放在与文法符号对应的栈中Val数组中，继承属性则放在标记非终结符对应的Val数组中，由于是L-属性定义，在标记非终结符处一定可以计算继承属性\nL属性自底向上分析和翻译算法：\n首先假设：\n每个非终结符号A 都有一个继承属性 A.i 每一个文法符号X 都有一个综合属性 X.s （1）引入新的标记非终结符号来代替原来的产生式 （2）在自底向上分析过程中，各个属性的值都可以被计算出来 第一种情况：用 M-\u0026gt;ε 规约\nMj在文法中只出现一次，对于另一条产生式，如果要变化，需要取其他名字，如N、L等 第二种情况：将所有有关符号规约成一个非终结符\nA.i 是在未展开之前计算的，所以在可规约串的栈位置下面，\n对改写产生式的简化，以减少可能导致的分析冲突\n如果Xj没有继承属性，不使用标记非终结符Mj 如果X1.i由复写规则X1.i:=A.i计算，可以省略M1 换句话说就是只对有继承属性的X添加标记非终结符\n对于第一个符号，由于A就在它栈位置的前一位，所以不用再多搞一个标记非终结符出来\n改写语法制导定义为S属性 语法定义 符号表作用、操作 插入\n检索\n定位\n重定位\n类型表达式 基本类型\n重命名\n类型构造器\n数组：array(I, T)，其中I是下标范围，如0..9，1..10这样。T是元素类型\n笛卡尔积：比如C语言中的int a，就变成 a X integer\n记录类型： 指针类型： 函数： 类型表达式可以包含变量（称为类型变量），变量的值是类型表达式。\n复合类型要用record括起来！！！ 类型等价 结构等价 名字等价 1 2 3 4 5 6 7 8 9 typedef struct { int age; char name[20]; }recA; typedef recA *recP; recP a; recP b; recA *c, *d; recA *e; 类型图 / 树 类型树的中序遍历就是这个类型构造器\n运行环境 程序运行期间，名字的值有左右之分\n左值；存储空间的地址 右值：存储空间的内容 两个函数\nenvironment：代表 名字 ——\u0026gt; 存储单元 state：存储单元 ——\u0026gt; 里面内容 赋值改变状态，不改变环境 静态和动态：\n静态： 动态： 过程定义 过程的活动 名字声明 名字的绑定 名字的作用域 绑定的生存期 活动记录：\n1. 返回值域：存放返回给调用过程的值 2. 参数域：存放由调用过程提供给该活动的实参 3. 控制链域：用于本次活动结束时实现控制返回到调用过程。 总是指向本次活动的调用者的活动记录。即调用过程的最新活动的活动记录 4. 访问链域：这是为了实现过程对非局部名字的访问而设计的一个指针域。 它总是指向该过程的直接外层过程的最新活动的活动记录。 5. 机器状态域：保存本活动开始前的活动现场信息 6. 局部数据区：局部数据分配的空间 7. 临时数据区：过程的中间值分配的空间 存储分配策略：\n静态 栈式 堆式 静态：运行前对每个名字都分配好了固定空间。\n数据对象的大小和它们在内存中的位置必须在编译时都能够确定 不允许过程递归调用 一个名字对应一个空间 不能建立动态数据结构 栈式：\n1. 活动开始时，与活动相应的活动记录入栈。 2. 局部变量的存储空间分配在活动记录中，同一过程中声明的名字在不同的活动中被绑定到不同的存储空间。 3. 活动结束时，活动记录出栈。 4. 分配给局部名字的存储空间被释放。名字的值将丢失，不可再用。 5. 性质：每次活动时局部量绑定到新的存储，当活动结束时，局部量的值删除 堆式：\n访问链指向声明块的上一级块\n控制链指向调用块\n函数作为参数传入要自带访问链！！！\n参数传递机制 传值调用\n先计算好实参的右值，然后传递给函数。函数使用的时候和常数一样 引用调用\n原则上要求：实参必须是已经分配了存储空间的变量。\n调用过程把实参存储单元的地址（即一个指向实参存储单元的指针）传递给被调用过程的相应形参。 可以把形参看成是实参的别名，对形参的任何引用都是对相应实参的引用。\n调用过程对实参求值。\n如果实参是具有左值的名字或表达式，则传递这个左值本身。\n如果实参是一个没有左值的表达式（如a+b或2等），则为它申请一临时数据空间，计算出的表达式的值并存入该单元，然后传递这个存储单元的地址。\n把实参的左值写入被调用过程活动记录中相应形参的存储单元中。\n被调用过程执行时，通过形参间接地引用实参。\n复制恢复\n(1) 将实参的右值传递给被调用过程，写入其活动记录的参数域中，并记录与形参相应的实参的左值。\n(2) 被调用过程执行时，对形参的操作在自己的活动记录的参数域空间上进行。\n(3) 控制返回时，被调用过程根据所记录的实参的左值把形参的当前右值复制到相应实参的存储空间中 。只有具有左值的那些实参的值被复制出来。 调用时是把实参的右值复制入被调用过程活动记录的形参单元\n返回时是把形参的结果从其活动记录复制出来，复制到调用过程活动记录实参左值确定的单元\n传名调用\n把过程当作“宏”处理，即在调用出现的地方，用被调用过程的过程体替换调用语句，并用实参的名字替换相应的形参。这种文字替换称为宏扩展。 用实参的字面形式替换相应的形参 被调用过程中的局部名字不能与调用过程中的名字重名。 可以考虑在做宏扩展之前，对被调用过程中的每一个名字都系统地重新命名，即给以一个不同的新名字。 为保持实参的完整性，可以用括号把实参的名字括起来。 中间代码生成 图形表示 语法树\n语法树的中序遍历得到的结果和原语句一样 后缀式 是语法树的线性形式：使用语法树的后序遍历\ndag图\n三地址码 三地址代码是语法树或dag的线性表示，\n其中 新增加的名字（临时变量）对应图中的内部结点\n四元式\n对应语法树的每个内部结点都有一句代码（虽然说计算了重复的东西）\n三元式\n为了不引入临时变量 一个语句计算的中间结果直接提供给引用它的语句 用计算中间结果的语句指针代替存放中间结果的临时变量 同样的，对应语法树的每个内部节点都有一个语句。 数组元素赋值的三元式序列：\n间接三元式\n作用：如果只用右边，删掉一条语句之后很麻烦。现在用间接码，在修改完右边后可以根据指针一次性执行完，可以不用管右边的实际顺序。 涉及数组元素的赋值语句 一维数组：\n数组下标：low..high A[i]的位置：base + (i-low) * w = i * w + base - low * w low * w 固定不变。 二维数组：\n每维的下界：low1、low2 每维的上界：high1、high2 每维的长度：n1 = high1-low1 n2 = high2-low2 域宽：w 基址：base A[i, j]的位置： 先算前面有几行：i-low1 行。每行的长度：n2 再算当前处于该行的什么位置：第j-low2 列 所以处于第 (i-low1)*n2 + j-low2 个元素 所以地址是 base + ((i-low1)*n2 + j-low2)*w = (i*n2+j)*w + base - (low1*n2 + low2)*w 最后减掉的部分是定长的。 A是一个1020的数组，即 n1=10，n2=20； 设数组元素的域宽 w=4； 设数组的第一个元素为：A[1,1]， 则有 low1=1，low2=1 所以： (low1*n2+low2)*w = (1*20+1)*4 = 84 布尔表达式的翻译 数值表示法\n先看优先级，确定语句执行的顺序 然后再进行翻译\nx \u0026gt; y 等价形式：if x \u0026gt; y then 1 else 0 if (true) goto t:=0 可以看到，当表达式为真的时候，会跳过下两条。\n而不成立，则顺序执行，存好0后，就跳过下一条\n举例：a\u0026gt;b and c\u0026gt;d or e\u0026lt;f 优先级： and \u0026gt; or，先算 左边，再算or的\n每一步都有一个中间结构，所以跳转到哪条语句可以直接写\n控制流法\n三种形式如下：\nif E then S : E 为 false就跳转到S1后面。S1紧跟E的语句 if E then S1 else S2 S1 紧跟E ， S2和S1之间有一个goto语句。E为真，就顺序执行，E为假就跳转到S2 while E do S1 S1 紧跟 E。S1 的最后一条语句是跳转回E。E为假，就跳转到S的下一条语句上。 布尔表达式的代码结构： E -\u0026gt; E1 or E2 E1 如果是true，就直接跳转了，不用看E2。E1是false才要顺序执行看E2\nE -\u0026gt; not E1 E -\u0026gt; E1 and E2 E -\u0026gt; id1 relop id2 控制流回填技术 先产生没有填写目标标号的转移指令； 建立一个链表，把转向这个目标的所有转移指令的标号填入该链表； 目标地址确定后，再把目标地址填入该链表中记录的所有转移指令中。 用回填技术翻译 a\u0026gt;b and c\u0026gt;d or e \u0026lt; f, 假设起点为100\n第一步：翻译 a\u0026gt;b 100：if a\u0026gt;b goto -- 101：goto -- 这时候，true的回填表为{100}，false的表为{101} 第二步：翻译 c\u0026gt;d 102：if c\u0026gt;d goto -- 103: goto -- 这个时候由and的结构，我们已经制导了100应该填什么了，就把102填到100里 但是如果102 也是true的话，那就可以跳过 e\u0026lt;f 这个判断。因此要把102放到true-list里面。103放入false-list里。 true = {102} false = {101, 103} 第三步：翻译 e\u0026lt;f 104：if e\u0026lt;f goto -- 105: goto -- 由于 e\u0026lt;f 是前一个条件为false才执行的，因此可以把104回填到101和103中 而104要放入truelist中，105放入false-list中。 true:{102, 104} false:{105} 第四步：根据后续代码回填 目标代码生成 基本块 控制从第一条语句（入口语句）流入，从最后一条语句（出口语句）流出，中途没有停止或分支\n具有原子性的一组连续语句序列\n确定入口语句：\n三地址代码的第一条语句； goto语句转移到的目标语句； 紧跟在goto语句后面的语句。 确定基本块：与每一个入口语句相应的基本块\n从一个入口语句（含该语句）到下一个入口语句（不含）之间的语句序列； 从一个入口语句（含该语句）到停止语句（含该语句）之间的语句序列。 1. 找到goto语句，goto的目标和goto下一句都是入口 2. 入口和入口间划分基本块 流图 流图的结点是基本块 如果一个结点基本块的入口语句是程序的第一条语句，则称此基本块结点为流图的首结点。 如果在某个执行序列中，基本块B2紧跟在基本块B1之后执行，则从B1到B2有一条有向边，B1是B2的前驱，B2是B1的后继。 B1的最后一条语句不是无条件转移语句，并且在程序的语句序列中，B2紧跟在B1之后。 有一个条件/无条件转移语句从B1的最后一条语句转移到B2的第一条语句； （后继是程序执行过程中可能会出现的） 下次引用信息 算法：\n1. 把基本块中各变量在符号表中的下次引用信息域置为“无下次引用”、活跃信息域置为“活跃” 2. 从基本块出口到入口由后向前依次处理各语句，对每个三地址语句 i: x:=y op z，依次执行下述步骤： (1)把当前符号表中变量 x 的下次引用信息和活跃信息附加到语句 i 上； (2)把符号表中 x 的下次引用信息置为“无下次引用”，活跃信息置为“非活跃”； (3)把当前符号表中变量y和z的下次引用信息和活跃信息附加到语句 i 上； (4)把符号表中y和z的下次引用信息均置为 'i'，活跃信息均置为“活跃”。 先改左边的，再改右边的。先赋到语句上，再修改符号表。符号表中，左边的改为无非活，右边的改为语句序号，活跃。\n计算上图B4中的下次引用信息： 0. 初始化活跃信息表：每个变量都是 无下次引用、活跃 1. 从后往前，遇到赋值语句： (15)i := t10 ， 把i的下次引用信息和活跃信息附加到语句(15)上 (15) i := t10 i：无 非活 把符号表中i的信息置为无下次引用，非活跃 把当前符号表中的变量y和z，即t10的信息附加到语句i上 (15) i := t10 i：无 非活 t10：无 非活 把y和z符号表中信息，即t10符号表信息里下次引用信息信息置为i，活跃信息置为活跃 变量 下次 活跃 i 无 非活 ... ... ... t10 (15) 活跃 2. 继续往上回溯，遇到 (14) t10:=i+1 把t10符号表信息赋给(14) (14) t10:=i+1 t10 (15) 活跃 再把t10符号表信息置为 无 非活 把赋值表达式右边的变量符号表信息加到语句(14)上 (14) t10:=i+1 t10 (15) 活跃 i 无 非活 最后把右边变量符号表信息置为(14) 活 变量 下次 活跃 i (14) 活 ... ... ... t10 无 非活 ！！！易错！！！ 3. 往上回溯，遇到 (13) t2[t1]:=t9 先左：将t2[t1]的信息放到语句(13)上 (13) t2[t1]:=t9 t2 无 非活 t1 无 非活 由于这里引用了数组t2和t1的信息，所以 t2、t1的符号表信息要变成(13) 活跃 再右：将t9的信息放到语句(13)上： (13) t2[t1]:=t9 t2 无 非活 t1 无 非活 t9 无 非活 将t9 信息改为 (13) 活跃 符号表： 变量 下次 活跃信息 i (14) 活跃 t1 (13) 活跃 t2 (13) 活跃 ... ... ... t9 (13) 活跃 t10 无 非活 代码优化 基本块优化 删除公共表达式\n在一个基本块中，当第一次对表达式E求值之后，如果E中的运算对象都没有改变，再次对E求值，则除E的第一次出现之外，其余的都是冗余的公共表达式。 复制传播\n为减少重复计算，可以利用复制传播来删除公共表达式 思想：在复制语句f:=g之后，尽可能用g代替f 删除死代码\n如果对一个变量 x 求值之后却不引用它的值，则称对 x 求值的代码为死代码。 死块：控制流不可到达的块称为死块。 如果一个基本块是在某一条件为真时进入执行的，经数据流分析的结果知该条件恒为假，则此块是死块。 如果一个基本块是在某个条件为假时才进入执行，而该条件却恒为真，则这个块也是死块。 削弱计算强度\nx:=x+0 和 x:=x*1 执行的运算没有任何意义 应将这样的语句从基本块中删除。 改变计算次序\n互不依赖就可以改变次序 循环优化 循环展开\n循环次数在编译时可以确定 针对每次循环生成循环体（不包括调节部分和测试部分）的一个副本。 代码外提\n将循环结构中的与循环无关代码提到循环结构的外面（通常提到循环结构的前面），从而减少循环中的代码总数。 削弱计算强度\n用+代替*。低级运算代替高级运算 删除归纳变量\n如果循环中对变量i只有唯一的形如 i:=i+c 的赋值，并且c为循环不变量，则称i为循环中的基本归纳变量。 如果i是循环中的一个基本归纳变量，j在循环中的定值总可以化归为i的同一线性函数，即j:=c1*i+c2，这里c1和c2都是循环不变量，则称j是归纳变量，并称j与i同族。 当循环中含有归纳变量时，可视情况删除其中的一个或几个，以减少存在的个数。\n","date":"2024-09-20T08:27:11+08:00","permalink":"https://ffirestorm.github.io/p/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","title":"编译原理"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://ffirestorm.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://ffirestorm.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://ffirestorm.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://ffirestorm.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://ffirestorm.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://ffirestorm.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://ffirestorm.github.io/p/emoji-support/","title":"Emoji Support"}]